function [dat, sl_size] = searchlight_applymask_collate(dat2, file_list, varargin)

% Estimate local pattern weight on train data using SVR and searchlight and 
% apply weights to the test dataset 
%
% Usage:
% -------------------------------------------------------------------------
% [dat, sl_size] = searchlight_applymask(train, test, varargin)
%
%
% Inputs:
% -------------------------------------------------------------------------
% dat2          fmri_data test object
% file_list     Cellarray of list of file distributed in parallel.  Make sure
%               it is sorted correctly (e.g., sort_nat())
%
% Optional inputs:
% -------------------------------------------------------------------------
% 'r'           searchlight sphere radius (in voxel) (default: r = 3 voxels)
% 'parallel'    run subset of voxels to distribute on a cluster.  flag must
%               be followed by array specifing id and total number of jobs
%               (e.g., 'parallel',[1,10]);
% Outputs:
% -------------------------------------------------------------------------
% dat           This contains an fmri_data object that contain
%               correlation pattern expression values
% sl_size       The number of voxels within each searchlight. Based on this
%               number, you can detect searchlights on the edge (searchlights
%               with low sl_size should be on the edge of the brain.
%
% Author and copyright information:
% -------------------------------------------------------------------------
%     Copyright (C) 2015  Luke Chang & Wani Woo
%
%     This program is free software: you can redistribute it and/or modify
%     it under the terms of the GNU General Public License as published by
%     the Free Software Foundation, either version 3 of the License, or
%     (at your option) any later version.
%
%     This program is distributed in the hope that it will be useful,
%     but WITHOUT ANY WARRANTY; without even the implied warranty of
%     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
%     GNU General Public License for more details.
%
%     You should have received a copy of the GNU General Public License
%     along with this program.  If not, see <http://www.gnu.org/licenses/>.
%
% Example
% -------------------------------------------------------------------------
%
% [r, dat] = searchlight_applymask(train, test, 'r', 5);
%
% [r, dat] = searchlight_applymask(train, test, 'r', 5,'parallel',[1,10]);

% Programmers' notes:
%

%% set-up variables

% Defaults
r = 4; % default radius (in voxel)
doParallel = 0;

% parsing varargin
for i = 1:length(varargin)
    if ischar(varargin{i})
        switch varargin{i}
            % functional commands
            case 'r' % radius
                r = varargin{i+1};
                varargin{i} = []; varargin{i+1} = [];
            case 'parallel'
                doParallel = 1;
                tmp = varargin{i+1};
                dist_id = tmp(1);
                dist_n = tmp(2);
                varargin{i} = []; varargin{i+1} = [];
        end
    end
end

% Check inputs
if ~isa(dat2,'fmri_data')
    dat1 = fmri_data(dat2); dat2 = remove_empty(dat2);
end

if ~iscell(file_list)
    error('Make sure searchlight file list is a cellarray and that files are on the path')
end

vox_num = size(dat2.dat,1);
dist_n = length(file_list);
dat_comb = dat2;
for i = 1:dist_n
    load(file_list{i});
    dist_indx = select_voxels(i, dist_n, vox_num);
    dat_comb.dat(dist_indx) = dat.dat;
end

% if doParallel
%     fprintf(['Running in Parallel: id' num2str(dist_id) ' of ' num2str(dist_n)])
% 
%     dat1.dat = dat1.dat(dist_indx, :);
%     dat1.removed_voxels(~dist_indx) = true;
%     dat2.dat = dat2.dat(dist_indx, :);
%     dat2.removed_voxels(~dist_indx) = true;
% end
% 
% [~, idx] = min([size(dat1.dat,1) size(dat2.dat,1)]);
% 
% eval(['n = size(dat' num2str(idx) '.dat,1);']);
% 
% r_corr = NaN(n,size(dat2.dat,2));
% sl_size = zeros(n,1);
% 
% dd1 = dat1;
% dd2 = dat2;
% 
% fprintf('\n Calculating correlation for voxel                   ');
% for i = 1:n %(1):vox_to_run(10)
%     clc
%     fprintf('\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b%07d/%07d', i, n);
%     eval(['searchlight_indx = searchlight_sphere_prep(dat' num2str(idx) ...
%         '.volInfo.xyzlist(~dat' num2str(idx) '.removed_voxels,:), i, r);']);
%     dd1.dat = dat1.dat(searchlight_indx,:);
%     [yfit, wt] = alg_svr(dd1);
%     
%     dd2.dat = dat2.dat(searchlight_indx,:);
%     for j = 1:size(dd2.dat, 2)
%         r_corr(i,j) = corr(dd2.dat(:,j),wt.dat);
%     end
%     sl_size(i) = sum(searchlight_indx);
% end
% 
% dat = fmri_data;
% eval(['dat.volInfo = dat' num2str(idx) '.volInfo;']);
% eval(['dat.removed_voxels = dat' num2str(idx) '.removed_voxels;']);
% dat.dat = r_corr;

end

% ========== SUBFUNCTION ===========


function dist_indx = select_voxels(dist_id, dist_n, vox_num)
% preparation of distribution indx

dist_indx = false(vox_num,1);

unit_num = ceil(vox_num/dist_n);
unit = true(unit_num,1);

start_point = (unit_num.*(dist_id-1)+1);
end_point = min(start_point+unit_num-1, vox_num);
dist_indx(start_point:end_point) = unit(1:end_point-start_point+1);

dist_indx = logical(dist_indx);
end

