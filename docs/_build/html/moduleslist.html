<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>fmri_data &mdash; CanlabCore 1.0 documentation</title>
    
    <link rel="stylesheet" href="_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="CanlabCore 1.0 documentation" href="index.html" />
    <link rel="prev" title="CanlabCore documentation home" href="index.html" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="mat-modindex.html" title="MATLAB Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="index.html" title="CanlabCore documentation home"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">CanlabCore 1.0 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="toctree-wrapper compound">
<ul class="simple">
</ul>
</div>
<div class="section" id="module-&#64;fmri_data">
<span id="fmri-data"></span><h1>fmri_data<a class="headerlink" href="#module-@fmri_data" title="Permalink to this headline">¶</a></h1>
<dl class="function">
<dt id="&#64;fmri_data.canlab_connectivity_preproc">
<code class="descclassname">&#64;fmri_data.</code><code class="descname">canlab_connectivity_preproc</code><span class="sig-paren">(</span><em>dat</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@fmri_data.canlab_connectivity_preproc" title="Permalink to this definition">¶</a></dt>
<dd><p>This function prepares data for connectivity analysis by removing nuisance
variables and temporal filtering (high, low, or bandpass filter). This also
can extract values from given masks and return averaged activity or pattern
expression values.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="p">[</span><span class="n">preprocessed_dat</span><span class="p">,</span> <span class="n">roi_val</span><span class="p">]</span> <span class="o">=</span> <span class="n">canlab_connectivity_preproc</span><span class="p">(</span><span class="n">dat</span><span class="p">,</span> <span class="n">varargin</span><span class="p">)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Features:</th><td class="field-body"><ul class="first last simple">
<li>can regress out nuisance variables with any additional nuisance matrix</li>
<li>can remove signal from ventricle and white matter (calls
canlab_extract_ventricle_wm_timeseries.m and canlab_create_wm_ventricle_masks.m)</li>
<li>can do temporal filtering, including high-pass, low-pass, or bandpass
filtering (it uses conn_filter.m from conn toolbox; see subfunction below)</li>
<li>can extract data from given ROIs, and return averaged value or pattern
expression value (dot-product).</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt><em>Steps in order [with defaults]:</em></dt>
<dd><ol class="first last arabic simple">
<li>Remove nuisance covariates (and linear trend if requested)</li>
<li>Remove ventricle and white matter - needs structural images</li>
<li>Windsorize based on distribution of full data matrix</li>
<li>High/low/bandpass filter</li>
<li>Extract region-by-region average ROI or pattern expression data</li>
</ol>
</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Inputs:</th><td class="field-body"><dl class="first docutils">
<dt><strong>dat:</strong></dt>
<dd><p class="first last">fmri_data object with data</p>
</dd>
<dt><strong>dat.covariate:</strong></dt>
<dd><p class="first last">basic nuisance matrix</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Optional inputs:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body"><dl class="first docutils">
<dt><strong>additional_nuisance</strong></dt>
<dd><p class="first last">When you have additional nuisance variables that you want
regress out from the data, you can use this option. This
option should be followed by a nuisance matrix (or values).
The matrix should have the same number of rows with the
number of images.</p>
</dd>
<dt><strong>vw</strong></dt>
<dd><p class="first">When you want to regress out signals from ventricle and
white matter, you can use this option. To use this option,
You should provide the directory where the subjects&#8217; data
are saved using the &#8216;datdir&#8217; (for example, see below).
Requires specific subdirectory structure (CANlab) - see code.</p>
<p class="last">You can also choose what to use to remove ventricle and
white matter signal between raw data or top 5 PCA
components (default). You can just put &#8216;raw&#8217; if you want to
use raw signal than PCA compoenents.
also see: canlab_extract_ventricle_wm_timeseries.m
canlab_create_wm_ventricle_masks.m)
- <em>Example:</em> &#8216;vw&#8217;, &#8216;datdir&#8217;, subject_dir, &#8216;raw&#8217;</p>
</dd>
<dt><strong>windsorize:</strong></dt>
<dd><p class="first last">Windsorizing entire data matrix to k x STD.
- <em>Example:</em> &#8216;windsorize&#8217;, 5 (windsorize to 5 STD)</p>
</dd>
<dt><strong>linear_trend:</strong></dt>
<dd><p class="first last">This option will include the linear trend to nuisance variables.</p>
</dd>
<dt><strong>hpf&#8217;, &#8216;lpf&#8217;, or &#8216;bpf:</strong></dt>
<dd><p class="first">This option will do temporal filtering.
- &#8216;hpf&#8217;: high pass filter. This option should be followed by</p>
<blockquote>
<div><p>the lower bound of the frequency (e.g., .01 Hz [= 100 sec]).</p>
</div></blockquote>
<ul class="last">
<li><dl class="first docutils">
<dt>&#8216;lpf&#8217;: low pass filter. This option should be followed by</dt>
<dd><p class="first last">the upper bound of the frequency (e.g., .25 Hz [= 4 sec]).</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>&#8216;bpf&#8217;: bandpass filter. This should be followed by lower</dt>
<dd><p class="first last">and upper bounds of the frequency (e.g., [.01 .25]).
After the frequency value, you need to provide TR.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><em>Example:</em> &#8216;hpf&#8217;, .01, TR</dt>
<dd><p class="first last">&#8216;bpf&#8217;, [.01 .25], TR</p>
</dd>
</dl>
</li>
</ul>
</dd>
<dt><strong>extract_roi:</strong></dt>
<dd><p class="first">This option will extract data from ROIs specified. This
option should be followed by one or more masks.
For one mask (potentially multiple ROIs, enter a char array with the mask name.
For multiple masks (1 or more), enter in a cell array of mask names.
You can specify methods with &#8216;roi_methods&#8217; option.
- &#8216;average_over&#8217; (default): calculate averaged value across the ROIs.
- &#8216;pattern_expression&#8217;: calculate dot-products between</p>
<blockquote>
<div><p>pattern mask and data</p>
</div></blockquote>
<ul class="last">
<li><dl class="first docutils">
<dt>&#8216;unique_mask_values&#8217; (default): will divide a mask into</dt>
<dd><p class="first last">multiple regions that have different discrete values.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>&#8216;contiguous_regions&#8217;: will divide a mask into multiple</dt>
<dd><p class="first last">contiguous regions.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>&#8216;whole&#8217;: will do average_over or pattern_expression across</dt>
<dd><p class="first last">all the voxels within the mask.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><em>Example:</em> &#8216;extract_roi&#8217;, mask, &#8216;contiguous_regions&#8217;</dt>
<dd><p class="first last">&#8216;extract_roi&#8217;, mask, &#8216;pattern_expression&#8217;</p>
</dd>
</dl>
</li>
</ul>
</dd>
<dt><strong>no_preproc:</strong></dt>
<dd><p class="first last">If you want to skip the preprocessing part, and want to
extract ROI values only, you can use this option.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Outputs:</th><td class="field-body"><dl class="first docutils">
<dt><strong>preprocessed_dat:</strong></dt>
<dd><p class="first last">fmri_data object after removing nuisance variables and
filtering temporal confounds.</p>
</dd>
<dt><strong>roi_val:</strong></dt>
<dd><p class="first last">returns values extracted from ROIs in cell arrays (if there are many different ROIs).
Each cell will have roi_val.dat, roi_val.mask_name, and roi_val.methods.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Examples:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>roi_masks = which(&#39;weights_NSF_grouppred_cvpcr.img&#39;);
[preprocessed_dat, roi_val] = canlab_connectivity_preproc(dat, &#39;vw&#39;, &#39;datdir&#39;,
       subject_dir, &#39;bpf&#39;, [.008 .25], TR, &#39;extract_roi&#39;, roi_masks, &#39;pattern_expression&#39;);
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="&#64;fmri_data.create">
<code class="descclassname">&#64;fmri_data.</code><code class="descname">create</code><span class="sig-paren">(</span><em>obj</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@fmri_data.create" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an object from an empty obj structure, assigning fieldname/value
pairs as optional arguments.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>[obj = create(obj, varargin)
</pre></div>
</div>
<p>Used in fmri_data.m class constructor.
if &#8216;noverbose&#8217; is entered, suppress output</p>
</dd></dl>

<dl class="function">
<dt id="&#64;fmri_data.extract_roi_averages">
<code class="descclassname">&#64;fmri_data.</code><code class="descname">extract_roi_averages</code><span class="sig-paren">(</span><em>obj</em>, <em>mask_image</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@fmri_data.extract_roi_averages" title="Permalink to this definition">¶</a></dt>
<dd><p>This fmri_data method a extracts and averages data stored in an fmri_data object 
from a set of ROIs defined in a mask.</p>
<p>If no mask_image is entered, it uses the mask defined with the fmri_data object as a default.</p>
<dl class="docutils">
<dt>If mask_image is a new image file name, this method:</dt>
<dd><ol class="first last arabic simple">
<li>Defines an fmri_mask_image object using create_fmri_mask</li>
<li>Maps to the space in fmri_data object using resample_to_image_space</li>
</ol>
</dd>
</dl>
<p>Regions to average over can be either regions of contiguous voxels
bounded by voxels with values of 0 or NaN, which are considered non-data
values, or regions defined by unique integer codes in the mask image
(i.e., for atlas images with unique codes for each defined region.)</p>
<p>Mask/Atlas image does NOT have to be in the same space as the images to
extract from.  It will be remapped/resliced.
NOTE: Mask is <em>reloaded</em> from original data if space is remapped, and you
cannot use manual thresholding of the mask. This is a feature of the
map_to_image_space method and scn_map_image</p>
<p>Extracted data is returned in single data format.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>[[cl, clroimean, clpattern] = extract_roi_averages(fmri_data obj, [mask_image], [average_over])
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Inputs:</th><td class="field-body"><ol class="first arabic simple">
<li>char array of strings containing 4D image file names (data extracted from these)</li>
<li>mask_image to extract from.</li>
</ol>
</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Optional inputs:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body"><dl class="first docutils">
<dt><strong>how to average</strong></dt>
<dd><p class="first last">Default = &#8216;unique_mask_values&#8217; to average over unique integer codes in the mask image
bounded by voxels of 0 or NaN (non-data values)
(i.e., for atlas images with unique codes for each defined region)
Alt. option = &#8216;contiguous_regions&#8217; to average over contiguous voxels</p>
</dd>
<dt><strong>pattern_expression</strong></dt>
<dd><p class="first">Use values in mask images to get weighted average within each
region, rather than simple average.  See also apply_mask with
&#8216;pattern_expression&#8217; option.</p>
<p class="last">Optional outputs (varargout): 
[cl, cl_roimean, cl_roipattern] = ...
roimean: pattern expression is average over ROI (unit vector)
roipattern: pattern expression is dot product of activity and mean-centered pattern weights</p>
</dd>
<dt><strong>nonorm</strong></dt>
<dd><p class="first last">Turn off L1 norm in pattern expression.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Examples:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="n">imgs_to_extract_from</span> <span class="o">=</span> <span class="n">filenames</span><span class="p">(</span><span class="s">&#39;w*.nii&#39;</span><span class="p">,</span><span class="s">&#39;char&#39;</span><span class="p">);</span>
<span class="n">mask_image</span> <span class="o">=</span> <span class="n">which</span><span class="p">(</span><span class="s">&#39;anat_lbpa_thal.img&#39;</span><span class="p">);</span>
<span class="p">[</span><span class="n">cl</span><span class="p">,</span> <span class="n">clroimean</span><span class="p">,</span> <span class="n">clpattern</span><span class="p">]</span> <span class="o">=</span> <span class="n">extract_image_data</span><span class="p">(</span><span class="n">imgs_to_extract_from</span><span class="p">,</span> <span class="n">mask_image</span><span class="p">);</span>

<span class="n">region_obj</span> <span class="o">=</span> <span class="n">extract_roi_averages</span><span class="p">(</span><span class="n">data_obj</span><span class="p">,</span> <span class="n">mask_char_name</span><span class="p">,</span> <span class="s">&#39;pattern_expression&#39;</span><span class="p">,</span> <span class="s">&#39;contiguous_regions&#39;</span><span class="p">);</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name" colspan="2">Related functions:</th></tr>
<tr class="field-odd field"><td>&nbsp;</td><td class="field-body">For an non-object-oriented alternative, see extract_image_data.m</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="&#64;fmri_data.horzcat">
<code class="descclassname">&#64;fmri_data.</code><code class="descname">horzcat</code><span class="sig-paren">(</span><em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@fmri_data.horzcat" title="Permalink to this definition">¶</a></dt>
<dd><p>Implements the horzcat ([a b]) operator on image_vector objects across voxels.
Requires that each object has an equal number of columns and voxels</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>function s = horzcat(varargin)
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Examples:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>c = [dat1 dat2];
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="&#64;fmri_data.hrf_fit">
<code class="descclassname">&#64;fmri_data.</code><code class="descname">hrf_fit</code><span class="sig-paren">(</span><em>obj</em>, <em>TR</em>, <em>Runc</em>, <em>T</em>, <em>method</em>, <em>mode</em><span class="sig-paren">)</span><a class="headerlink" href="#@fmri_data.hrf_fit" title="Permalink to this definition">¶</a></dt>
<dd><p>HRF estimation on fmri_data class object</p>
<p>HRF estimation function for a single voxel;</p>
<p>Implemented methods include: IL-model (Deterministic/Stochastic), FIR
(Regular/Smooth), and HRF (Canonical/+ temporal/+ temporal &amp; dispersion)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Inputs:</th><td class="field-body"><dl class="first docutils">
<dt><strong>obj</strong></dt>
<dd><p class="first last">fMRI object</p>
</dd>
<dt><strong>TR</strong></dt>
<dd><p class="first last">time resolution</p>
</dd>
<dt><strong>Runs</strong></dt>
<dd><p class="first last">expermental design</p>
</dd>
<dt><strong>T</strong></dt>
<dd><p class="first last">length of estimated HRF ij seconds</p>
</dd>
<dt><strong>type</strong></dt>
<dd><p class="first last">Model type: &#8216;FIR&#8217;, &#8216;IL&#8217;, or &#8216;CHRF&#8217;</p>
</dd>
<dt><strong>mode</strong></dt>
<dd><p class="first last">Mode</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Model Types:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<ol class="upperalpha">
<li><dl class="first docutils">
<dt><strong>Fit HRF using IL-function</strong></dt>
<dd><dl class="first docutils">
<dt>Choose mode (deterministic/stochastic)</dt>
<dd><ul class="first last simple">
<li>0 - deterministic aproach</li>
<li>1 - simulated annealing approach</li>
</ul>
</dd>
</dl>
<p class="last">Please note that when using simulated annealing approach you
may need to perform some tuning before use.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><strong>Fit HRF using FIR-model</strong></dt>
<dd><dl class="first last docutils">
<dt>Choose mode (FIR/sFIR)</dt>
<dd><ul class="first last simple">
<li>0 - FIR</li>
<li>1 - smooth FIR</li>
</ul>
</dd>
</dl>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><strong>Fit HRF using FIR-model</strong></dt>
<dd><dl class="first last docutils">
<dt>Choose mode (FIR/sFIR)</dt>
<dd><ul class="first last simple">
<li>0 - FIR</li>
<li>1 - smooth FIR</li>
</ul>
</dd>
</dl>
</dd>
</dl>
</li>
</ol>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Examples:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<p>SIMULATE DATA AND RUN</p>
<div class="highlight-python"><div class="highlight"><pre>%params for sim and fitting
TR = 2;   % repetition time (sec)
n = 200;  % time points measured (for simulation) must be multiple of 10
T = 30;   % duration of HRF to estimate (seconds)
nconds = 2; % num conditions
nevents = 8; % events per condition

% Create fake data
h = spm_hrf(TR);
y = zeros(n, 1);

% onsets - indicator
Condition = {};
for i = 1:nconds
    Condition{i} = zeros(n,1);
    wh = randperm(n);
    Condition{i}(wh(1:nevents)) = 1;

    ytmp{i} =  conv(Condition{i}, h);
    ytmp{i} = ytmp{i}(1:n);
end

y = sum(cat(2, ytmp{:}), 2);

dat = fmri_data(&#39;VMPFC_mask_neurosynth.img&#39;);  % AVAILABLE ON WIKI IN MASK GALLERY
dat = threshold(dat, [5 Inf], &#39;raw-between&#39;);

v = size(dat.dat, 1); % voxels in mask
dat.dat = repmat(y&#39;,v, 1) + .1 * randn(v, n);

% Fit data - estimate HRFs across the brain mask
[params_obj hrf_obj] = hrf_fit(dat,TR, Condition, T,&#39;FIR&#39;, 1);

hrf = fmri_data(&#39;HRF_timecourse_cond0001.img&#39;);
hrf = remove_empty(hrf);
create_figure(&#39;hrfs&#39;, 1, 2); 
plot(hrf.dat&#39;);
title(&#39;Condition 1&#39;)
hrf = fmri_data(&#39;HRF_timecourse_cond0002.img&#39;);
hrf = remove_empty(hrf);
subplot(1, 2, 2);
plot(hrf.dat&#39;);
title(&#39;Condition 2&#39;)
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="&#64;fmri_data.plot">
<code class="descclassname">&#64;fmri_data.</code><code class="descname">plot</code><span class="sig-paren">(</span><em>fmridat</em>, <em>plotmethod</em><span class="sig-paren">)</span><a class="headerlink" href="#@fmri_data.plot" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot means by condition
plot(fmri_data_object, &#8216;means_for_unique_Y&#8217;)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Inputs:</th><td class="field-body"><dl class="first docutils">
<dt>Plot methods:</dt>
<dd><ul class="first last simple">
<li>plot data matrix</li>
<li>plot(fmri_data_object)</li>
</ul>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="n">plot</span><span class="p">(</span><span class="n">fmridat</span><span class="p">,</span> <span class="p">[</span><span class="n">plotmethod</span><span class="p">])</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Outputs:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<p>5 plots and an SPM orthviews presentation of the data.  In the below 
and elsewhere, &#8220;image&#8221; connotes a 3D brain volume captured every TR.</p>
<blockquote>
<div><dl class="docutils">
<dt><strong>subplot 1:</strong></dt>
<dd>the fMRI data itself. Color is intensity of signal.</dd>
<dt><strong>subplot 2:</strong></dt>
<dd>presented as a histogram of values for every voxel collected.
The low values are typically out-of-brain voxels, as there is
no signal there.</dd>
<dt><strong>subplot 3:</strong></dt>
<dd>each point is an image.  The point&#8217;s X value is the mean
intensity of every voxel in that image, and the Y value is the
stdev of intensities for all voxels in that image.</dd>
<dt><strong>subplot 4:</strong></dt>
<dd>covariance between images</dd>
<dt><strong>subplot 5:</strong></dt>
<dd>each point is an image (case = image).  X value is image
number in the run, Y is image mean intensity, and the size of
the circular marker represents stdev for that image</dd>
<dt><strong>Orthviews:</strong></dt>
<dd>mean and STD for a given voxel averaged over time.  Note that
the values for mean and STD here are higher than in the plots
above. That is because mean and STD are calculated here by
voxel, but in the plots above they are calculated by image.
Images also include out-of-brain areas.</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="&#64;fmri_data.predict">
<code class="descclassname">&#64;fmri_data.</code><code class="descname">predict</code><span class="sig-paren">(</span><em>obj</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@fmri_data.predict" title="Permalink to this definition">¶</a></dt>
<dd><p>Predict outcome (Y) from brain data and test cross-validated error rate for an fmri_data object</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="p">[</span><span class="n">cverr</span><span class="p">,</span> <span class="n">stats</span><span class="p">,</span> <span class="n">optional_outputs</span><span class="p">]</span> <span class="o">=</span> <span class="n">predict</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">varargin</span><span class="p">)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Features:</th><td class="field-body"><ul class="first simple">
<li>flexible specification of algorithm by function name</li>
<li>k-fold cross-validation, default = 5-fold, can enter custom fold membership</li>
<li>folds are stratified on outcome</li>
<li>choice of multiple error metrics (class loss, mse, etc.)</li>
<li>by default, chooses error metric based on outcome type (classes vs. continuous-valued)</li>
<li>returns all outputs for each fold returned by the algorithm in optout cell array variable</li>
<li>bootstrapping of weights built in [optional keyword]</li>
<li>select variable number of components (for pcr-based techniques)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Inputs:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>obj is mandatory, rest are optional</dt>
<dd><dl class="first last docutils">
<dt><strong>obj:</strong></dt>
<dd>fmri_data or image_vector object, with fields .dat (data used to predict) and .Y (outcome)</dd>
</dl>
</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name" colspan="2">Optional inputs:</th></tr>
<tr class="field-odd field"><td>&nbsp;</td><td class="field-body"><p class="first">(with their default values)</p>
<dl class="docutils">
<dt><strong>nfolds</strong> = 5</dt>
<dd><p class="first last">number of folds</p>
</dd>
<dt><strong>nfolds</strong> = [vector of integers]</dt>
<dd><p class="first last">can also input vector of integers for holdout set IDs</p>
</dd>
<dt><strong>error_type</strong> = mcr</dt>
<dd><p class="first last">mcr, mse: misclassification rate or mean sq. error</p>
</dd>
<dt><strong>algorithm_name</strong> = &#8216;cv_regress&#8217;</dt>
<dd><p class="first last">name of m-file defining training/test function</p>
</dd>
<dt><strong>useparallel</strong> = 1</dt>
<dd><p class="first last">Use parallel processing, if available; follow by 1 for yes, 0 for no</p>
</dd>
<dt><strong>bootweights</strong> = 0</dt>
<dd><p class="first last">bootstrap voxel weights; enter bootweights do bootstrapping of weight maps (based on all observations)</p>
</dd>
<dt><strong>savebootweights</strong></dt>
<dd><p class="first last">save bootstraped weights (useful for combining across multiple iterations of predict())</p>
</dd>
<dt><strong>bootsamples</strong> = 100</dt>
<dd><p class="first last">number of bootstrap samples to use</p>
</dd>
<dt><strong>numcomponents</strong> = xxx:</dt>
<dd><p class="first last">save first xxx components (for pca-based methods)</p>
</dd>
<dt><strong>nopcr</strong></dt>
<dd><p class="first last">for cv_lassopcr and cv_lassopcrmatlab: do not do pcr, use original variables</p>
</dd>
<dt><strong>lasso_num</strong> = xxx</dt>
<dd><p class="first last">followed by number of components/vars to retain after shrinkage</p>
</dd>
<dt><strong>hvblock</strong> = [h,v]</dt>
<dd><p class="first last">use hvblock cross-validation with a block size of &#8216;h&#8217; (0 reduces to v-fold xval) and
number of test observations &#8216;v&#8217; (0 reduces to h-block xval)</p>
</dd>
<dt><strong>rolling</strong> = [h,v,g]</dt>
<dd><p class="first last">use rolling cross-validation with a block size of &#8216;h&#8217; (0 reduces to v-fold xval) and
number of test observations &#8216;v&#8217; (0 reduces to h-block xval), and a training size
of g * 2 surrounding hv</p>
</dd>
<dt><strong>verbose</strong> = 1</dt>
<dd><p class="first last">Set to 0 to suppress output to command window</p>
</dd>
<dt><strong>platt_scaling</strong></dt>
<dd><p class="first last">calculate cross-validated platt scaling if using SVM.
Softmax parameters [A,B] are in other_output{3}</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Algorithm choices:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body"><p class="first">You can input the name (as a string array) of any algorithm with the
appropriate inputs and outputs. i.e., this can either be one of the
built-in choices below, or the name of another m-file.
The format for algorithm functions is :
[yfit, other_outputs] = predfun(xtrain, ytrain, xtest, optional_inputs)
Each algorithm can take/interpret its own optional inputs.
For bootstrapping of weights, algorithms MUST RETURN 3 OUTPUTS
(programming &#8216;feature&#8217;)</p>
<p>To choose an algorithm, enter &#8216;algorithm_name&#8217; followed by a text string
with a built-in algorithm name, or a function handle for a custom algorithm
Built-in algorithm choices include:</p>
<dl class="docutils">
<dt><strong>cv_multregress:</strong></dt>
<dd><p class="first last">[default] multiple regression</p>
</dd>
<dt><strong>cv_univregress:</strong></dt>
<dd><p class="first last">Average predictions from separate univariate regression of outcome on each feature</p>
</dd>
<dt><strong>cv_svr:</strong></dt>
<dd><p class="first last">Support vector regression with Spider package; requires spider</p>
</dd>
<dt><strong>cv_pcr:</strong></dt>
<dd><p class="first last">Cross-validated principal components regression</p>
</dd>
<dt><strong>cv_lassopcr:</strong></dt>
<dd><p class="first last">Cross-val LASSO-PCR; can enter &#8216;lasso_num&#8217; followed by components to retain by shrinkage
NOTE: can enter &#8216;EstimateParams&#8217; to use shrankage
lasso method based on the estimated optimal lambda
that minimizes the mean squared error (MSE) of nested
cross-validation models. Output of nested cv model is
saved in stats.other_output_cv{:,3}. Output includes
&#8216;Lambda&#8217; parameter and min MSE value.</p>
</dd>
<dt><strong>cv_lassopcrmatlab:</strong></dt>
<dd><p class="first last">Cross-val LASSO-PCR; can enter &#8216;lasso_num&#8217; followed by components to retain by shrinkage
NOTE: this uses the matlab implementation of LASSO,
but can also run ridge or elastic net. Reduces to PCR
when no lasso_num is entered by default.  Use MSE for
predicting continuous data and MCR for classifying
binary data.
NOTE: You can input any optional inputs that lassoglm
takes.
Enter &#8216;Alpha&#8217;, (0,1] as optional inputs to
run ridge (Alpha approaches 0, but excluding 0), lasso (Alpha = 1), or elastic
net (Alpha between 0 and 1)
NOTE: Requires Matlab R2012a and higher.
NOTE: Optional input: &#8216;EstimateParams&#8217; - this will
use grid search and nested cross validation to
estimate Lambda and Alpha.  Output is saved in
stats.other_output_cv{:,3}.  Output includes &#8216;Alpha&#8217;
parameter which is the elastic net mixture value
between l1 and l2 regularization, &#8216;Lambda&#8217; parameter,
which is amount of LASSO regularization/shrinkage, and
&#8216;errorMatrix&#8217;, which is the amount of error for each
parameter combination.  Use
imagesc(obj.stats_other_output_cv{:,3}.errorMatrix)
to view matrix.  Min of this matrix is the best
fitting parameters.</p>
</dd>
<dt><strong>cv_svm:</strong></dt>
<dd><p class="first last">Cross-val support vector machine using Spider package
NOTE: This is sensitive to scale of outputs! Use -1 , 1
NOTE: Optional inputs: Slack var parameter: &#8216;C&#8217;, 1 [default], &#8216;C&#8217;, 3 etc.
Distance from hyperplane saved in
stats.other_output_cv{:,2}.  Recommend using the reordered
cross-validated distance from hyperplane saved in stats.other_output{3}
stats.dist_from_hyperplane_xval =  cross-validated distance from hyperplane
stats.weight_obj = voxel (variable) weight object
e.g., orthviews(stats.weight_obj)
Intercept for calculating dist from hy is in stats.other_output_cv{:,3}
e.g., dist_hy = stats.weight_obj.dat&#8217; * obj.dat, where obj is a new set of test images
NOTE: To run nonlinear SVM using radial basis
function.  Add &#8216;rbf&#8217; followed by size of sigma (e.g., 2).
NOTE: To estimate some of the parameters using
nested cross validation add &#8216;EstimateParams&#8217; as optional input.
NOTE: To run multiclass SVM (i.e., one vs rest) add
&#8216;MultiClass&#8217; as optional input.  Important - Obj.Y must be a matrix (data x
class) with a column of 1 and -1 indicating each
class.  For example, if using 3 classes, then obj.Y
must have 3 columns.
NOTE: To run a balanced SVM where the number of cases for each class are unequal (i.e., one vs rest) add
&#8216;Balanced&#8217; as optional input, followed by a numerical value indicating the ridge amount (e.g., 0.01).</p>
</dd>
<dt><strong>cv_multilevel_glm:</strong></dt>
<dd><p class="first last">Runs glmfit_multilevel. Must pass in &#8216;&#8217;subjIDs&#8217;&#8217; followed by an array specifying which subject each trial belongs to
Subjects&#8217; trials must all be &#8220;adjacent&#8221;, i.e., don&#8217;t
put some of subject 1&#8217;s trials at the beginning and
other trials at the end &#8211; subjIDs does not handle
this case correctly. Also, 2ND LEVEL PREDICTORS NOT
CURRENTLY SUPPORTED.  code can be expanded to support this.
mean-centering X and/or Y will NOT impact the
predictor betas.  Note that it WILL impact the intercept
esimate as well as how much variance is explained
(pred_outcome_r).  Stratified CV partition not
supported either, pass in custom holdout set.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Outputs:</th><td class="field-body"><dl class="first docutils">
<dt><strong>Y:</strong></dt>
<dd><p class="first last">Copy of outcome data to be predicted</p>
</dd>
<dt><strong>algorithm_name:</strong></dt>
<dd><p class="first last">Name of algorithm; see options above</p>
</dd>
<dt><strong>function_call:</strong></dt>
<dd><p class="first last">String of the command evaluated to call the prediction function</p>
</dd>
<dt><strong>function_handle:</strong></dt>
<dd><p class="first last">Handle for the command evaluated to call the prediction function</p>
</dd>
<dt><strong>yfit:</strong></dt>
<dd><p class="first last">Predicted outcome data (cross-validated)</p>
</dd>
<dt><strong>err:</strong></dt>
<dd><p class="first last">Residuals/misclassification vector (cross-validated)</p>
</dd>
<dt><strong>error_type:</strong></dt>
<dd><p class="first last">Name of error metric used for cverr</p>
</dd>
<dt><strong>cverr:</strong></dt>
<dd><p class="first last">Cross-validated error</p>
</dd>
<dt><strong>nfolds:</strong></dt>
<dd><p class="first">Number of folds in stratified cross-validation, or
vector of integers for membership in custom holdout set of each fold</p>
<blockquote class="last">
<div><ul class="simple">
<li>if k = 1, will estimate weights for full data object
and not crossvalidate (useful for bootstrapping)</li>
</ul>
</div></blockquote>
</dd>
<dt><strong>cvpartition:</strong></dt>
<dd><p class="first last">Cross-val partition object or structure with fold info</p>
</dd>
<dt><strong>teIdx:</strong></dt>
<dd><p class="first last">Cell array of logical vectors with test samples in each fold</p>
</dd>
<dt><strong>trIdx:</strong></dt>
<dd><p class="first last">Cell array of logical vectors with training samples in each fold</p>
</dd>
<dt><strong>other_output:</strong></dt>
<dd><p class="first last">Other outputs returned by the algorithm; number and nature depend on algo choice; e.g., beta weights, svr weights, etc.
For many algorithms, other_output{1} is a vector of
weights on variables (e.g., voxels)</p>
</dd>
<dt><strong>other_output_descrip:</strong></dt>
<dd><p class="first last">String description of other outputs</p>
</dd>
<dt><strong>other_output_cv:</strong></dt>
<dd><p class="first last">Other outputs for each cross-validation fold</p>
</dd>
<dt><strong>other_output_cv_descrip:</strong></dt>
<dd><p class="first last">Other output from algorithm - for each CV fold</p>
</dd>
<dt><strong>mse:</strong></dt>
<dd><p class="first last">For regression only; mean squared error</p>
</dd>
<dt><strong>rmse:</strong></dt>
<dd><p class="first last">For regression only; root mean squared error</p>
</dd>
<dt><strong>meanabserr:</strong></dt>
<dd><p class="first last">For regression only; mean absolute error</p>
</dd>
<dt><strong>pred_outcome_r:</strong></dt>
<dd><p class="first last">For regression only; prediction-outcome correlation</p>
</dd>
<dt><strong>WTS:</strong></dt>
<dd><p class="first last">bootstrapped weights on voxels</p>
</dd>
<dt><strong>weight_obj:</strong></dt>
<dd><p class="first last">for some algorithms, an fmri_data object with the predictive weights (from full sample)</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Examples:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>obj = fmri_data;
obj.dat = randn(30, 50); %    30 voxels, 50 images (observations)
obj.Y = obj.dat&#39; * rand(30, 1) + randn(50, 1); %    toy Y, linear combo of X plus noise
[cverr, stats, regression_outputs] = predict(obj);

Simulated example with 100 observations, 1000 voxels, with bootstrapping
dat = fmri_data;
dat.Y = rand(100, 1);
dat.dat = repmat(dat.Y&#39;, 1000, 1) + 10*rand(1000, 100);
[err,stats] = predict(dat, &#39;bootweights&#39;, &#39;algorithm_name&#39;, &#39;cv_lassopcr&#39;);

[cverr, stats, regression_outputs] = predict(obj, &#39;nfolds&#39;, 3, &#39;error_type&#39;, &#39;meanabserr&#39;);
[cverr, stats, regression_outputs] = predict(obj, &#39;algorithm_name&#39;, &#39;cv_univregress&#39;, &#39;error_type&#39;, &#39;meanabserr&#39;);
[cverr, stats, optout] = predict(obj, &#39;algorithm_name&#39;, &#39;cv_lassopcr&#39;, &#39;lasso_num&#39;, 5, &#39;nfolds&#39;, 5, &#39;error_type&#39;, &#39;mse&#39;, &#39;bootweights&#39;);
[cverr, stats, optout] = predict(dat, &#39;algorithm_name&#39;, &#39;cv_svm&#39;, &#39;nfolds&#39;, 5, &#39;error_type&#39;, &#39;mse&#39;);
[cverr, stats, optout] = predict(dat, &#39;algorithm_name&#39;, &#39;cv_svm&#39;, &#39;rbf&#39;, 2, &#39;nfolds&#39;, 5, &#39;error_type&#39;, &#39;mse&#39;); %SVM w/ radial basis function
[cverr, stats, optout] = predict(dat, &#39;algorithm_name&#39;, &#39;cv_svm&#39;, &#39;rbf&#39;, 2, &#39;EstimateParams&#39;, &#39;nfolds&#39;, 5, &#39;error_type&#39;, &#39;mse&#39;); %SVM w/ radial basis function w/ parameters estimated using nested cross-valdiation
[cverr, stats, optout] = predict(dat, &#39;algorithm_name&#39;, &#39;cv_svm&#39;, &#39;nfolds&#39;, 5, &#39;MultiClass&#39;, &#39;error_type&#39;, &#39;mse&#39;);

Elastic net with first 10 components:
[cverr, stats, optout] = predict(dat_masked, &#39;algorithm_name&#39;, &#39;cv_lassopcrmatlab&#39;, &#39;nfolds&#39;, 5, &#39;error_type&#39;, &#39;mse&#39;, &#39;numcomponents&#39;, 10, &#39;Alpha&#39;, .5); stats.pred_outcome_r

Ridge with first 10 components:
[cverr, stats, optout] = predict(dat_masked, &#39;algorithm_name&#39;, &#39;cv_lassopcrmatlab&#39;, &#39;nfolds&#39;, 5, &#39;error_type&#39;, &#39;mse&#39;, &#39;numcomponents&#39;, 10, &#39;Alpha&#39;, 0.00001); stats.pred_outcome_r

Lasso with all components, but shrink to retain 2 components only:
[cverr, stats, optout] = predict(dat, &#39;algorithm_name&#39;, &#39;cv_lassopcrmatlab&#39;, &#39;nfolds&#39;, whfolds, &#39;nopcr&#39;, &#39;lasso_num&#39;, 2, &#39;Alpha&#39;, 1);
[cverr, stats, optout] = predict(dat, &#39;algorithm_name&#39;, &#39;cv_lassopcr&#39;, &#39;nfolds&#39;, whfolds, &#39;lasso_num&#39;, 2);

Lasso with the shrinkage methods based on the estimated optimal lambda that minimizes MSE of nested cross-validation models.
[cverr, stats, optout] = predict(dat, &#39;algorithm_name&#39;, &#39;cv_lassopcr&#39;, &#39;nfolds&#39;, whfolds, &#39;estimateparam&#39;);
[cverr, stats, optout] = predict(dat, &#39;algorithm_name&#39;, &#39;cv_lassopcr&#39;, &#39;nfolds&#39;, 5, &#39;estimateparam&#39;);

Lasso without doing PCR:
[cverr, stats, optout] = predict(dat, &#39;algorithm_name&#39;, &#39;cv_lassopcrmatlab&#39;, &#39;nfolds&#39;, whfolds, &#39;nopcr&#39;, &#39;lasso_num&#39;, 2, &#39;Alpha&#39;, 1);
[cverr, stats, optout] = predict(dat, &#39;algorithm_name&#39;, &#39;cv_lassopcr&#39;, &#39;nfolds&#39;, whfolds, &#39;lasso_num&#39;, 2, &#39;nopcr&#39;);
[cverr, stats, optout] = predict(dat, &#39;algorithm_name&#39;, &#39;cv_lassopcr&#39;, &#39;nfolds&#39;, 5, &#39;estimateparam&#39;, &#39;nopcr&#39;);

Lasso pcr using hvblock cross-validation on time-series, h = 3, v = 5;
[cverr, stats, optout] = predict(dat, &#39;algorithm_name&#39;, &#39;cv_lassopcr&#39;, &#39;hvblock&#39;,[3,5]);

Output display:
orthviews(stats.weight_obj)
line_plot_multisubject(stats.yfit, stats.Y, &#39;subjid&#39;, id_numbers);
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">See also:</th><td class="field-body"><p class="first">predict_test_suite method for fmri_data, which runs predict with multiple
options and summarizes output.</p>
<p class="last">xval_regression_multisubject, xval_lasso_brain</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="&#64;fmri_data.predict_test_suite">
<code class="descclassname">&#64;fmri_data.</code><code class="descname">predict_test_suite</code><span class="sig-paren">(</span><em>dat</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@fmri_data.predict_test_suite" title="Permalink to this definition">¶</a></dt>
<dd><p>Run a set of cross-validated prediction algorithms on an fmri_data object
and plot the outcome.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>[allcverr, allyhat] = predict_test_suite(dat, [optional inputs])
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Functionality:</th><td class="field-body"><ul class="first simple">
<li>Requires matlab 2012a or later for full functionality</li>
<li>Handles categorical or continuous outcomes automatically</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Inputs:</th><td class="field-body"><dl class="first docutils">
<dt><strong>dat:</strong></dt>
<dd><p class="first last">an fMRI data object. 
dat.Y must be assigned, and must have continuous or binary outcomes assigned.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Optional:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt><strong>quick:</strong></dt>
<dd>Skip extended output</dd>
<dt><strong>nfolds:</strong></dt>
<dd>Followed by number of folds or custom holdout vector (default = 5-fold balanced)</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Examples:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="n">predict_test_suite</span><span class="p">(</span><span class="n">dat</span><span class="p">,</span> <span class="s">&#39;nfolds&#39;</span><span class="p">,</span> <span class="n">subjid</span><span class="p">);</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="&#64;fmri_data.regress">
<code class="descclassname">&#64;fmri_data.</code><code class="descname">regress</code><span class="sig-paren">(</span><em>dat</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@fmri_data.regress" title="Permalink to this definition">¶</a></dt>
<dd><p>Regression method for fmri_data object</p>
<p>Regress dat.X on dat.dat at each voxel, and return voxel-wise statistic
images. Each column of dat.X is a predictor in a multiple regression,
and the intercept is the last column. Intercept will automatically be
added if not detected unless &#8216;nointercept&#8217; is specified.</p>
<p>This function can also create a map of brain regions that predict the dat.Y
vector using the &#8216;brainony&#8217; option.  This is essentially a univariate
version of the &#8216;predict&#8217; command.  Warning: this is very slow as it loops
through all voxels.</p>
<p>Regression is OLS by default, but can be robust using &#8216;robust&#8217; flag.
Warning: Running robust option is considerably slower than OLS.</p>
<p>Creates thresholded plot by default</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="n">out</span> <span class="o">=</span> <span class="n">regress</span><span class="p">(</span><span class="n">dat</span><span class="p">,</span> <span class="n">varargin</span><span class="p">)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Inputs:</th><td class="field-body"><dl class="first docutils">
<dt><strong>dat:</strong></dt>
<dd><p class="first last">should be an fmri_data object with X field defined.
dat.X can be a design_matrix() object.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Optional Inputs:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body"><dl class="first docutils">
<dt><strong>[threshold, &#8216;unc&#8217;]:</strong></dt>
<dd><p class="first last">p-value threshold string indicating threshold type
(see help statistic_image.threshold for options)</p>
</dd>
<dt><strong>nointercept:</strong></dt>
<dd><p class="first last">Do not add intercept to model</p>
</dd>
<dt><strong>nodisplay:</strong></dt>
<dd><p class="first last">Do not plot thresholded results using orthviews</p>
</dd>
<dt><strong>brainony:</strong></dt>
<dd><p class="first last">univariate approach to predict obj.Y from brain data</p>
</dd>
<dt><strong>residual:</strong></dt>
<dd><p class="first last">Output residual as fmri_data() object</p>
</dd>
<dt><strong>noverbose:</strong></dt>
<dd><p class="first last">Suppress verbose outputs</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Outputs:</th><td class="field-body"><dl class="first docutils">
<dt><strong>out:</strong></dt>
<dd><p class="first last">A structure containing stats_img and fmri_data objects.</p>
</dd>
<dt><strong>out.b:</strong></dt>
<dd><p class="first last">stats_img object of beta values estimated from regression</p>
</dd>
<dt><strong>out.t:</strong></dt>
<dd><p class="first last">stats_img object of t-values with input threshold</p>
</dd>
<dt><strong>out.df:</strong></dt>
<dd><p class="first last">fmri_data object of degrees of freedom</p>
</dd>
<dt><strong>out.sigma:</strong></dt>
<dd><p class="first last">fmri_data object of variance of residual</p>
</dd>
<dt><strong>out.residual:</strong></dt>
<dd><p class="first last">fmri_data object of residual data after model has been regressed out (optional).</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Examples:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>% Run regression with liberal threshold
out = regress(dat, .05, &#39;unc&#39;);

% Run regression with conservative threshold and save residual
out = regress(dat, .001, &#39;unc&#39;, &#39;residual);

% Run robust regression with fdr threshold
out = regress(dat, .05, &#39;fdr&#39;,&#39;robust&#39;);

% Run a regression predicting behavior from brain at liberal threshold
out  = regress(data_comb, .05, &#39;unc&#39;, &#39;brainony&#39;)

% Re-threshold at different values
out.t = threshold(out.t, .05, &#39;fdr&#39;);
out.t = threshold(out.t, .001, &#39;unc&#39;);

% Re-display results of thresholding
orthviews(out.t);

% Write out beta image to current directory
out.b.fullpath = fullfile(pwd,&#39;beta.nii&#39;);
write(out)
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="&#64;fmri_data.rescale">
<code class="descclassname">&#64;fmri_data.</code><code class="descname">rescale</code><span class="sig-paren">(</span><em>fmridat</em>, <em>meth</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@fmri_data.rescale" title="Permalink to this definition">¶</a></dt>
<dd><p>Rescales data in an fmri_data object
Data is observations x images, so operating on the columns operates on
images, and operating on the rows operates on voxels (or variables more
generally) across images.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="n">fmridat</span> <span class="o">=</span> <span class="n">rescale</span><span class="p">(</span><span class="n">fmridat</span><span class="p">,</span> <span class="n">meth</span><span class="p">)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Inputs:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>Methods:</strong></dt>
<dd><ul class="first last simple">
<li>centervoxels</li>
<li>zscorevoxels</li>
<li>centerimages</li>
<li>zscoreimages</li>
<li>rankvoxels</li>
<li>windsorizevoxels</li>
<li>percentchange</li>
<li>tanh</li>
</ul>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>Appropriate for multi-session (time series) only:</dt>
<dd><ul class="first last simple">
<li>session_global_percent_change</li>
<li>session_global_z</li>
<li>session_multiplicative</li>
</ul>
</dd>
</dl>
<p>See also fmri_data.preprocess</p>
</dd></dl>

<dl class="function">
<dt id="&#64;fmri_data.saveplots">
<code class="descclassname">&#64;fmri_data.</code><code class="descname">saveplots</code><span class="sig-paren">(</span><em>fmri_dat</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@fmri_data.saveplots" title="Permalink to this definition">¶</a></dt>
<dd><p>Output dir</p>
</dd></dl>

<dl class="function">
<dt id="&#64;fmri_data.signtest">
<code class="descclassname">&#64;fmri_data.</code><code class="descname">signtest</code><span class="sig-paren">(</span><em>dat</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@fmri_data.signtest" title="Permalink to this definition">¶</a></dt>
<dd><p>Sign test for each voxel of an fmri_data object
returns voxel-wise statistic images.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>[out, statimg] = signtest(dat, [p-val threshold], [thresh_type])
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Inputs:</th><td class="field-body"><dl class="first docutils">
<dt><strong>dat:</strong></dt>
<dd><p class="first last">Should be an fmri_data object with .dat field containing voxels x observations matrix</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Optional inputs:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body"><p class="first">in [  ] above are
<strong>p-value threshold:</strong></p>
<blockquote>
<div><p>string indicating threshold type (see help statistic_image.threshold for options)</p>
</div></blockquote>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Outputs:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>out:</strong></dt>
<dd><p class="first last">is a structure of information about the sign test</p>
</dd>
<dt><strong>statimg:</strong></dt>
<dd><blockquote class="first">
<div><p>is a statistic_image object that can be thresholded and
plotted/imaged.  statimg.dat contains signed direction values,</p>
</div></blockquote>
<p class="last">.p contains p-values</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p>c Tor Wager, 2011
..</p>
<p>See also: fmri_data.regress</p>
</dd></dl>

<dl class="function">
<dt id="&#64;fmri_data.ttest">
<code class="descclassname">&#64;fmri_data.</code><code class="descname">ttest</code><span class="sig-paren">(</span><em>fmridat</em>, <em>pvalthreshold</em>, <em>thresh_type</em><span class="sig-paren">)</span><a class="headerlink" href="#@fmri_data.ttest" title="Permalink to this definition">¶</a></dt>
<dd><p>T-test on fmri_data class object</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="n">statsimg</span> <span class="o">=</span> <span class="n">ttest</span><span class="p">(</span><span class="n">fmridat</span><span class="p">,</span> <span class="n">pvalthreshold</span><span class="p">,</span> <span class="n">thresh_type</span><span class="p">)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Inputs:</th><td class="field-body"><dl class="first docutils">
<dt><strong>p-value threshold:</strong></dt>
<dd><p class="first last">p-value, e.g., .05 or .001 or [.001 .01 .05]</p>
</dd>
<dt><strong>thresh_type:</strong></dt>
<dd><p class="first last">&#8216;uncorrected&#8217;, &#8216;fwe&#8217;, or &#8216;fdr&#8217;</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Examples:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>%T-test, Construct a stats_image object, threshold and display:
statsimg = ttest(fmridat, .001, &#39;unc&#39;);
orthviews(statsimg);

%Re-threshold and display:
statsimg = threshold(statsimg, .000001, &#39;unc&#39;);
orthviews(statsimg);

statsimg = threshold(statsimg, .01, &#39;fdr&#39;);
orthviews(statsimg);
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Note:</th><td class="field-body">for two-sample T-test, use fmri_data.regress</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="&#64;fmri_data.windsorize">
<code class="descclassname">&#64;fmri_data.</code><code class="descname">windsorize</code><span class="sig-paren">(</span><em>obj</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@fmri_data.windsorize" title="Permalink to this definition">¶</a></dt>
<dd><p>Windsorize an fMRI data object to madlimit Median Absolute Deviations.
Default = 5 MADs.
Works across rows and columns.
Registers this step in history.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="n">obj</span> <span class="o">=</span> <span class="n">windsorize</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="p">[</span><span class="n">madlimit</span><span class="p">])</span>
</pre></div>
</div>
<p>Calculate and display descriptives
..</p>
</dd></dl>

</div>
<div class="section" id="module-&#64;fmri_mask_image">
<span id="fmri-mask-image"></span><h1>fmri_mask_image<a class="headerlink" href="#module-@fmri_mask_image" title="Permalink to this headline">¶</a></h1>
<dl class="function">
<dt id="&#64;fmri_mask_image.resample_to_image_space">
<code class="descclassname">&#64;fmri_mask_image.</code><code class="descname">resample_to_image_space</code><span class="sig-paren">(</span><em>obj</em>, <em>sampleto</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@fmri_mask_image.resample_to_image_space" title="Permalink to this definition">¶</a></dt>
<dd><p>Resamples data in an fmri_mask_image object (obj) to the space of another
image (e.g., a functional image, for data extraction)
The volInfo field will be the same as the sampleto volume info.
The mask will have zeros in obj.dat for out-of-mask voxels.
THIS FUNCTION USES SCN_MAP_IMAGE AND REQUIRES THAT THE ORIGINAL IMAGE BE
AVAILABLE ON DISK.  Multiple resamplings will break the function because
the new space will be different from the original one on disk.  Use the
more general resample_space.</p>
<p>NOTE: Mask is <em>reloaded</em> from original data if space is remapped, and you
cannot use manual thresholding of the mask. This is a feature of the
map_to_image_space method and scn_map_image</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>obj = resample_to_image_space(obj, sampleto &lt;img name or image_vector object&gt;)
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Inputs:</th><td class="field-body"><dl class="first docutils">
<dt><strong>obj:</strong></dt>
<dd><p class="first last">must be an fmri_mask_image object</p>
</dd>
<dt><strong>sampleto:</strong></dt>
<dd><dl class="first last docutils">
<dt>can be either:</dt>
<dd><ol class="first last arabic simple">
<li>An image name to sample to</li>
<li>Another fmri_mask_image object (but image must exist on path!)</li>
</ol>
</dd>
</dl>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Optional inputs:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body"><dl class="first last docutils">
<dt><strong>mask:</strong></dt>
<dd><p class="first last">Apply sampleto as mask so that only voxels in the sampleto mask
are retained in obj.dat.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p>THIS FUNCTION WORKS, BUT IS DEPRECATED BECAUSE RESAMPLE_SPACE IS MORE
GENERAL.  resample_space does not require the resampling of the original
image from disk, which this does.  resample_space is slower, though.</p>
<p>See Also: resample_space, for a method that does not require images to
exist on disk on the path.</p>
</dd></dl>

</div>
<div class="section" id="module-&#64;fmri_model">
<span id="fmri-model"></span><h1>fmri_model<a class="headerlink" href="#module-@fmri_model" title="Permalink to this headline">¶</a></h1>
<dl class="function">
<dt id="&#64;fmri_model.build">
<code class="descclassname">&#64;fmri_model.</code><code class="descname">build</code><span class="sig-paren">(</span><em>obj</em><span class="sig-paren">)</span><a class="headerlink" href="#@fmri_model.build" title="Permalink to this definition">¶</a></dt>
<dd><p>obj = build(fmri_model_obj)</p>
<p>Build the design matrix (xx) for an fmri_model object</p>
<p>We assume that the same conditions are modeled for each session
We assume that you have one basis set per condition (this is different
from SPM, which only allows a single basis set across all conditions)
Define sessions and number of conditions</p>
</dd></dl>

<dl class="function">
<dt id="&#64;fmri_model.build_single_trial">
<code class="descclassname">&#64;fmri_model.</code><code class="descname">build_single_trial</code><span class="sig-paren">(</span><em>obj</em>, <em>inputhrf</em><span class="sig-paren">)</span><a class="headerlink" href="#@fmri_model.build_single_trial" title="Permalink to this definition">¶</a></dt>
<dd><p>obj = build_single_trial(fmri_model_obj, inputhrf)</p>
<p>Build a single-trial design matrix (xx) for an fmri_model object</p>
<p>We assume that the same conditions are modeled for each session
We assume that you have one basis set per condition (this is different
from SPM, which only allows a single basis set across all conditions)</p>
<p>This is used in single_trial_estimates, which assumes that you have
estimated an initial model and saved image data.</p>
<p>The idea behind this is somewhat different from other canlab single-trial
analyses, in that it takes in a single, custom HRF for each condition,
rather than using a basis set.  In single_trial_estimates, custom HRFs
are created for each voxel by using the condition- and voxel-specific hrf
estimates stored during model fitting.
The sequence would be:
1 - robustfit(my_model), to fit average model and get HRF est for each
voxel
2 - single_trial_estimates(my_model), to use this function to build
single-trial design matrices and fit them.</p>
<p>inputhrf should be a cell array of length nconds (number of conditions).
Check assumptions and basis set
We assume that the same conditions are modeled for each session</p>
</dd></dl>

<dl class="function">
<dt id="&#64;fmri_model.get_condition_assignments">
<code class="descclassname">&#64;fmri_model.</code><code class="descname">get_condition_assignments</code><span class="sig-paren">(</span><em>obj</em><span class="sig-paren">)</span><a class="headerlink" href="#@fmri_model.get_condition_assignments" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>Indicator matrix coding for which columns in X belong to the same</li>
</ul>
<p>modeled condition, and are part of the same HRF fit
- There is one set of columns for each condition modeled, and one set of
columns for each parametric modulator of each condition
- Because parametric modulators may not exist for all conditions, we need
to build this dynamically for modulators.</p>
<p>Design matrix build (which calls method get_session_X) builds columns in
this order:
All within Session:
Regressors of interest, basis functions within conditions
Parametric modulators, basis functions within conditions
Covariates of no interest
Then:
Baselines (session/run intercepts)</p>
<p>This method is called automatically in the build method.</p>
</dd></dl>

<dl class="function">
<dt id="&#64;fmri_model.get_session_X">
<code class="descclassname">&#64;fmri_model.</code><code class="descname">get_session_X</code><span class="sig-paren">(</span><em>obj</em>, <em>s</em><span class="sig-paren">)</span><a class="headerlink" href="#@fmri_model.get_session_X" title="Permalink to this definition">¶</a></dt>
<dd><p>[Xs, delta, C, B, names] = get_session_X(obj, session number)</p>
<p>Get design matrix (predictors) for one session of fmri_model object, using
basis functions defined in the object and onsets for one session (s).</p>
</dd></dl>

<dl class="function">
<dt id="&#64;fmri_model.plot">
<code class="descclassname">&#64;fmri_model.</code><code class="descname">plot</code><span class="sig-paren">(</span><em>obj</em><span class="sig-paren">)</span><a class="headerlink" href="#@fmri_model.plot" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="&#64;fmri_model.replace_basis_set">
<code class="descclassname">&#64;fmri_model.</code><code class="descname">replace_basis_set</code><span class="sig-paren">(</span><em>obj</em>, <em>condition_num</em>, <em>xBF_hires</em><span class="sig-paren">)</span><a class="headerlink" href="#@fmri_model.replace_basis_set" title="Permalink to this definition">¶</a></dt>
<dd><p>obj = replace_basis_set(obj, condition_num, xBF_hires)</p>
<p>Replace a basis set in an fmri_model object with another one of your
choosing.</p>
<p>This allows one to use a custom basis set, and also to use different
basis sets for different trial types.</p>
<p>Each condition across all sessions must be modeled with the same basis
set. That is, there can be only one basis set per condition, e.g., one
for anticipation (used in each session) and one for pain.</p>
<p>e.g., generate a custom spline basis set and use that for Condition 1,
and the standard one for Condition 2:</p>
<p>[xBF_hires, xBF] = fmri_spline_basis(2, &#8216;length&#8217;, 12, &#8216;nbasis&#8217;, 3, &#8216;order&#8217;, 3, &#8216;plot&#8217;);
save this to get info that is not typically in basis set until after
model is built.</p>
</dd></dl>

<dl class="function">
<dt id="&#64;fmri_model.robustfit">
<code class="descclassname">&#64;fmri_model.</code><code class="descname">robustfit</code><span class="sig-paren">(</span><em>fmri_model_obj</em>, <em>fmri_data_obj</em><span class="optional">[</span>, <em>optional args</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#@fmri_model.robustfit" title="Permalink to this definition">¶</a></dt>
<dd><p>robust fit for a model object to data object</p>
<p>Features:
spatial smoothing of weights at 12 mm FWHM
ridge regression <strong>*not yet*</strong></p>
<p>Preproc scaling:
1) Remove covariates using ridge reg; ridge trace for full model
2) scale to % signal change across time (cols) OR rank time points (for
w/i ss predictions??) AND/OR rank or center rows (images; for &#8216;shape&#8217;
analysis</p>
<p>Example: %sig across time, rank across rows: relative % sig change
Different models of noise lead to different ideas about optimal preproc
If large diffs in nuisance scaling in BOLD across individuals, ranking cols may
be good idea. but then individual diffs in overall activity will be removed...</p>
<p>&#8216;tune&#8217;, tuning const for robust reg
&#8216;iter&#8217;, &#8216;maxiterations&#8217;, robust reg /WLS iterations. 1 = OLS only!
&#8216;smooth&#8217;, &#8216;spatial_smooth_fwhm&#8217;, 0 or smoothing kernel for weights</p>
<p>&#8216;nosmooth&#8217;, spatial_smooth_fwhm = 0;
&#8216;stats&#8217;, &#8216;calculate_stats&#8217;, calculate_stats = 1; IN DEVELOPMENT
&#8216;noresiduals&#8217;, write_residuals = 0;
&#8216;noplots&#8217;, save_plots = 0;
Defaults/constants
&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;</p>
</dd></dl>

<dl class="function">
<dt id="&#64;fmri_model.saveplots">
<code class="descclassname">&#64;fmri_model.</code><code class="descname">saveplots</code><span class="sig-paren">(</span><em>fmri_model</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@fmri_model.saveplots" title="Permalink to this definition">¶</a></dt>
<dd><p>Output dir</p>
</dd></dl>

<dl class="function">
<dt id="&#64;fmri_model.single_trial_estimates">
<code class="descclassname">&#64;fmri_model.</code><code class="descname">single_trial_estimates</code><span class="sig-paren">(</span><em>obj</em>, <em>fmri_data_obj</em><span class="sig-paren">)</span><a class="headerlink" href="#@fmri_model.single_trial_estimates" title="Permalink to this definition">¶</a></dt>
<dd><p>Write single trial estimates associated with an estimated fmri_model object.
must have estimated the model (robustfit(obj); see fmri_model.robustfit)
and saved hrf*.img images for each condition.</p>
<p>Also input an fmri_data object with time series data.</p>
<p>This function writes images, one 4-D image for each condition, with the
number of frames equalling the number of trials (onsets) for that
condition.</p>
<p>It does this by constructing a separate design matrix for each voxel,
which is based on the HRF estimates for that voxel for each condition.
Fits for all conditions are added to the same model, so that their
colinearity influences the single-trial parameter estimates.</p>
</dd></dl>

</div>
<div class="section" id="module-&#64;image_vector">
<span id="image-vector"></span><h1>image_vector<a class="headerlink" href="#module-@image_vector" title="Permalink to this headline">¶</a></h1>
<dl class="function">
<dt id="&#64;image_vector.apply_mask">
<code class="descclassname">&#64;image_vector.</code><code class="descname">apply_mask</code><span class="sig-paren">(</span><em>dat</em>, <em>mask</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@image_vector.apply_mask" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply a mask image (image filename or fmri_mask_image object) to an image_vector object
stored in dat.</p>
<dl class="docutils">
<dt>This can be used to:</dt>
<dd><ul class="first last simple">
<li>Mask an image_vector or fmri_data object with a mask</li>
<li>Obtain &#8220;pattern expression&#8221; for a weight map (entered as the
mask, here) in a series of images stored in dat.</li>
</ul>
</dd>
</dl>
<p>The mask or weight map does not have to be in the same space as the dat;
it will be resampled to the space of the data in dat.</p>
<p>To extract pattern expression values for each ROI within a mask use extract_roi_averages()</p>
<p><em>Optional inputs:</em></p>
<p>&#8216;pattern_expression&#8217; : calculate and return the cross-product of each
image in dat and the values in the mask.  This is useful if comparing
expression values that are comprised of different datasets or differing
number of voxels.</p>
<p>&#8216;correlation&#8217; : calculate the pearson correlation coefficient of each
image in dat and the values in the mask.</p>
<p>&#8216;norm_mask&#8217;: normalize the mask weights by L2 norm, for patt expression
only.</p>
<p>&#8216;ignore_missing&#8217;: use with pattern expression only. Ignore weights on voxels
with zero values in test image. If this is not entered, the function will
check for these values and give a warning.</p>
<p>&#8216;invert&#8217;: Invert the mask so that out-of-mask voxels are now in (using
the mask as an &#8216;exclude mask&#8217; rather than an include-mask. If pattern
expression is requested, the behavior is different, and it inverts the
sign of in-mask pattern weights.</p>
<blockquote>
<div><ul class="simple">
<li>[dat, mask] = apply_mask(dat, mask)</li>
<li>[dat, mask] = apply_mask(dat, mask image name)</li>
<li>[dat, mask] = apply_mask(dat, mask image vector object)</li>
<li>[pattern_exp_values] = apply_mask(dat, weight map image, &#8216;pattern_expression&#8217;, &#8216;ignore_missing&#8217;)</li>
<li>[pattern_exp_values] = apply_mask(dat, weight map image, &#8216;pattern_expression&#8217;, &#8216;ignore_missing&#8217;,&#8217;correlation&#8217;)</li>
</ul>
</div></blockquote>
<p><em>See also:</em></p>
<p>extract_roi_averages, to get individual region averages / local pattern expression
apply_nps, which does whole-pattern and local regional expression</p>
<p><em>Notes:</em></p>
<p>Last modified: 10/30/11 to add support for masks that are weight maps</p>
<p>12/15/13:  Luke Chang - added correlation option for pattern-expression, 
set options</p>
</dd></dl>

<dl class="function">
<dt id="&#64;image_vector.check_image_filenames">
<code class="descclassname">&#64;image_vector.</code><code class="descname">check_image_filenames</code><span class="sig-paren">(</span><em>obj</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@image_vector.check_image_filenames" title="Permalink to this definition">¶</a></dt>
<dd><p>Check whether images listed in obj.fullpath actually exist</p>
<p>obj = check_image_filenames(obj, [&#8216;noverbose&#8217;])</p>
<p><em>Behavior:</em></p>
<p>If there are no file names, do nothing.
If file names are entered and full path is not, attempt to find full
path.
If full path info is entered, check to see if files exist.
Return output in obj.files_exist, and print a warning if only some exist.</p>
<p>Image names should be stored in .fullpath
abbreviated image names may be stored in image_names.</p>
<p><em>Notes:</em></p>
<p>fullpath should have full path to each volume in a string matrixm, with
trailing ,volume# for 4-D images as per SPM style expanded list.
image_names should have image name only for each volume</p>
<p><a href="#id1"><span class="problematic" id="id2">**</span></a>* May still be debugging issues with 3-D vs. 4-D files
if &#8216;noverbose&#8217; is entered, suppress output</p>
</dd></dl>

<dl class="function">
<dt id="&#64;image_vector.compare_space">
<code class="descclassname">&#64;image_vector.</code><code class="descname">compare_space</code><span class="sig-paren">(</span><em>obj</em>, <em>obj2</em><span class="sig-paren">)</span><a class="headerlink" href="#@image_vector.compare_space" title="Permalink to this definition">¶</a></dt>
<dd><p>function isdiff = compare_space(obj, obj2)</p>
<p>Compare spaces of two image_vector objects</p>
<p>Returns 0 if same, 1 if different spaces, 2 if no volInfo info for one or
more objects. 3 if same space, but different in-mask voxels in .dat or
volInfo.image_indx</p>
</dd></dl>

<dl class="function">
<dt id="&#64;image_vector.extract_gray_white_csf">
<code class="descclassname">&#64;image_vector.</code><code class="descname">extract_gray_white_csf</code><span class="sig-paren">(</span><em>obj</em><span class="sig-paren">)</span><a class="headerlink" href="#@image_vector.extract_gray_white_csf" title="Permalink to this definition">¶</a></dt>
<dd><p>[values, components] = extract_gray_white_csf(obj)</p>
<p>Extracts mean values (values) and top 5 component scores (components)
from each of gray, white, and CSF masks.
Images must be in standard MNI space for this to apply.</p>
<p>obj = an image_vector (e.g., fmri_data) object</p>
<p>Tor Wager, July 21, 2015</p>
</dd></dl>

<dl class="function">
<dt id="&#64;image_vector.extract_roi_averages">
<code class="descclassname">&#64;image_vector.</code><code class="descname">extract_roi_averages</code><span class="sig-paren">(</span><em>obj</em>, <em>mask</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@image_vector.extract_roi_averages" title="Permalink to this definition">¶</a></dt>
<dd><p>cl = extract_roi_averages(image_vector obj, mask, [average_over])</p>
<p>This image_vector method a extracts and averages data stored in an fmri_data object 
from a set of ROIs defined in a mask.
It is <em>slightly</em> different from the fmri_data method, as fmri_data has
more fields.</p>
<p>This version requires the mask_image to be in the same space as the obj.</p>
<p>Regions to average over can be either regions of contiguous voxels
bounded by voxels with values of 0 or NaN, which are considered non-data
values, or regions defined by unique integer codes in the mask image
(i.e., for atlas images with unique codes for each defined region.)</p>
<p>Mask/Atlas image does NOT have to be in the same space as the images to
extract from.  It will be remapped/resliced.</p>
<p>Extracted data is returned in single data format.</p>
<dl class="docutils">
<dt>Inputs:</dt>
<dd><ol class="first last arabic simple">
<li>char array of strings containing 4D image file names (data extracted from these)</li>
<li>mask_image to extract from.</li>
</ol>
</dd>
</dl>
<p><em>Optional inputs:</em></p>
<dl class="docutils">
<dt><strong>average_over:</strong></dt>
<dd><ul class="first last simple">
<li>Default = &#8216;contiguous_regions&#8217; to average over contiguous voxels
bounded by voxels of 0 or NaN (non-data values)</li>
<li>Alt. option = &#8216;unique_mask_values&#8217; to average over unique integer codes in the mask image
(i.e., for atlas images with unique codes for each defined region)</li>
</ul>
</dd>
</dl>
<p><em>Example:</em></p>
<blockquote>
<div><ul class="simple">
<li>imgs_to_extract_from = filenames(&#8216;w*.nii&#8217;,&#8217;char&#8217;);</li>
<li>mask_image = which(&#8216;anat_lbpa_thal.img&#8217;);</li>
<li>[cl, imgdat] = extract_image_data(imgs_to_extract_from, mask_image);</li>
</ul>
</div></blockquote>
<p><em>Related functions:</em></p>
<p>For an non-object-oriented alternative, see extract_image_data.m</p>
</dd></dl>

<dl class="function">
<dt id="&#64;image_vector.fastmontage">
<code class="descclassname">&#64;image_vector.</code><code class="descname">fastmontage</code><span class="sig-paren">(</span><em>dat</em><span class="optional">[</span>, <em>myview</em><span class="optional">]</span><span class="optional">[</span>, <em>'spacing'</em>, <em>slicespacing</em><span class="optional">]</span><span class="optional">[</span>, <em>'vertical'</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#@image_vector.fastmontage" title="Permalink to this definition">¶</a></dt>
<dd><p>fastmontage(dat);</p>
<p>Creates 3 separate montage views - ax, cor, sagg</p>
<p>In special figure window</p>
<blockquote>
<div><ul class="simple">
<li>fastmontage(dat, &#8216;coronal&#8217;);</li>
<li>fastmontage(dat, &#8216;saggital&#8217;, &#8216;spacing&#8217;, 10);</li>
<li>fastmontage(dat, &#8216;saggital&#8217;, &#8216;spacing&#8217;, 10, &#8216;vertical&#8217;);</li>
<li>fastmontage(dat, &#8216;saggital&#8217;, &#8216;slices_per_row&#8217;, 12);</li>
</ul>
</div></blockquote>
<p>Tor Wager, Aug 2012</p>
</dd></dl>

<dl class="function">
<dt id="&#64;image_vector.flip">
<code class="descclassname">&#64;image_vector.</code><code class="descname">flip</code><span class="sig-paren">(</span><em>dat</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@image_vector.flip" title="Permalink to this definition">¶</a></dt>
<dd><p>Flips an image_vector object left to right</p>
<p><em>Optional:</em></p>
<p>input &#8216;mirror&#8217; to make a symmetrical image, averaging the left
and right hemispheres</p>
<blockquote>
<div><ul class="simple">
<li>dat = flip(dat, [&#8216;mirror&#8217;])</li>
</ul>
</div></blockquote>
<p>tor. may 2012</p>
</dd></dl>

<dl class="function">
<dt id="&#64;image_vector.histogram">
<code class="descclassname">&#64;image_vector.</code><code class="descname">histogram</code><span class="sig-paren">(</span><em>obj</em><span class="sig-paren">)</span><a class="headerlink" href="#@image_vector.histogram" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="&#64;image_vector.history">
<code class="descclassname">&#64;image_vector.</code><code class="descname">history</code><span class="sig-paren">(</span><em>dat</em><span class="sig-paren">)</span><a class="headerlink" href="#@image_vector.history" title="Permalink to this definition">¶</a></dt>
<dd><p>Display history for image_vector object</p>
</dd></dl>

<dl class="function">
<dt id="&#64;image_vector.horzcat">
<code class="descclassname">&#64;image_vector.</code><code class="descname">horzcat</code><span class="sig-paren">(</span><em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@image_vector.horzcat" title="Permalink to this definition">¶</a></dt>
<dd><p>function s = horzcat(varargin)</p>
<p>Implements the horzcat ([a b]) operator on image_vector objects across voxels.
Requires that each object has an equal number of columns and voxels</p>
<dl class="docutils">
<dt><em>Examples:</em></dt>
<dd><ul class="first last simple">
<li>c = [dat1 dat2];</li>
</ul>
</dd>
</dl>
<p>Programmer Notes
Created 3/14/14 by Luke Chang</p>
</dd></dl>

<dl class="function">
<dt id="&#64;image_vector.ica">
<code class="descclassname">&#64;image_vector.</code><code class="descname">ica</code><span class="sig-paren">(</span><em>fmridat_obj</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@image_vector.ica" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Spatial ICA of an fmri_data object</dt>
<dd><ul class="first last simple">
<li>icadat = ica(fmridat_obj, [number of ICs to save])</li>
<li>icadat is also an fmri_data object, with .dat field voxels x components</li>
</ul>
</dd>
<dt><em>Notes:</em></dt>
<dd><ul class="first last simple">
<li>icasig = W * mixedsig</li>
<li>icasig = icadat.dat&#8217; = W * fmridat_obj.dat&#8217;</li>
</ul>
</dd>
</dl>
<p>A is scaled version of fmridat_obj.dat&#8217; * icadat.dat</p>
<p>A and W are stored in additional_info field of icadat</p>
</dd></dl>

<dl class="function">
<dt id="&#64;image_vector.image_math">
<code class="descclassname">&#64;image_vector.</code><code class="descname">image_math</code><span class="sig-paren">(</span><em>obj1</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@image_vector.image_math" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform simple mathematical and boolean operations on image objects</p>
<dl class="docutils">
<dt><em>Usage:</em></dt>
<dd><ul class="first last simple">
<li>obj_out = image_math(obj1, [optional inputs, e.g., a 2nd object, keywords])</li>
</ul>
</dd>
<dt>For objects: Type methods(object_name) for a list of special commands</dt>
<dd>Type help object_name.method_name for help on specific
methods.</dd>
<dt><em>Inputs:</em></dt>
<dd><ul class="first last simple">
<li>obj1           An image_vector object</li>
</ul>
</dd>
<dt><em>Optional inputs:</em></dt>
<dd><ul class="first last">
<li><p class="first">obj2                   - An additional image_vector object</p>
</li>
<li><dl class="first docutils">
<dt>{&#8216;add&#8217;, &#8216;plus&#8217;}        - Keyword to perform image-wise addition of images in obj1</dt>
<dd><p class="first last">and obj2.  Assumes these are paired/matched objects.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>{&#8216;subtract&#8217;, &#8216;minus&#8217;}  - Keyword to perform image-wise subtraction of images</dt>
<dd><p class="first last">in obj1 and obj2</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>{&#8216;cat&#8217;, &#8216;concatenate&#8217;} - Concatenate obj1 and obj2 image-wise.  Requires same</dt>
<dd><p class="first last">number of voxels in both image sets.  Returns effects
codes of 1, -1 in obj_out.Y.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>{&#8216;power&#8217;}              - Keyword to raise data to power element-wise; obj.dat = obj.dat.^b;</dt>
<dd><p class="first last">Followed by exponent to apply (b)</p>
</dd>
</dl>
</li>
</ul>
</dd>
<dt><em>Outputs:</em></dt>
<dd><ul class="first last simple">
<li>obj_out        The result - an image_vector object</li>
</ul>
</dd>
</dl>
<p><em>Examples:</em>
give examples here</p>
<p><em>See also:</em>
<em>list other functions related to this one, and alternatives</em>
<em>Programmers&#8217; notes:</em>
List dates and changes here, and author of changes</p>
<p>Author and copyright information:</p>
<blockquote>
<div><p>Copyright (C) 2015  Tor Wager</p>
<p>This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.</p>
<p>This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.</p>
<p>You should have received a copy of the GNU General Public License
along with this program.  If not, see &lt;<a class="reference external" href="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</a>&gt;.</p>
</div></blockquote>
<p>initalize optional variables to default values here.</p>
</dd></dl>

<dl class="function">
<dt id="&#64;image_vector.image_similarity_plot">
<code class="descclassname">&#64;image_vector.</code><code class="descname">image_similarity_plot</code><span class="sig-paren">(</span><em>obj</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@image_vector.image_similarity_plot" title="Permalink to this definition">¶</a></dt>
<dd><p>Point-biserial correlations between images in fmri_data obj and set of
&#8216;spatial basis function&#8217; images (e.g., &#8216;signatures&#8217; or pre-defined maps)</p>
<p>Usage:</p>
<blockquote>
<div><ul class="simple">
<li>stats = image_similarity_plot(obj, &#8216;average&#8217;);</li>
</ul>
</div></blockquote>
<p>This is a method for an image_vector object</p>
<p>Author and copyright information:</p>
<blockquote>
<div><p>Copyright (C) 2015 Tor Wager</p>
<p>This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.</p>
<p>This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.</p>
<p>You should have received a copy of the GNU General Public License
along with this program.  If not, see &lt;<a class="reference external" href="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</a>&gt;.</p>
</div></blockquote>
<p>Inputs:</p>
<p>obj           An image object with one or more images loaded</p>
<p><em>Optional inputs:</em></p>
<dl class="docutils">
<dt>&#8216;average&#8217;     Calculate average over images in obj with standard errors</dt>
<dd>Useful if obj contains one image per subject and you want
to test similarity with maps statistically.
Default behavior is to plot each individual image.</dd>
</dl>
<p><em>Outputs:</em></p>
<dl class="docutils">
<dt>stats         Structure including:</dt>
<dd>.r, Correlations in [7 networks x images in obj] matrix
.t, T-test (if &#8216;average&#8217; is specified)
.line_handles Handles to polar plot lines so you can
customize
.fill_handles Handles to polar plot fills so you can
customize</dd>
</dl>
<p><em>Examples:</em></p>
<p>corrdat is an fmri_data object with 18 images from searchlight
correlation in it.  Then:
stats = image_similarity_plot_bucknermaps(corrdat, &#8216;average&#8217;);</p>
<p>t_diff is a thresholded statistic_image object
stats = image_similarity_plot_bucknermaps(t_diff);</p>
<p><em>See also:</em></p>
<p>tor_polar_plot
<em>Programmers&#8217; notes:</em>
List dates and changes here, and author of changes
&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;-
DEFAULTS AND INPUTS
&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;-
Defaults
&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8211;
initalize optional variables to default values here.</p>
</dd></dl>

<dl class="function">
<dt id="&#64;image_vector.image_similarity_plot_bucknermaps">
<code class="descclassname">&#64;image_vector.</code><code class="descname">image_similarity_plot_bucknermaps</code><span class="sig-paren">(</span><em>obj</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@image_vector.image_similarity_plot_bucknermaps" title="Permalink to this definition">¶</a></dt>
<dd><p>Point-biserial correlations between images in fmri_data obj and Bucker
Lab 7-network maps, with polar plot</p>
<p><em>Usage:</em></p>
<p>stats = image_similarity_plot_bucknermaps(obj, &#8216;average&#8217;);</p>
<p>This is a method for an image_vector object</p>
<p>Author and copyright information:</p>
<blockquote>
<div><p>Copyright (C) 2015 Tor Wager</p>
<p>This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.</p>
<p>This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.</p>
<p>You should have received a copy of the GNU General Public License
along with this program.  If not, see &lt;<a class="reference external" href="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</a>&gt;.</p>
</div></blockquote>
<p><em>Inputs:</em></p>
<p>obj           An image object with one or more images loaded</p>
<p><em>Optional inputs:</em></p>
<dl class="docutils">
<dt>&#8216;average&#8217;     Calculate average over images in obj with standard errors</dt>
<dd>Useful if obj contains one image per subject and you want
to test similarity with maps statistically.
Default behavior is to plot each individual image.</dd>
</dl>
<p><em>Outputs:</em></p>
<dl class="docutils">
<dt>stats         Structure including:</dt>
<dd>.r, Correlations in [7 networks x images in obj] matrix
.t, T-test (if &#8216;average&#8217; is specified)
.line_handles Handles to polar plot lines so you can
customize
.fill_handles Handles to polar plot fills so you can
customize</dd>
</dl>
<p><em>Examples:</em></p>
<p>corrdat is an fmri_data object with 18 images from searchlight
correlation in it.  Then:</p>
<blockquote>
<div><ul class="simple">
<li>stats = image_similarity_plot_bucknermaps(corrdat, &#8216;average&#8217;);</li>
</ul>
</div></blockquote>
<dl class="docutils">
<dt>t_diff is a thresholded statistic_image object</dt>
<dd><ul class="first last simple">
<li>stats = image_similarity_plot_bucknermaps(t_diff);</li>
</ul>
</dd>
</dl>
<p><em>See also:</em></p>
<p>tor_polar_plot</p>
<p><em>Programmers&#8217; notes:</em>
List dates and changes here, and author of changes</p>
<p>initalize optional variables to default values here.</p>
</dd></dl>

<dl class="function">
<dt id="&#64;image_vector.interpolate">
<code class="descclassname">&#64;image_vector.</code><code class="descname">interpolate</code><span class="sig-paren">(</span><em>dat</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@image_vector.interpolate" title="Permalink to this definition">¶</a></dt>
<dd><p>Interpolate over missing values in image_vector object</p>
<blockquote>
<div><ul class="simple">
<li>dat = interpolate(dat, varargin)</li>
</ul>
</div></blockquote>
<p><em>Input:</em> image_vector object (dat; e.g., an fmri_data object)
Use when there are some missing values in the mask image
Performs 3-D linear interpolation to fill in all values in the original
mask.</p>
<p>e.g., For a standard brain image space that is 91 x 109 x 91, you may
have 300,000 in-mask values. Only 150,000 of these may be defined in the
image, however, and the rest are missing (0 or NaN).
This function will return a dat image with non-missing values for all
300,000 voxels (the &#8220;in-mask&#8221; space). 
It will not return values for all voxels in the 91 x 109 x 91 space,
however.</p>
<p><em>Note:</em> This function does not upsample the data now, but could be extended
to do so fairly easily.</p>
<p>values &gt; 1 would upsample the data</p>
</dd></dl>

<dl class="function">
<dt id="&#64;image_vector.mean">
<code class="descclassname">&#64;image_vector.</code><code class="descname">mean</code><span class="sig-paren">(</span><em>obj</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@image_vector.mean" title="Permalink to this definition">¶</a></dt>
<dd><p>function m = mean(obj, [optional args])</p>
<p>Create an image_vector object with mean values for each voxel (cols)
across images (rows) of an fmri_data object.</p>
<p>m is an image_vector object whose data contains the mean values.</p>
<dl class="docutils">
<dt>Options are:</dt>
<dd><ul class="first last simple">
<li>&#8216;write&#8217;, followed by file name</li>
<li>&#8216;path&#8217;, followed by location for file (default = current directory)</li>
<li>&#8216;orthviews&#8217; -&gt; show orthviews for this image, same as orthviews(m)</li>
<li>&#8216;histogram&#8217; -&gt; show histogram for this image, same as histogram(m)</li>
<li>&#8216;plot&#8217; -&gt; do both</li>
</ul>
</dd>
</dl>
<p><em>Examples:</em>
If sdat is an fmri_data object with multiple images,</p>
<blockquote>
<div><ul class="simple">
<li>m = mean(sdat, &#8216;plot&#8217;, &#8216;write&#8217;, anatmeanname, &#8216;path&#8217;, maskdir);</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="&#64;image_vector.minus">
<code class="descclassname">&#64;image_vector.</code><code class="descname">minus</code><span class="sig-paren">(</span><em>obj1</em>, <em>obj2</em><span class="sig-paren">)</span><a class="headerlink" href="#@image_vector.minus" title="Permalink to this definition">¶</a></dt>
<dd><p>function s = minus(obj1, obj2)</p>
<p>Implements the minus (-) operator on image_vector objects across voxels.
Requires that each object has an equal number of columns and voxels</p>
<dl class="docutils">
<dt><em>Examples:</em></dt>
<dd><ul class="first last simple">
<li>c = dat1 - dat2;</li>
</ul>
</dd>
</dl>
<p><em>Programmer Notes</em>
Created 3/14/14 by Luke Chang</p>
</dd></dl>

<dl class="function">
<dt id="&#64;image_vector.montage">
<code class="descclassname">&#64;image_vector.</code><code class="descname">montage</code><span class="sig-paren">(</span><em>image_obj</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@image_vector.montage" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a montage of an image_vector (or statistic_image or fmri_data) object</p>
<dl class="docutils">
<dt><em>Usage:</em></dt>
<dd><ul class="first last simple">
<li>[fig_handle or o2 fmridisp object] = montage(image_obj, [optional arguments])</li>
</ul>
</dd>
<dt><em>Optional inputs:</em></dt>
<dd><ul class="first last simple">
<li>&#8216;fmridisplay&#8217; for fmridisplay object style montage [default]</li>
<li>&#8216;scnmontage&#8217; for circa 2008-style SCN lab montage for each image vector</li>
</ul>
</dd>
<dt><em>Examples:</em></dt>
<dd><ul class="first last simple">
<li>o2 = montage(mask);</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="&#64;image_vector.orthviews">
<code class="descclassname">&#64;image_vector.</code><code class="descname">orthviews</code><span class="sig-paren">(</span><em>image_obj</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@image_vector.orthviews" title="Permalink to this definition">¶</a></dt>
<dd><p>Orthviews display (SPM) for CANlab image_vector (or fmri_data, statistic_image) object</p>
<dl class="docutils">
<dt><em>Usage:</em></dt>
<dd><ul class="first last simple">
<li>orthviews(image_obj, varargin)</li>
</ul>
</dd>
<dt><em>Options:</em></dt>
<dd><ul class="first last">
<li><p class="first">&#8216;posneg&#8217; input generates orthviews using solid colors.</p>
</li>
<li><dl class="first docutils">
<dt>&#8216;largest_region&#8217; to center the orthviews on the largest region in the</dt>
<dd><p class="first last">image</p>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
<p>Copyright Tor Wager, 2011</p>
</dd></dl>

<dl class="function">
<dt id="&#64;image_vector.plot_current_orthviews_coord">
<code class="descclassname">&#64;image_vector.</code><code class="descname">plot_current_orthviews_coord</code><span class="sig-paren">(</span><em>dat</em><span class="sig-paren">)</span><a class="headerlink" href="#@image_vector.plot_current_orthviews_coord" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieves and plots the image data series at the current crosshairs in spm_orthviews</p>
<ul class="simple">
<li>voxel_data_series = plot_current_orthviews_coord(dat)</li>
</ul>
</dd></dl>

<dl class="function">
<dt id="&#64;image_vector.plus">
<code class="descclassname">&#64;image_vector.</code><code class="descname">plus</code><span class="sig-paren">(</span><em>obj1</em>, <em>obj2</em><span class="sig-paren">)</span><a class="headerlink" href="#@image_vector.plus" title="Permalink to this definition">¶</a></dt>
<dd><p>function s = plus(obj1, obj2)</p>
<p>Implements the plus (+) operator on image_vector objects across voxels.
Requires that each object has an equal number of columns and voxels</p>
<dl class="docutils">
<dt><em>Examples:</em></dt>
<dd><ul class="first last simple">
<li>c = dat1 + dat2;</li>
</ul>
</dd>
</dl>
<p><em>Programmer Notes</em>
Created 3/14/14 by Luke Chang</p>
</dd></dl>

<dl class="function">
<dt id="&#64;image_vector.power">
<code class="descclassname">&#64;image_vector.</code><code class="descname">power</code><span class="sig-paren">(</span><em>obj</em>, <em>b</em><span class="sig-paren">)</span><a class="headerlink" href="#@image_vector.power" title="Permalink to this definition">¶</a></dt>
<dd><p>function s = power(obj1, obj2)</p>
<p>Implements the power (^) operator on image_vector objects across voxels.</p>
<dl class="docutils">
<dt><em>Examples:</em></dt>
<dd><ul class="first last simple">
<li>c = dat1^2;</li>
</ul>
</dd>
</dl>
<p><em>Programmer Notes</em>
Created 3/14/14 by Luke Chang</p>
</dd></dl>

<dl class="function">
<dt id="&#64;image_vector.preprocess">
<code class="descclassname">&#64;image_vector.</code><code class="descname">preprocess</code><span class="sig-paren">(</span><em>obj</em>, <em>meth</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@image_vector.preprocess" title="Permalink to this definition">¶</a></dt>
<dd><p>obj = preprocess(obj, meth, varargin)</p>
<p>Preprocesses data in an fmri_data object</p>
<p>Data is observations (i.e., voxels, subjects) x images, so operating on the columns operates on
images, and operating on the rows operates on voxels (or variables more
generally) across images.</p>
<p><em>meth: Options</em></p>
<dl class="docutils">
<dt>&#8216;resid&#8217;: Residualize voxels with respect to covariates</dt>
<dd>Uses obj.covariates, obj.dat.
Adds intercept automatically. You can tell it to add the mean response per voxel back in:
obj = preprocess(obj, &#8216;resid&#8217;, [add mean back in flag])</dd>
</dl>
<p>&#8216;hpfilter&#8217;: High-pass filter and remove run intercepts and first two
images per run.</p>
<blockquote>
<div>Uses obj.dat, obj.images_per_session
obj = preprocess(obj, &#8216;hpfilter&#8217;, HPlen in s, TR)</div></blockquote>
<p>&#8216;windsorize&#8217;: Windsorize entire data matrix to 3 STD</p>
<p>&#8216;windsorizevoxels&#8217;: Windsorize each time series in data matrix to 3 STD</p>
<dl class="docutils">
<dt>&#8216;session_outliers&#8217;: Identify session-wise (run-wise) outliers with significant</dt>
<dd>based on mahalanobis distance with FDR-corrected P-values in chi-square test.
Impute session grand mean outliers.</dd>
</dl>
<p>&#8216;outliers&#8217;: Identify outlier time points for each session based on
mahalanobis distance (see above) across global mean for slices and
spatial STD for slices, as in scn_session_spike_id.
Outliers at 3 SD based on timeseries added to obj.covariates.</p>
<p>&#8216;outliers_rmssd&#8217;: Identify outlier time points for each session based on
root-mean-square successive differences between images (across voxels.)
this is the std (across voxels) of the successive diffs across images.
Outliers at 3.5 SD based on timeseries added to obj.covariates.</p>
<dl class="docutils">
<dt>&#8216;smooth&#8217;:  Smoothed images with Gaussian filter</dt>
<dd>obj = preprocess(obj, &#8216;smooth&#8217;, FWHM in mm)</dd>
</dl>
<p>% NOTE: SMOOTHING KERNEL MAY BE IN VOX, AS VOL INFO IS NOT PASSED IN</p>
<p>&#8216;interp_images&#8217;: Interpolate all voxels in a series of images specified
by logical vector whout.</p>
<blockquote>
<div><ul class="simple">
<li>obj = preprocess(obj, &#8216;interp_images&#8217;, whout);</li>
</ul>
</div></blockquote>
<dl class="docutils">
<dt><em>Examples:</em> two complementary ways to get and plot outliers:</dt>
<dd><ul class="first last simple">
<li>dat = preprocess(dat, &#8216;outliers&#8217;, &#8216;plot&#8217;);</li>
<li>subplot(5, 1, 5); % go to new panel...</li>
<li>dat = preprocess(dat, &#8216;outliers_rmssd&#8217;, &#8216;plot&#8217;);</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="&#64;image_vector.read_from_file">
<code class="descclassname">&#64;image_vector.</code><code class="descname">read_from_file</code><span class="sig-paren">(</span><em>obj</em><span class="sig-paren">)</span><a class="headerlink" href="#@image_vector.read_from_file" title="Permalink to this definition">¶</a></dt>
<dd><p>Reads data from image filenames into obj.dat</p>
<blockquote>
<div><ul class="simple">
<li>obj = read_from_file(obj)</li>
</ul>
</div></blockquote>
<p>Try obj = check_image_filenames(obj) first.</p>
<p>This is automatically called if you create a new image_vector object with
names but do not directly enter data. e.g., the commands below will load data:</p>
<blockquote>
<div><ul class="simple">
<li>name = &#8216;salientmap.nii&#8217;;</li>
<li>img = image_vector(&#8216;image_names&#8217;, name);</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="&#64;image_vector.rebuild_volinfo_from_dat">
<code class="descclassname">&#64;image_vector.</code><code class="descname">rebuild_volinfo_from_dat</code><span class="sig-paren">(</span><em>dat</em>, <em>newdat</em><span class="sig-paren">)</span><a class="headerlink" href="#@image_vector.rebuild_volinfo_from_dat" title="Permalink to this definition">¶</a></dt>
<dd><p>dat = rebuild_volinfo_from_dat(dat, newdat)</p>
<p>Will rebuild volInfo (the image space, or sometimes &#8220;mask&#8221;) from a vectorized image. 
In other words, will rebuild dat.volInfo from newdat.</p>
<p>Also resets all voxels to be significant, if a statistic image</p>
<dl class="docutils">
<dt><em>Input</em></dt>
<dd><ul class="first last simple">
<li>dat: an image_vector</li>
<li>newdat: a vector that MUST be size of ENTIRE image (dat.volInfo.nvox)</li>
</ul>
</dd>
<dt><em>Output</em></dt>
<dd><ul class="first last">
<li><dl class="first docutils">
<dt>dat: dat.dat contains the non-zero values of newdat, and dat.volInfo is</dt>
<dd><p class="first last">correctly defining the image space</p>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="&#64;image_vector.reconstruct_image">
<code class="descclassname">&#64;image_vector.</code><code class="descname">reconstruct_image</code><span class="sig-paren">(</span><em>obj</em><span class="sig-paren">)</span><a class="headerlink" href="#@image_vector.reconstruct_image" title="Permalink to this definition">¶</a></dt>
<dd><p>Reconstruct a 3-D or 4-D image from image_vector object obj
[voldata, vectorized_voldata, xyz_coord_struct] = reconstruct_image(obj)</p>
<p>voldata is and X x Y x Z x Images matrix
vectorized_voldata is the same, with all voxels vectorized</p>
<p>This output has one element for every voxel in THE ENTIRE IMAGE, and so
can be very memory-intensive.  But it&#8217;s useful for lining up voxels
across images with different masks/in-mask voxels.</p>
<p>This function returns output in memory;
see image_vector.write for writing .img files to disk.</p>
<dl class="docutils">
<dt><em>Outputs:</em></dt>
<dd><ul class="first last">
<li><p class="first">voldata : 3-D recon volume</p>
</li>
<li><p class="first">vectorized_voldata : volume in column vetor, iimg_xxx function format</p>
</li>
<li><dl class="first docutils">
<dt>xyz_coord_struct <span class="classifier-delimiter">:</span> <span class="classifier">has fields with coordinate information in mm (world) space</span></dt>
<dd><ul class="first last simple">
<li>x, y, z : vectors of coordinates in mm for each of the 3
dimensions of the image</li>
<li>X, Y, Z : output matrices from meshgrid with mm coordinates,
for volume visualization.
These can be passed to surf or isocaps functions for volume
visualization in world space (mm).</li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
<p>Copyright 2011 tor wager</p>
<p><em>Programmers&#8217; notes:</em></p>
<p>Aug 2012: This function does not flip the data based on the sign of x dimension.  
The flipping is applied in image writing / display in
iimg_reconstruct_vols, write method, spm_orthviews, etc.</p>
<p>July 2013 : Tor : Added xyz_coord_struct output</p>
</dd></dl>

<dl class="function">
<dt id="&#64;image_vector.remove_empty">
<code class="descclassname">&#64;image_vector.</code><code class="descname">remove_empty</code><span class="sig-paren">(</span><em>dat</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@image_vector.remove_empty" title="Permalink to this definition">¶</a></dt>
<dd><p>dat = remove_empty(dat, [logical vector of custom voxels to remove], [logical vector of imgs to remove])</p>
<p>remove vox: logical vector of custom voxels to remove, VOX x 1</p>
<p>remove im: logical vector of custom images to remove, 1 x IMAGES</p>
<p>indices of removed data will be stored in removed_voxels and
removed_images fields, to preserve ability to later reconstruct into 3D images</p>
<p>Indicator vectors stored in:
removed_images
removed_voxels</p>
<p><em>See also:</em> replace_empty
force logical</p>
</dd></dl>

<dl class="function">
<dt id="&#64;image_vector.reparse_contiguous">
<code class="descclassname">&#64;image_vector.</code><code class="descname">reparse_contiguous</code><span class="sig-paren">(</span><em>obj</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@image_vector.reparse_contiguous" title="Permalink to this definition">¶</a></dt>
<dd><p>obj = reparse_contiguous(obj, [&#8216;nonempty&#8217;])</p>
<p>Re-construct list of contiguous voxels in an image based on in-image
voxel coordinates.  Coordinates are taken from obj.volInfo.xyzlist.</p>
<p>Results are saved in obj.volInfo.cluster.</p>
<p>xyzlist can be generated from iimg_read_img, and is done automatically by
object-oriented fMRI image classes (fmri_image, image_vector,
statistic_image)</p>
<p>If &#8216;nonempty&#8217; is entered as an optional argument, will use only voxels
that are non-zero, non-nan in all columns of obj.dat.</p>
<p>copyright tor wager, 2011
<em>Programmers&#8217; notes:</em></p>
<dl class="docutils">
<dt>Edited 1/27/13 by tor to use all columns when calculating &#8216;nonempty&#8217;</dt>
<dd>also fixed bug - was not using &#8216;nonempty&#8217; input in some
cases</dd>
</dl>
<p>.cluster and .xyzlist should both always be length v in-mask voxels
if &#8216;nonempty&#8217; is entered, then .dat should be length v in-mask voxels too</p>
</dd></dl>

<dl class="function">
<dt id="&#64;image_vector.replace_empty">
<code class="descclassname">&#64;image_vector.</code><code class="descname">replace_empty</code><span class="sig-paren">(</span><em>obj</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@image_vector.replace_empty" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Replace empty/missing values in an image data object</dt>
<dd><ul class="first last simple">
<li>obj = replace_empty(obj, [optional keywords])</li>
</ul>
</dd>
</dl>
<p>Replace missing values in obj.dat stored in obj.removed_voxels and
obj.removed_images with zeros.  This returns obj.dat in a format that can
be reconstructed into a 3-D or 4-D image matrix for brain visualization.</p>
<p><em>Optional keywords:</em></p>
<p>&#8216;voxels&#8217; or &#8216;images&#8217;: replace only missing voxels/images</p>
<p>Tor Wager, 12/1/10</p>
<p><em>See also:</em> remove_empty, zeroinsert, nanremove, naninsert</p>
</dd></dl>

<dl class="function">
<dt id="&#64;image_vector.resample_space">
<code class="descclassname">&#64;image_vector.</code><code class="descname">resample_space</code><span class="sig-paren">(</span><em>obj</em>, <em>sampleto</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@image_vector.resample_space" title="Permalink to this definition">¶</a></dt>
<dd><p>Resample the images in an fmri_data object (obj) to the space of another
image (sampleto; e.g., a mask image). Works for all image_vector objects.</p>
<blockquote>
<div><ul class="simple">
<li>obj = resample_space(obj, sampleto, [sampling method])</li>
</ul>
</div></blockquote>
<dl class="docutils">
<dt>Sampleto may be one of these:</dt>
<dd><ol class="first last arabic simple">
<li>a volInfo structure (the image does not have to exist on the path)</li>
<li>an image_vector, fmri_data, fmri_mask_image object</li>
<li>a string with the name of an image</li>
</ol>
</dd>
</dl>
<p>Can enter resampling method as optional input. Takes any input to
interp3:</p>
<blockquote>
<div><p>&#8216;nearest&#8217; - nearest neighbor interpolation
&#8216;linear&#8217;  - linear interpolation (default)
&#8216;spline&#8217;  - spline interpolation
&#8216;cubic&#8217;   - cubic interpolation as long as the data is uniformly</p>
<blockquote>
<div>spaced, otherwise the same as &#8216;spline&#8217;</div></blockquote>
</div></blockquote>
<p><em>Examples:</em></p>
<p>label_mask = fmri_data(which(&#8216;atlas_labels_combined.img&#8217;));
label_mask = resample_space(label_mask, ivec, &#8216;nearest&#8217;) % resamples and masks label image
<em>Programmers&#8217; notes:</em></p>
<p>1/27/2012 Tor edited to handle .mask field in fmri_data and .sig field in
statistic_image.  Was causing errors otherwise...</p>
<blockquote>
<div>Also changed automatic behavior to reparse contig voxels with
&#8216;nonempty&#8217; in output obj</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="&#64;image_vector.resample_time">
<code class="descclassname">&#64;image_vector.</code><code class="descname">resample_time</code><span class="sig-paren">(</span><em>obj</em>, <em>source_TR</em>, <em>target_TR</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@image_vector.resample_time" title="Permalink to this definition">¶</a></dt>
<dd><p>Resample the time-series images (source_time_interval) in an fmri_data object (obj) 
to the different time series (target_time_interval). Works for all image_vector objects.</p>
<blockquote>
<div><ul class="simple">
<li>obj = resample_time(obj, source_time_interval, target_time_interval, varargin)</li>
</ul>
</div></blockquote>
<dl class="docutils">
<dt><em>Options:</em></dt>
<dd><ol class="first last arabic">
<li><dl class="first docutils">
<dt>&#8216;meth&#8217; (Interpolation methods)</dt>
<dd><dl class="first last docutils">
<dt>You can enter resampling method as optional input. Takes any input to</dt>
<dd><ul class="first last">
<li><p class="first">&#8216;nearest&#8217; - nearest neighbor interpolation</p>
</li>
<li><p class="first">&#8216;linear&#8217;  - linear interpolation (default)</p>
</li>
<li><p class="first">&#8216;spline&#8217;  - spline interpolation</p>
</li>
<li><dl class="first docutils">
<dt>&#8216;cubic&#8217;   - cubic interpolation as long as the data is uniformly</dt>
<dd><p class="first last">spaced, otherwise the same as &#8216;spline&#8217;</p>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</dd>
</dl>
</li>
<li><p class="first">&#8216;slice&#8217; (a fraction of the slice timing correction)
The default is 0.5, meaning if your TR is 2s, the time point of your TR image
will be considered as the middle point of the TR bins. You can use this option
to use different time points. If you are upsampling your data (i.e.,
your target TR is shorter than your source TR), you need to discard the
first column of your data. This function will return the first time point data as NaN.</p>
</li>
</ol>
</dd>
</dl>
<p><em>Examples:</em></p>
<blockquote>
<div><ul class="simple">
<li>dat = fmri_data(&#8216;/Volumes/RAID1/labdata/current/BMRK3/Imaging/spatiotemp_biomarker/STmarker1.img&#8217;);</li>
<li>dat = resample_time(dat, 2, 1.3)</li>
</ul>
</div></blockquote>
<dl class="docutils">
<dt>with options:</dt>
<dd><ul class="first last simple">
<li>dat = resample_time(dat, 2, 1.3, &#8216;meth&#8217;, &#8216;linear&#8217;, &#8216;slice&#8217;, .3)</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="&#64;image_vector.sagg_slice_movie">
<code class="descclassname">&#64;image_vector.</code><code class="descname">sagg_slice_movie</code><span class="sig-paren">(</span><em>dat</em><span class="optional">[</span>, <em>full_path_of_movie_output_file</em>, <em>image_skip_interval</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#@image_vector.sagg_slice_movie" title="Permalink to this definition">¶</a></dt>
<dd><p>Movie of successive differences (sagittal slice)
Enter an image_vector or fmri_data object (usually with time series)</p>
<p><em>Optional inputs:</em></p>
<blockquote>
<div><dl class="docutils">
<dt>movie_output_file: a char array detailing the full path to save the</dt>
<dd>movie file</dd>
<dt>image_skip_interval: a integer value describing the interval </dt>
<dd>between images in each subsequent frame of the movie 
(default = 1)</dd>
</dl>
</div></blockquote>
<dl class="docutils">
<dt><em>Example:</em></dt>
<dd><ul class="first">
<li><dl class="first docutils">
<dt>sagg_slice_movie(fmri_dat, ...</dt>
<dd><p class="first last">&#8216;/Volumes/engram/labdata/fmri_data/Study1/Subj1/qc_images&#8217;, 5)</p>
</dd>
</dl>
</li>
</ul>
<p class="last">This would save an movie based on the images in fmri_dat to the
above directory, with an interval of 5 images between each
frame (so, the movie would show image 1, 6, 11, 16, etc)</p>
</dd>
<dt>Edited 8/7/14 by Scott</dt>
<dd><ul class="first simple">
<li>added skip interval</li>
<li>updated help</li>
</ul>
<p class="last">8/7/14 Programmer Note: if more varargin options are desired in the
future, the function call will likely need to be re-written. The
current form exists for backwards compatibility - obviously changing
the function call will mean that other functions that use this
(preproc) will need to be modified</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="&#64;image_vector.searchlight">
<code class="descclassname">&#64;image_vector.</code><code class="descname">searchlight</code><span class="sig-paren">(</span><em>dat</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@image_vector.searchlight" title="Permalink to this definition">¶</a></dt>
<dd><p>Run searchlight multivariate prediction/classification on an image_vector
or fmri_data object OR two objects, for cross-prediction.</p>
<p><em>Usage:</em></p>
<p>[list outputs here] = function_name(list inputs here, [optional inputs])
[results_obj, indx] = searchlight(dat, [optional inputs])</p>
<dl class="docutils">
<dt><em>Features:</em></dt>
<dd><ul class="first last simple">
<li>Runs searchlight with standard, pre-defined algorithms</li>
<li>Custom-entry definition of holdout sets</li>
<li>Can re-use searchlight spheres after initial definition</li>
<li>Custom-entry definition of any spheres/regions of interest</li>
<li>Uses Matlab&#8217;s parallel processing toolbox (parfor)</li>
</ul>
</dd>
</dl>
<p>Type help image_vector.searchlight to display this help information</p>
<p>Author and copyright information:</p>
<blockquote>
<div><p>Copyright (C) 2014  Tor Wager and...</p>
<p>This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.</p>
<p>This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.</p>
<p>You should have received a copy of the GNU General Public License
along with this program.  If not, see &lt;<a class="reference external" href="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</a>&gt;.</p>
</div></blockquote>
<p><em>Inputs:</em></p>
<blockquote>
<div><ul class="simple">
<li>dat           image_vector or fmri_data object with data</li>
<li>dat.Y         required: true outcomes for each observation (image) in dat</li>
</ul>
</div></blockquote>
<dl class="docutils">
<dt><em>Optional:</em> Keyword followed by input variable:</dt>
<dd><ul class="first last">
<li><p class="first">&#8216;r&#8217;         searchlight radius, voxels</p>
</li>
<li><p class="first">&#8216;dat2&#8217;      second dataset, for cross-prediction</p>
</li>
<li><dl class="first docutils">
<dt>&#8216;indx&#8217;      sparse logical matrix. each COLUMN is index of inclusion sets for each region/sphere in searchlight</dt>
<dd><p class="first last">This takes a long time to calculate, but can be saved and
re-used for a given mask</p>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
<p><em>Outputs:</em></p>
<blockquote>
<div><ul>
<li><p class="first">results_obj   fmri_data object with results maps</p>
</li>
<li><p class="first">stats         selected statistics for each sphere in searchlight</p>
</li>
<li><dl class="first docutils">
<dt>indx          sparse logical matrix. each COLUMN is index of inclusion sets for each region/sphere in searchlight</dt>
<dd><ul class="first simple">
<li>this can be re-used for all data with the same</li>
</ul>
<p class="last">mask/structure. *</p>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
<p><em>Examples:</em></p>
<dl class="docutils">
<dt>Define a sensible gray-matter mask:</dt>
<dd><ul class="first last simple">
<li>dat = fmri_data(which(&#8216;scalped_avg152T1_graymatter.img&#8217;));</li>
<li>dat = threshold(dat, [.8 Inf], &#8216;raw-between&#8217;);</li>
<li>dat = trim_mask(dat);</li>
</ul>
</dd>
<dt>Create fake data and holdout indicator index vector</dt>
<dd><ul class="first last simple">
<li>dat.dat = randn(dat.volInfo.n_inmask, 30);</li>
<li>dat.Y = dat.dat(111111, :)&#8217; + .3 * randn(30, 1);</li>
<li>holdout_set = ones(6, 1); for i = 2:5, holdout_set = [holdout_set; i*ones(6, 1)]; end</li>
</ul>
</dd>
<dt>Run, and run again with existing indx</dt>
<dd><ul class="first last simple">
<li>pool = parpool(12);  % initialize parallel processing (12 cores)</li>
<li>[results_obj, indx] = searchlight(dat, &#8216;holdout_set&#8217;, holdout_set);</li>
<li>results_obj = searchlight(dat, &#8216;holdout_set&#8217;, holdout_set, &#8216;indx&#8217;, indx);</li>
</ul>
</dd>
</dl>
<p><em>See also:</em>
region.m, fmri_data.predict.m</p>
<p><em>Programmers&#8217; notes:</em>
List dates and changes here, and author of changes</p>
<p>For defining regions</p>
</dd></dl>

<dl class="function">
<dt id="&#64;image_vector.slices">
<code class="descclassname">&#64;image_vector.</code><code class="descname">slices</code><span class="sig-paren">(</span><em>obj</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@image_vector.slices" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a montage of single-slice results for every image in an
image_vector object</p>
<blockquote>
<div><ul class="simple">
<li>o = slices(obj, &#8216;orientation&#8217;, [orientation], &#8216;slice&#8217;, [slice_mm], &#8216;nimages&#8217;, [nimgs])</li>
</ul>
</div></blockquote>
<p>obj is an image_vector, fmri_data, or statistic_image object with
multiple images (only the first 64 will display), which are stored as
columns in its .dat field.</p>
<dl class="docutils">
<dt><em>Optional inputs:</em></dt>
<dd><ul class="first last simple">
<li>&#8216;orientation&#8217; can be followed by &#8216;saggital&#8217;, &#8216;axial&#8217;, or &#8216;coronal&#8217;</li>
<li>&#8216;slice_mm&#8217; is followed by the mm coord of the slice to display; default = 0</li>
<li>&#8216;nimgs&#8217; can be followed by the number of images to display, 1:nimgs</li>
<li>&#8216;names&#8217; is followed by a cell array of names for the images.</li>
<li>&#8216;color&#8217; is followed by color vector or string specification. default is</li>
<li>color-mapped with split colors (hot/cool) for pos and neg effects.</li>
<li>&#8216;outline&#8217; is followed by a color vector for outline around blobs.</li>
</ul>
</dd>
</dl>
<p>The output, o, is an fmridisplay object.</p>
<p>This function uses fmridisplay objects, and may be memory-intensive for
older computers.</p>
<p><em>Common Errors:</em></p>
<p>This function uses the volInfo.cluster field. If you create a mask in an
ad hoc way, this field may not be updated.  use this to fix:
mask = reparse_contiguous(mask);</p>
<p><em>Examples:</em></p>
<blockquote>
<div><ul class="simple">
<li>slices(dat);</li>
<li>slices(dat, &#8216;orientation&#8217;, &#8216;axial&#8217;);</li>
<li>slices(dat, &#8216;slice&#8217;, -5);                 % display sagg at x = -5</li>
<li>o = slices(dat, &#8216;names&#8217;, terms); % use &#8216;terms&#8217; var as names</li>
<li>o2 = slices(all_chi2_images, &#8216;orientation&#8217;, &#8216;saggital&#8217;, &#8216;slice&#8217;, 0);</li>
</ul>
</div></blockquote>
<p>Copyright 2011, Tor Wager</p>
</dd></dl>

<dl class="function">
<dt id="&#64;image_vector.surface">
<code class="descclassname">&#64;image_vector.</code><code class="descname">surface</code><span class="sig-paren">(</span><em>obj</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@image_vector.surface" title="Permalink to this definition">¶</a></dt>
<dd><p>[all_surf_handles, pcl, ncl] = surface(obj)</p>
<dl class="docutils">
<dt><em>Usage:</em></dt>
<dd><ul class="first last simple">
<li>[all_surf_handles, pcl, ncl] = surface(r, [&#8216;cutaways&#8217;, any optional inputs to surface_cutaway])</li>
</ul>
</dd>
</dl>
<p>This function uses region.surface to create surface figures.
See help region.surface for options.</p>
<p><em>Examples:</em></p>
<dl class="docutils">
<dt>create an initial surface plot from an fmri_data object:</dt>
<dd><ul class="first last simple">
<li>han = surface(regionmasks{2});</li>
</ul>
</dd>
<dt>Now add a second region in green:</dt>
<dd><ul class="first last simple">
<li>cluster_surf(region(regionmasks{2}), {[0 1 0]}, han, 5);</li>
</ul>
</dd>
<dt>Use optional arguments taken by surface_cutaway:</dt>
<dd><ul class="first last simple">
<li>poscm = colormap_tor([1 .3 0], [1 1 0]); % orange to yellow</li>
<li>[all_surf_handles, pcl, ncl] = surface(t, &#8216;cutaway&#8217;, &#8216;ycut_mm&#8217;, -30, &#8216;pos_colormap&#8217;, poscm, &#8216;existingfig&#8217;);</li>
<li>[all_surf_handles2, pcl, ncl] = surface(t, &#8216;foursurfaces&#8217;, &#8216;pos_colormap&#8217;, poscm, &#8216;neg_colormap&#8217;, negcm);</li>
<li>[all_surf_handles2, pcl, ncl] = surface(t, &#8216;foursurfaces&#8217;, &#8216;existingfig&#8217;, &#8216;color_upperboundpercentile&#8217;, 95, &#8216;color_lowerboundpercentile&#8217;, 5, &#8216;neg_colormap&#8217;, colormap_tor([0 0 1], [.3 0 .5]));</li>
</ul>
</dd>
<dt>use mediation_brain_surface_figs and re-make colors</dt>
<dd><ul class="first last simple">
<li>all_surf_handles = mediation_brain_surface_figs([]);</li>
<li>surface(t2, &#8216;cutaway&#8217;, &#8216;surface_handles&#8217;, all_surf_handles, &#8216;color_upperboundpercentile&#8217;, 95, &#8216;color_lowerboundpercentile&#8217;, 5, &#8216;neg_colormap&#8217;, colormap_tor([0 0 1], [.2 0 .5]));</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="&#64;image_vector.threshold">
<code class="descclassname">&#64;image_vector.</code><code class="descname">threshold</code><span class="sig-paren">(</span><em>obj</em>, <em>input_threshold</em>, <em>thresh_type</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@image_vector.threshold" title="Permalink to this definition">¶</a></dt>
<dd><p>Threshold image_vector (or fmri_data or fmri_obj_image) object based on
raw threshold values. For statistical thresholding, convert to a
statistic_image object and see the threshold method for that object.</p>
<dl class="docutils">
<dt><em>Usage:</em></dt>
<dd><ul class="first last simple">
<li>obj = threshold(obj, input_threshold, thresh_type, [optional arguments])</li>
</ul>
</dd>
</dl>
<p>This is a method for an image_vector object</p>
<p>Thresholding is not reversible. For statistic_image objects it is.</p>
<dl class="docutils">
<dt>For objects: Type methods(object_name) for a list of special commands</dt>
<dd>Type help object_name.method_name for help on specific
methods.</dd>
</dl>
<p>Author and copyright information:</p>
<blockquote>
<div><p>Copyright (C) 2015 Tor Wager</p>
<p>This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.</p>
<p>This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.</p>
<p>You should have received a copy of the GNU General Public License
along with this program.  If not, see &lt;<a class="reference external" href="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</a>&gt;.</p>
</div></blockquote>
<p><em>Inputs:</em></p>
<blockquote>
<div><ul>
<li><p class="first">obj               image_vector object</p>
</li>
<li><dl class="first docutils">
<dt>input_threshold   Vector of 2 values defining data value bounds at which</dt>
<dd><p class="first last">to threshold, e.g., [0 Inf] or [-3 3]</p>
</dd>
</dl>
</li>
<li><p class="first">thresh_type       String: &#8216;raw-between&#8217; or &#8216;raw-outside&#8217;</p>
</li>
</ul>
</div></blockquote>
<dl class="docutils">
<dt><em>Optional:</em> Argument or argument followed by value</dt>
<dd><ul class="first last simple">
<li>&#8216;k&#8217;               Followed by extent threshold cluster size, default = 1</li>
<li>&#8216;trim_mask&#8217;       Reduce the mask in obj.voInfo based on thresholding</li>
<li>&#8216;noverbose&#8217;       Suppress verbose output</li>
</ul>
</dd>
<dt><em>Outputs:</em></dt>
<dd><ul class="first last simple">
<li>obj           thresholded image_vector object</li>
</ul>
</dd>
</dl>
<p><em>Examples:</em></p>
<dl class="docutils">
<dt>Retain positive values, cluster extent &gt; 100 voxels</dt>
<dd><ul class="first last simple">
<li>obj = threshold(obj, [0 Inf], &#8216;raw-between&#8217;, &#8216;k&#8217;, 100)</li>
</ul>
</dd>
<dt>Retain voxels with absolute value &gt; 3</dt>
<dd><ul class="first last simple">
<li>obj = threshold(obj, [-3 3], &#8216;raw-outside&#8217;)</li>
</ul>
</dd>
</dl>
<p><em>See also:</em>
statistic_image.threshold, statistic_image.multi_threshold</p>
<p><em>Programmers&#8217; notes:</em>
Tor: Updated documentation, July 2015
Inputs</p>
</dd></dl>

<dl class="function">
<dt id="&#64;image_vector.trim_mask">
<code class="descclassname">&#64;image_vector.</code><code class="descname">trim_mask</code><span class="sig-paren">(</span><em>obj</em><span class="sig-paren">)</span><a class="headerlink" href="#@image_vector.trim_mask" title="Permalink to this definition">¶</a></dt>
<dd><p>Exclude empty voxels from mask information in obj.volInfo structure, and re-make obj.volInfo</p>
<blockquote>
<div><ul class="simple">
<li>obj = trim_mask(obj)</li>
</ul>
</div></blockquote>
<p>Tor Wager, 2013</p>
</dd></dl>

<dl class="function">
<dt id="&#64;image_vector.union">
<code class="descclassname">&#64;image_vector.</code><code class="descname">union</code><span class="sig-paren">(</span><em>dat1</em>, <em>dat2</em>, <em>outputname</em><span class="sig-paren">)</span><a class="headerlink" href="#@image_vector.union" title="Permalink to this definition">¶</a></dt>
<dd><p>Union and intersection masks for two image_vector objects</p>
<blockquote>
<div><ul>
<li><p class="first">[dat_union, dat_intersection] = union(dat1, dat2, outputname)</p>
</li>
<li><p class="first">dat = union(dat1, dat2, outputname)
outputname = character array name for union image</p>
<blockquote>
<div><p>INCLUDE .img at the end.</p>
</div></blockquote>
</li>
</ul>
</div></blockquote>
<p>NOTE: must now be in same space!</p>
<p>tor</p>
</dd></dl>

<dl class="function">
<dt id="&#64;image_vector.write">
<code class="descclassname">&#64;image_vector.</code><code class="descname">write</code><span class="sig-paren">(</span><em>obj</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@image_vector.write" title="Permalink to this definition">¶</a></dt>
<dd><p>Write an image_vector object to an Analyze image.
Option to write thresholded image, for statistic_image objects.</p>
<p>obj.dat should contain data, with one COLUMN for each 3-D frame in the
4-D image to be written.</p>
<p><em>Usage:</em></p>
<blockquote>
<div><ul class="simple">
<li>write(obj)  -&gt; writes to the image(s) specified in obj.fullpath</li>
<li>write(obj, &#8216;thresh&#8217;) -&gt; for statistic_image objects, writes thresholded</li>
<li>write(obj, &#8216;fname&#8217;, &#8216;~/Documents/test.nii&#8217;)  -&gt; writes the image(s) to specific path</li>
</ul>
</div></blockquote>
<p><em>For example:</em> 
If m is an image_vector object,</p>
<blockquote>
<div><ul class="simple">
<li>m.X(m.X &lt; .12) = 0; % apply an arbitrary but reasonable custom threshold</li>
<li>orthviews(m);</li>
</ul>
</div></blockquote>
<dl class="docutils">
<dt>write the thresholded image to disk:</dt>
<dd><ul class="first last simple">
<li>anatmeanname = &#8216;mean_gray_matter_mask.img&#8217;;</li>
<li>m.filename = anatmeanname;</li>
<li>m.fullpath = fullfile(maskdir, anatmeanname);</li>
<li>write(m)</li>
</ul>
</dd>
<dt><em>Option:</em></dt>
<dd><dl class="first docutils">
<dt>&#8216;mni&#8217;       resample image to standard MNI FOV (91x109x91)</dt>
<dd>uses mri_data.resample_space</dd>
</dl>
<p>&#8216;keepdt&#8217;    output image will be keep original data type (default = float32)
&#8216;fname&#8217;     writes out image to specific file name.  &#8216;fname&#8217; must be</p>
<blockquote class="last">
<div>followed by image name with path</div></blockquote>
</dd>
</dl>
<p>2013/3/5: Luk[ea] added &#8216;mni&#8217; option</p>
<p>2013/3/25: Luke[ea] added optional input to retain original datatype</p>
<p>2014/3/14: Luke added &#8216;fname&#8217; option to specify filename</p>
</dd></dl>

</div>
<div class="section" id="module-&#64;region">
<span id="region"></span><h1>region<a class="headerlink" href="#module-@region" title="Permalink to this headline">¶</a></h1>
<dl class="function">
<dt id="&#64;region.check_extracted_data">
<code class="descclassname">&#64;region.</code><code class="descname">check_extracted_data</code><span class="sig-paren">(</span><em>cl</em><span class="sig-paren">)</span><a class="headerlink" href="#@region.check_extracted_data" title="Permalink to this definition">¶</a></dt>
<dd><p>isok = check_extracted_data(cl)</p>
<p>cl must be a valid region object (see region.m)
and cl(1).source_images must still be on the path.</p>
<p>Checks the data, just in case of space/programming issues, 
by re-extracting the region average data from 5 random regions 
using spm_get_data.m, and compares it to the already-saved values</p>
<p>You should not need to run this regularly &#8211; but you should if you
suspect things have gone awry.</p>
</dd></dl>

<dl class="function">
<dt id="&#64;region.extract_data">
<code class="descclassname">&#64;region.</code><code class="descname">extract_data</code><span class="sig-paren">(</span><em>r</em>, <em>data_obj</em><span class="sig-paren">)</span><a class="headerlink" href="#@region.extract_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Extract data from image_vector object (data_obj) for voxels specified by a region object (r)
Returns extracted data and averages</p>
<p><em>Features:</em></p>
<p>data_obj does not have to be in the same space, uses mm coordinates</p>
<dl class="docutils">
<dt><em>Usage:</em></dt>
<dd><ul class="first last simple">
<li>region_obj = extract_data(region_obj, data_obj)</li>
</ul>
</dd>
</dl>
<p>Type methods(region) for a list of special commands for region object
Type help object_name.method_name for help on specific methods.</p>
<p>Author and copyright information:</p>
<blockquote>
<div><p>Copyright (C) 2010 Tor Wager</p>
<p>This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.</p>
<p>This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.</p>
<p>You should have received a copy of the GNU General Public License
along with this program.  If not, see &lt;<a class="reference external" href="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</a>&gt;.</p>
</div></blockquote>
<dl class="docutils">
<dt><em>Inputs:</em></dt>
<dd><ul class="first last">
<li><p class="first">r           a region object</p>
</li>
<li><dl class="first docutils">
<dt>data_obj    an image_vector or fmri_data object to extract data from</dt>
<dd><p class="first last">does not have to be in the same space, uses mm coordinates</p>
</dd>
</dl>
</li>
</ul>
</dd>
<dt><em>Outputs:</em></dt>
<dd><ul class="first last simple">
<li>r           a region object, with data attached</li>
</ul>
</dd>
</dl>
<p><em>Examples:</em>
give examples here</p>
<p><em>See also:</em>
list other functions related to this one, and alternatives*</p>
<p><em>Programmers&#8217; notes:</em></p>
<p>8/3/2015 Tor Wager: Fixed bug in averaging when only 1 voxel in region</p>
</dd></dl>

<dl class="function">
<dt id="&#64;region.merge">
<code class="descclassname">&#64;region.</code><code class="descname">merge</code><span class="sig-paren">(</span><em>cl</em>, <em>wh_merge</em><span class="sig-paren">)</span><a class="headerlink" href="#@region.merge" title="Permalink to this definition">¶</a></dt>
<dd><p>Merge two or more regions together in a region object.
Combines fields from all clusters in the named series with the first one
in the series.</p>
<blockquote>
<div><ul class="simple">
<li>wh_merge = [3 4];</li>
<li>cl = merge(cl, wh_merge)</li>
</ul>
</div></blockquote>
<p>Tor Wager, April 2011</p>
</dd></dl>

<dl class="function">
<dt id="&#64;region.posneg_separate">
<code class="descclassname">&#64;region.</code><code class="descname">posneg_separate</code><span class="sig-paren">(</span><em>cl</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@region.posneg_separate" title="Permalink to this definition">¶</a></dt>
<dd><p>Separate a region object (cl) into clusters with positive and negative
peak values, based on max (peak) value in .val or .Z field (default =
val)</p>
<blockquote>
<div><ul class="simple">
<li>[pcl, ncl] = posneg_separate(cl, [&#8216;Z&#8217;])</li>
</ul>
</div></blockquote>
<p>Returns pcl and ncl, region structures with positive- and negative-valued
peaks, respectively, copied from the original cl input.</p>
<p><em>Optional input:</em> &#8216;Z&#8217;, to use .Z field</p>
<dl class="docutils">
<dt><em>Note:</em> You may have to use reparse_continguous to get this to work right.</dt>
<dd><ul class="first last simple">
<li>r = reparse_continguous(r);</li>
<li>[pcl, ncl] = posneg_separate(r);</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="&#64;region.region2imagevec">
<code class="descclassname">&#64;region.</code><code class="descname">region2imagevec</code><span class="sig-paren">(</span><em>cl</em><span class="sig-paren">)</span><a class="headerlink" href="#@region.region2imagevec" title="Permalink to this definition">¶</a></dt>
<dd><p>[ivecobj, orig_cluster_indx]  = region2imagevec(cl)</p>
<p>Convert a region object to an image_vector object, replacing the voxels
and reconstructing as much info as possible.</p>
<p>The .dat field of the new &#8220;ivecobj&#8221; is made from the cl.all_data field.
if this is empty, uses cl.val field, then cl.Z as a backup.
Mask information is available in ivecobj.volInfo.</p>
<blockquote>
<div><ul class="simple">
<li>ivecobj = region2imagevec(cl)</li>
</ul>
</div></blockquote>
<p>NEEDS SOME ADDITIONAL WORK/CHECKING</p>
</dd></dl>

<dl class="function">
<dt id="&#64;region.region2imagevec2tmp">
<code class="descclassname">&#64;region.</code><code class="descname">region2imagevec2tmp</code><span class="sig-paren">(</span><em>cl</em><span class="sig-paren">)</span><a class="headerlink" href="#@region.region2imagevec2tmp" title="Permalink to this definition">¶</a></dt>
<dd><p>[ivecobj, orig_cluster_indx]  = region2imagevec2tmp(cl)</p>
<p>Convert a region object to an image_vector object, replacing the voxels
and reconstructing as much info as possible.</p>
<p>The .dat field of the new &#8220;ivecobj&#8221; is made from the cl.all_data field.
if this is empty, uses cl.val field, then cl.Z as a backup.
Mask information is available in ivecobj.volInfo.</p>
<blockquote>
<div><ul class="simple">
<li>ivecobj = region2imagevec(cl)</li>
</ul>
</div></blockquote>
<p>NEEDS SOME ADDITIONAL WORK/CHECKING</p>
</dd></dl>

<dl class="function">
<dt id="&#64;region.region2struct">
<code class="descclassname">&#64;region.</code><code class="descname">region2struct</code><span class="sig-paren">(</span><em>cl</em><span class="sig-paren">)</span><a class="headerlink" href="#@region.region2struct" title="Permalink to this definition">¶</a></dt>
<dd><p>cl = region2struct(cl)</p>
<p>Convert a region object to a simple structure, primarily for
compatibility with other, older CANlab tools.</p>
<p>see also cluster2region, for the reverse transformation</p>
</dd></dl>

<dl class="function">
<dt id="&#64;region.reparse_continguous">
<code class="descclassname">&#64;region.</code><code class="descname">reparse_continguous</code><span class="sig-paren">(</span><em>cl</em><span class="sig-paren">)</span><a class="headerlink" href="#@region.reparse_continguous" title="Permalink to this definition">¶</a></dt>
<dd><p>Re-define regions in region object based on contiguous blobs</p>
<blockquote>
<div><ul class="simple">
<li>clout = reparse_continguous(cl)</li>
</ul>
</div></blockquote>
<p>NEEDS SOME ADDITIONAL WORK/CHECKING</p>
</dd></dl>

<dl class="function">
<dt id="&#64;region.subdivide_by_atlas">
<code class="descclassname">&#64;region.</code><code class="descname">subdivide_by_atlas</code><span class="sig-paren">(</span><em>r</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@region.subdivide_by_atlas" title="Permalink to this definition">¶</a></dt>
<dd><p>r = subdivide_by_atlas(r, [atlas name])</p>
<dl class="docutils">
<dt><em>Inputs:</em></dt>
<dd><ul class="first last">
<li><p class="first">r = a region object, defined using region(mask)</p>
</li>
<li><dl class="first docutils">
<dt>atlas name: Optional mask image with integer codes defining in-mask</dt>
<dd><p class="first last">regions.  Default is &#8216;atlas_labels_combined.img&#8217;</p>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
<p><em>Output:</em> A region object with separate clusters for each contiguous blob,
subdivided by regions labeled in atlas.</p>
<dl class="docutils">
<dt><em>Example:</em></dt>
<dd><ul class="first last simple">
<li>r = subdivide_by_atlas(r);</li>
<li>r(cat(1, r.numVox) &lt; 20) = []; % get rid of small regions</li>
<li>cluster_orthviews(r, &#8216;unique&#8217;);</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="&#64;region.subdivide_by_local_max">
<code class="descclassname">&#64;region.</code><code class="descname">subdivide_by_local_max</code><span class="sig-paren">(</span><em>r</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@region.subdivide_by_local_max" title="Permalink to this definition">¶</a></dt>
<dd><p>Subdivide regions into sub-regions based on local peak Z-scores/maxima</p>
<dl class="docutils">
<dt><em>Usage:</em></dt>
<dd><ul class="first last simple">
<li>subregions = subdivide_by_local_max(r, [&#8216;mm_distance&#8217;, value], [&#8216;noorthviews&#8217;])</li>
</ul>
</dd>
<dt>For objects: Type methods(object_name) for a list of special commands</dt>
<dd>Type help object_name.method_name for help on specific
methods.</dd>
</dl>
<p>Author and copyright information:</p>
<blockquote>
<div><p>Copyright (C) 2015 Tor Wager</p>
<p>This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.</p>
<p>This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.</p>
<p>You should have received a copy of the GNU General Public License
along with this program.  If not, see &lt;<a class="reference external" href="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</a>&gt;.</p>
</div></blockquote>
<dl class="docutils">
<dt><em>Inputs:</em> All Optional</dt>
<dd><ul class="first last simple">
<li>&#8216;mm_distance&#8217;     Followed by mm distance minimum for dividing subclusters</li>
<li>&#8216;noorthviews&#8217;     Suppress display of orthviews</li>
</ul>
</dd>
<dt><em>Outputs:</em></dt>
<dd><ul class="first last simple">
<li>subregions        subdivided region object</li>
</ul>
</dd>
</dl>
<p><em>Examples:</em>
give examples here</p>
<p><em>See also:</em></p>
<p>region.subdivide_by_atlas, subclusters_from_local_max, cluster_local_maxima</p>
<p>Programmers&#8217; notes:
List dates and changes here, and author of changes</p>
<p>BELOW IS A STANDARD TEMPLATE FOR DEFINING VARIABLE (OPTIONAL) INPUT
ARGUMENTS. MANY FUNCTIONS NEED TO PARSE OPTIONAL ARGS, SO THIS MAY BE
USEFUL.</p>
</dd></dl>

<dl class="function">
<dt id="&#64;region.surface">
<code class="descclassname">&#64;region.</code><code class="descname">surface</code><span class="sig-paren">(</span><em>r</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@region.surface" title="Permalink to this definition">¶</a></dt>
<dd><p>Surface method for region object - renders blobs on multiple types of 3-D surface</p>
<dl class="docutils">
<dt><em>Usage:</em></dt>
<dd><ul class="first last simple">
<li>[all_surf_handles, pcl, ncl] = surface(r, [&#8216;cutaways&#8217;, any optional inputs to surface_cutaway])</li>
</ul>
</dd>
</dl>
<blockquote>
<div><p>Copyright (C) 2013 Tor Wager</p>
<p>This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.</p>
<p>This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.</p>
<p>You should have received a copy of the GNU General Public License
along with this program.  If not, see &lt;<a class="reference external" href="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</a>&gt;.</p>
</div></blockquote>
<dl class="docutils">
<dt><em>Inputs:</em></dt>
<dd><ul class="first last">
<li><p class="first">r                A region object</p>
</li>
<li><dl class="first docutils">
<dt>&#8216;cutaway&#8217;        String command for rendering cutaways instead of the default</dt>
<dd><ul class="first last simple">
<li>default is call to mediation_brain_surface_figs</li>
<li>cutaways calls surface_cutaway</li>
<li>all optional arguments are passed to surface_cutaway</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>&#8216;rightsurface&#8217;   String command for rendering a right frontal cortical</dt>
<dd><p class="first last">view complementary to &#8216;cutaways&#8217;</p>
</dd>
</dl>
</li>
<li><p class="first">&#8216;foursurfaces&#8217;   Compact plots of four surfaces</p>
</li>
</ul>
</dd>
</dl>
<p>Other optional inputs to surface_cutaway
e.g., &#8216;pos_colormap&#8217;</p>
<dl class="docutils">
<dt><em>Outputs:</em></dt>
<dd><ul class="first last simple">
<li>all_surf_handles       surface patch handles</li>
<li>pcl                    region object with positive-only clusters</li>
<li>ncl                    region object with negative-only clusters</li>
</ul>
</dd>
</dl>
<p><em>Examples:</em>
Use surface(r), with optional arguments taken by surface_cutaway:</p>
<blockquote>
<div><ul class="simple">
<li>poscm = colormap_tor([1 .3 0], [1 1 0]); % orange to yellow</li>
<li>[all_surf_handles, pcl, ncl] = surface(r, &#8216;cutaway&#8217;, &#8216;ycut_mm&#8217;, -30, &#8216;pos_colormap&#8217;, poscm, &#8216;existingfig&#8217;);</li>
<li>[all_surf_handles2, pcl, ncl] = surface(r, &#8216;foursurfaces&#8217;, &#8216;pos_colormap&#8217;, poscm, &#8216;neg_colormap&#8217;, negcm);</li>
<li>[all_surf_handles2, pcl, ncl] = surface(r, &#8216;foursurfaces&#8217;, &#8216;existingfig&#8217;, &#8216;color_upperboundpercentile&#8217;, 95, &#8216;color_lowerboundpercentile&#8217;, 5, &#8216;neg_colormap&#8217;, colormap_tor([0 0 1], [.4 0 .7]));</li>
</ul>
</div></blockquote>
<dl class="docutils">
<dt>use mediation_brain_surface_figs and re-make colors</dt>
<dd><ul class="first last simple">
<li>all_surf_handles = mediation_brain_surface_figs([]);</li>
<li>surface(r, &#8216;cutaway&#8217;, &#8216;surface_handles&#8217;, all_surf_handles, &#8216;color_upperboundpercentile&#8217;, 95, &#8216;color_lowerboundpercentile&#8217;, 5, &#8216;neg_colormap&#8217;, colormap_tor([0 0 1], [.2 0 .5]));</li>
</ul>
</dd>
</dl>
<p><em>See also:</em></p>
<p>default options
optional inputs</p>
</dd></dl>

<dl class="function">
<dt id="&#64;region.table">
<code class="descclassname">&#64;region.</code><code class="descname">table</code><span class="sig-paren">(</span><em>cl</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@region.table" title="Permalink to this definition">¶</a></dt>
<dd><p>Print a table of all regions in a region object (cl)</p>
<blockquote>
<div><ul class="simple">
<li>[poscl, negcl] = table(cl, [optional inputs])</li>
</ul>
</div></blockquote>
<dl class="docutils">
<dt><em>Optional inputs:</em></dt>
<dd><ul class="first last simple">
<li>&#8216;k&#8217;           : Print only regions with k or more contiguous voxels</li>
<li>&#8216;nosep&#8217;       : do not separate cl with pos and neg effects based on peak in .val</li>
<li>&#8216;names&#8217;       : name clusters before printing to table and output; saves in .shorttitle field</li>
<li>&#8216;forcenames&#8217;  : force naming of cl by removing existing names in .shorttitle field</li>
</ul>
</dd>
</dl>
<p><em>Outputs:</em></p>
<p>Returns region objects for cl with pos and neg effects, limited by size if entered
and named if entered as optional input</p>
<p>Copyright 2011, tor wager</p>
</dd></dl>

</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">fmri_data</a></li>
<li><a class="reference internal" href="#module-&#64;fmri_mask_image">fmri_mask_image</a></li>
<li><a class="reference internal" href="#module-&#64;fmri_model">fmri_model</a></li>
<li><a class="reference internal" href="#module-&#64;image_vector">image_vector</a></li>
<li><a class="reference internal" href="#module-&#64;region">region</a></li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="index.html"
                        title="previous chapter">CanlabCore documentation home</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/moduleslist.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="mat-modindex.html" title="MATLAB Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="index.html" title="CanlabCore documentation home"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">CanlabCore 1.0 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &copy; Copyright 2015, Tor Wager.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.3.1.
    </div>
  </body>
</html>