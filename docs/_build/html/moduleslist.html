<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>canlab_dataset &mdash; CanlabCore 1.0 documentation</title>
    
    <link rel="stylesheet" href="_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="CanlabCore 1.0 documentation" href="index.html" />
    <link rel="prev" title="CanlabCore documentation home" href="index.html" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="mat-modindex.html" title="MATLAB Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="index.html" title="CanlabCore documentation home"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">CanlabCore 1.0 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="toctree-wrapper compound">
<ul class="simple">
</ul>
</div>
<div class="section" id="canlab-dataset">
<h1>canlab_dataset<a class="headerlink" href="#canlab-dataset" title="Permalink to this headline">¶</a></h1>
<span class="target" id="module-&#64;canlab_dataset"></span><dl class="function">
<dt id="&#64;canlab_dataset.bars">
<code class="descclassname">&#64;canlab_dataset.</code><code class="descname">bars</code><span class="sig-paren">(</span><em>obj</em>, <em>varnames</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@canlab_dataset.bars" title="Permalink to this definition">¶</a></dt>
<dd><p>Bar plot for canlab_dataset object</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="p">[</span><span class="n">dat</span><span class="p">,</span> <span class="n">descrip</span><span class="p">,</span> <span class="n">colors</span><span class="p">,</span> <span class="n">h1</span><span class="p">,</span> <span class="n">s1</span><span class="p">]</span> <span class="o">=</span> <span class="n">bars</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">varnames</span><span class="p">,</span> <span class="n">varargin</span><span class="p">)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Inputs:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>obj:</strong></dt>
<dd><p class="first last">canlab_dataset object</p>
</dd>
<dt><strong>varnames:</strong></dt>
<dd><p class="first last">Cell string of variable names to plot</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p>Takes any optional inputs to barplot_colored.m</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Outputs:</th><td class="field-body"><dl class="first docutils">
<dt><strong>dat:</strong></dt>
<dd><p class="first last">data matrix for each variable</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Examples:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>create_figure(&#39;NPS values - All subjects&#39;);

varnames = {&#39;15&#39; &#39;13&#39; &#39;11&#39; &#39; 9&#39; &#39;16&#39; &#39;14&#39; &#39;12&#39; &#39;10&#39;};
xvals = [1 2 4 5 8 9 11 12];
colors = {[1 0 0] [0 1 0] [1 0 0] [0 1 0] [1 0 0] [0 1 0] [1 0 0] [0 1 0]};
bars(LevoNPS, varnames, &#39;x&#39;, xvals, &#39;colors&#39;, colors, &#39;XTickLabels&#39;, varnames, &#39;within&#39;, &#39;nofig&#39;);
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="&#64;canlab_dataset.concatenate">
<code class="descclassname">&#64;canlab_dataset.</code><code class="descname">concatenate</code><span class="sig-paren">(</span><em>D</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@canlab_dataset.concatenate" title="Permalink to this definition">¶</a></dt>
<dd><p>Concatenates Subject-level and Event-level data across all subjects</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>[names ids dat] = concatenate(D)
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Inputs:</th><td class="field-body"><dl class="first docutils">
<dt><strong>D:</strong></dt>
<dd><p class="first last">canlab_dataset</p>
</dd>
<dt><strong>varargin:</strong></dt>
<dd><p class="first last">currently accepts a wh_keep (logical array)</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Outputs:</th><td class="field-body"><dl class="first docutils">
<dt><strong>Names:</strong></dt>
<dd><p class="first last">cell array of variable names</p>
</dd>
<dt><strong>Descrip:</strong></dt>
<dd><p class="first last">cell array of variable descriptions</p>
</dd>
<dt><strong>ids:</strong></dt>
<dd><p class="first last">subject IDs matching data rows in dat</p>
</dd>
<dt><strong>dat:</strong></dt>
<dd><dl class="first last docutils">
<dt>subjects*events x variables matrix</dt>
<dd><ul class="first last simple">
<li>subject number, event number are included</li>
<li>all subject-level and event-level data are included</li>
<li>this format appropriate for, e.g., SAS/HLM</li>
</ul>
</dd>
</dl>
</dd>
</dl>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Examples:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>[names, ids, flatdat] = concatenate(D);
id_numbers = flatdat(:, 1);

wh_subjs = true(size(D.Subj_Level.id));
wh_subjs([13 18 19]) = false;
[names, ids, dat] = concatenate(D, wh_subjs);
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="&#64;canlab_dataset.get_var">
<code class="descclassname">&#64;canlab_dataset.</code><code class="descname">get_var</code><span class="sig-paren">(</span><em>D</em>, <em>varname</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@canlab_dataset.get_var" title="Permalink to this definition">¶</a></dt>
<dd><p>Get Subject-level or Event-level variable from dataset D and return in
rect matrix and cell array. Multiple variables can be requested, but 
all data requested must be either numeric or text, and not a combination of the two.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>[dat, datcell, wh_level, descrip] = get_var(D, varname, [opt inputs])
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Inputs:</th><td class="field-body"><dl class="first docutils">
<dt><strong>D:</strong></dt>
<dd><p class="first last">a canlab_dataset object</p>
</dd>
<dt><strong>varname:</strong></dt>
<dd><dl class="first last docutils">
<dt>the name of a variable to get from dataset</dt>
<dd><ul class="first last simple">
<li>Looks for var name at either level, returns error if exists at both levels</li>
<li>can be a cell array of multiple var names
in this case, dat is a n x m matrix, where n=subjs and m=variables requested</li>
</ul>
</dd>
</dl>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Optional inputs:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body"><p class="first">a vector of 1/0 values to use as wh_keep</p>
<dl class="docutils">
<dt><strong>conditional:</strong></dt>
<dd><p class="first last">to be followed by a cell array; the first cell is the name
of the variable to be conditionally selected upon, the second cell
contains the condition which must be met.
Example: get_var(D, &#8216;DeltaDon&#8217;, &#8216;conditional&#8217;, {&#8216;trained&#8217; 1})
will get DeltaDon whenever trained==1.  Currently only implemented for
event-level data.  Could be expanded to include multiple conditions.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Outputs:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>dat:</strong></dt>
<dd><blockquote class="first">
<div><p>rect matrix of subjects X events (X variables)</p>
</div></blockquote>
<ul class="last simple">
<li>good for plotting individuals, means/std. errors across subjects</li>
<li>is actually a cell matrix if textual data is requested.</li>
</ul>
</dd>
<dt><strong>datcell:</strong></dt>
<dd><blockquote class="first">
<div><p>1 x subjects cell array, each cell containing event data for one subject</p>
</div></blockquote>
<ul class="last simple">
<li>good for input into some stats functions, e.g., glmfit_multilevel
and igls.m</li>
</ul>
</dd>
<dt><strong>wh_level:</strong></dt>
<dd><p class="first last">1 = &#8216;Subject&#8217;; 2 = &#8216;Event&#8217;;</p>
</dd>
<dt><strong>descrip:</strong></dt>
<dd><p class="first last">the description for this variable</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="&#64;canlab_dataset.glm">
<code class="descclassname">&#64;canlab_dataset.</code><code class="descname">glm</code><span class="sig-paren">(</span><em>D</em>, <em>Yvarname</em>, <em>Xvarnames</em>, <em>wh_keep</em><span class="sig-paren">)</span><a class="headerlink" href="#@canlab_dataset.glm" title="Permalink to this definition">¶</a></dt>
<dd><p>predict Y from X using GLM</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="n">out</span> <span class="o">=</span> <span class="n">glm</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="n">Yvarname</span><span class="p">,</span> <span class="n">Xvarnames</span><span class="p">,</span> <span class="n">wh_keep</span><span class="p">)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Inputs:</th><td class="field-body"><dl class="first docutils">
<dt><strong>D:</strong></dt>
<dd><p class="first last">a canlab_dataset object</p>
</dd>
<dt><strong>Yvarname:</strong></dt>
<dd><p class="first last">the name of a variable to predict. must be subject level</p>
</dd>
<dt><strong>Xvarnames:</strong></dt>
<dd><p class="first last">the name(s) of predictor variables. if multiple, put in
cell array. must be subject_level</p>
</dd>
<dt><strong>wh_keep:</strong></dt>
<dd><p class="first last">a vector of 1/0 values to use as wh_keep</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Outputs:</th><td class="field-body"><p class="first">same as for glmfit()</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Examples:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="n">out</span> <span class="o">=</span> <span class="n">glm</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="s">&#39;DeltaDon_avg&#39;</span><span class="p">,</span> <span class="n">prednames</span><span class="p">,</span> <span class="n">wh_keep</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="&#64;canlab_dataset.glm_multilevel">
<code class="descclassname">&#64;canlab_dataset.</code><code class="descname">glm_multilevel</code><span class="sig-paren">(</span><em>D</em>, <em>Yvarname</em>, <em>Xvarnames</em>, <em>wh_keep</em><span class="sig-paren">)</span><a class="headerlink" href="#@canlab_dataset.glm_multilevel" title="Permalink to this definition">¶</a></dt>
<dd><p>Predict Y from X using GLM</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="p">[</span><span class="n">b</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="n">stat</span><span class="p">]</span> <span class="o">=</span> <span class="n">glm</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="s">&#39;DeltaDon_avg&#39;</span><span class="p">,</span> <span class="n">prednames</span><span class="p">,</span> <span class="n">wh_keep</span><span class="p">)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Inputs:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>D:</strong></dt>
<dd><p class="first last">a canlab_dataset object</p>
</dd>
<dt><strong>Yvarname:</strong></dt>
<dd><p class="first last">the name of a variable to predict. must be event level</p>
</dd>
<dt><strong>Xvarnames:</strong></dt>
<dd><p class="first last">the name(s) of predictor variables. if multiple, put in
cell array. must be event level</p>
</dd>
<dt><strong>wh_keep:</strong></dt>
<dd><p class="first last">a vector of 1/0 values to use as wh_keep</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="&#64;canlab_dataset.histogram">
<code class="descclassname">&#64;canlab_dataset.</code><code class="descname">histogram</code><span class="sig-paren">(</span><em>D</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@canlab_dataset.histogram" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Histogram of one variable in dataset</dt>
<dd><ul class="first last simple">
<li>can be either event-level or subject-level</li>
<li>event-level data is plotted as concatenated events across subject-level</li>
<li>both variables must be valid names (case-sensitive)</li>
</ul>
</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="n">histogram</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="s">&#39;Anxiety&#39;</span><span class="p">);</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Optional Input:</th><td class="field-body"><a href="#id1"><span class="problematic" id="id2">**</span></a>nofig&#8217;: suppress creation of new figure</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="&#64;canlab_dataset.mediation">
<code class="descclassname">&#64;canlab_dataset.</code><code class="descname">mediation</code><span class="sig-paren">(</span><em>D</em>, <em>xvarname</em>, <em>yvarname</em>, <em>mvarname</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@canlab_dataset.mediation" title="Permalink to this definition">¶</a></dt>
<dd><p>Run single or multilevel mediation analysis on a canlab_dataset object</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="p">[</span><span class="n">paths</span><span class="p">,</span> <span class="n">stats</span><span class="p">]</span> <span class="o">=</span> <span class="n">mediation</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="n">xvarname</span><span class="p">,</span> <span class="n">yvarname</span><span class="p">,</span> <span class="n">mvarname</span><span class="p">,</span> <span class="n">varargin</span><span class="p">)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Inputs:</th><td class="field-body"><dl class="first docutils">
<dt><strong>D:</strong></dt>
<dd><p class="first last">is a canlab_dataset object</p>
</dd>
<dt><strong>xvarname, mvarname, and yvarname:</strong></dt>
<dd><p class="first last">are valid variable names in the dataset.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Optional Inputs:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body"><p class="first">Takes any optional inputs to mediation.m
e.g., &#8216;noverbose&#8217;, &#8216;dosave&#8217;, &#8216;names&#8217;, &#8216;M&#8217;, &#8216;L2M&#8217;, &#8216;covs&#8217;, others</p>
<dl class="docutils">
<dt><strong>wh_keep:</strong></dt>
<dd><dl class="first last docutils">
<dt>followed by 1/0 vector of subjects to keep.</dt>
<dd><ul class="first last simple">
<li>must be same length as subjects</li>
<li>subjects with value 0 will be excluded</li>
</ul>
</dd>
</dl>
</dd>
<dt><strong>rankdata:</strong></dt>
<dd><p class="first last">ranks all data before mediation; &#8220;Nonparametric&#8221;</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Outputs:</th><td class="field-body"><dl class="first docutils">
<dt><strong>[paths, stats]:</strong></dt>
<dd><p class="first last">mediation output variable</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Examples:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="p">[</span><span class="n">paths</span><span class="p">,</span> <span class="n">stats</span><span class="p">]</span> <span class="o">=</span> <span class="n">mediation</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="s">&#39;Group&#39;</span><span class="p">,</span> <span class="s">&#39;DeltaDon&#39;</span><span class="p">,</span> <span class="s">&#39;DeltaDist&#39;</span><span class="p">,</span> <span class="s">&#39;M2&#39;</span><span class="p">,</span> <span class="s">&#39;DeltaTend&#39;</span><span class="p">,</span> <span class="s">&#39;wh_keep&#39;</span><span class="p">,</span> <span class="n">wh_keep</span><span class="p">);</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="&#64;canlab_dataset.plot_var">
<code class="descclassname">&#64;canlab_dataset.</code><code class="descname">plot_var</code><span class="sig-paren">(</span><em>D</em>, <em>varname</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@canlab_dataset.plot_var" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot the mean and standard error of a variable across events.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>plot_var(D, varname)

[meandat, stedat] = plot_var(D, varname, [opt inputs])
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Inputs:</th><td class="field-body"><dl class="first docutils">
<dt><strong>D:</strong></dt>
<dd><p class="first last">a canlab_dataset object</p>
</dd>
<dt><strong>varname:</strong></dt>
<dd><dl class="first last docutils">
<dt>the name of a valid variable to get from dataset</dt>
<dd><ul class="first last simple">
<li>Looks for var name at either level, returns Event level if exists at both levels</li>
</ul>
</dd>
</dl>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Optional inputs:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body"><dl class="first last docutils">
<dt><strong>subjtype:</strong></dt>
<dd><dl class="first last docutils">
<dt>followed by name of grouping variable</dt>
<dd><ul class="first last simple">
<li>must be categorical subject-level variable</li>
<li>if entered, plot lines or bars based on these categories</li>
<li>&#8216;eventmeans&#8217; will plot bars; without, it will plot line
plots across events with standard error shading</li>
<li>the grouping variable&#8217;s description, if it exists, will
be split along commas, and those values will be used as
column lables</li>
</ul>
</dd>
</dl>
</dd>
<dt><strong>eventmeans:</strong></dt>
<dd><dl class="first last docutils">
<dt>calculate and plot subject means across event-level variables</dt>
<dd><ul class="first last simple">
<li>if entered, will plot bar plots of means by condition</li>
</ul>
</dd>
</dl>
</dd>
<dt><strong>wh_keep:</strong></dt>
<dd><dl class="first last docutils">
<dt>followed by 1/0 vector of subjects to keep.</dt>
<dd><ul class="first last simple">
<li>must be same length as subjects</li>
<li>subjects with value 0 will be excluded</li>
</ul>
</dd>
</dl>
</dd>
<dt><strong>color:</strong></dt>
<dd><p class="first last">followed by one color for all bars, or cell array with names of colors cell for each line/bar</p>
</dd>
<dt><strong>nofig:</strong></dt>
<dd><p class="first last">don&#8217;t make a new figure</p>
</dd>
<dt><strong>other:</strong></dt>
<dd><p class="first last">other varargin are passed directly to barplot_columns.  So
for example, &#8216;95CI&#8217; will make 95% confidence interals, instead
of SE bars.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p>Examples:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">plot_var</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="s">&#39;Frustration&#39;</span><span class="p">)</span>
<span class="n">plot_var</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="s">&#39;RT&#39;</span><span class="p">)</span>
<span class="n">plot_var</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="s">&#39;RT&#39;</span><span class="p">,</span> <span class="s">&#39;eventmeans&#39;</span><span class="p">);</span>
<span class="n">plot_var</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="s">&#39;RT&#39;</span><span class="p">,</span> <span class="s">&#39;subjtype&#39;</span><span class="p">,</span> <span class="s">&#39;Placebo&#39;</span><span class="p">);</span>
<span class="n">plot_var</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="s">&#39;RT&#39;</span><span class="p">,</span> <span class="s">&#39;eventmeans&#39;</span><span class="p">,</span> <span class="s">&#39;subjtype&#39;</span><span class="p">,</span> <span class="s">&#39;Placebo&#39;</span><span class="p">);</span>
<span class="n">plot_var</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="s">&#39;RT&#39;</span><span class="p">,</span> <span class="s">&#39;eventmeans&#39;</span><span class="p">,</span> <span class="s">&#39;subjtype&#39;</span><span class="p">,</span> <span class="s">&#39;Placebo&#39;</span><span class="p">,</span> <span class="s">&#39;color&#39;</span><span class="p">,</span> <span class="p">{</span><span class="s">&#39;r&#39;</span> <span class="s">&#39;b&#39;</span><span class="p">});</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="&#64;canlab_dataset.print_summary">
<code class="descclassname">&#64;canlab_dataset.</code><code class="descname">print_summary</code><span class="sig-paren">(</span><em>D</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@canlab_dataset.print_summary" title="Permalink to this definition">¶</a></dt>
<dd><p>Prints summaries for every variable, or specified variables
:Usage:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">print_summary</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="n">varargin</span><span class="p">)</span> 
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Inputs:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>D:</strong></dt>
<dd><p class="first last">dataset</p>
</dd>
<dt><strong>subj:</strong></dt>
<dd><p class="first last">followed by a cell array of subject level var names, to only see those vars</p>
</dd>
<dt><strong>event:</strong></dt>
<dd><p class="first last">followed by a cell array of event level var names, to only see those vars</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p>if either varargin is unspecified, all variables will be printed</p>
</dd></dl>

<dl class="function">
<dt id="&#64;canlab_dataset.read_from_excel">
<code class="descclassname">&#64;canlab_dataset.</code><code class="descname">read_from_excel</code><span class="sig-paren">(</span><em>dat</em>, <em>ExperimentFileName</em>, <em>SubjectFileList</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@canlab_dataset.read_from_excel" title="Permalink to this definition">¶</a></dt>
<dd><p>Read from datafile into canlab_dataset format - currently requires file
extensions .xls or .xlsx, but in the future will use importdata to take
.csv or .txt extensions as well.</p>
<dl class="docutils">
<dt>Datafiles require column headers</dt>
<dd><ul class="first last">
<li><dl class="first docutils">
<dt>Design file requires: id, names, units, descrip</dt>
<dd><ul class="first last">
<li><p class="first">other columns can be added</p>
</li>
<li><dl class="first docutils">
<dt>ONLY between subject columns identified in the &#8216;names&#8217;</dt>
<dd><p class="first last">column are added.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>See Sample_canlab_dataset_experiment_level.xlsx for an</dt>
<dd><p class="first last">example design file</p>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>Subject files require no specific column headers, but all column</dt>
<dd><p class="first last">headers must be identical across all subjects.
- Enter NaN for data field in file if no value for that column within a specific Event
- ALL columns of subject files are written to canlab_dataset</p>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="n">dat</span> <span class="o">=</span> <span class="n">read_from_excel</span><span class="p">(</span><span class="n">dat</span><span class="p">,</span> <span class="n">ExperimentFileName</span><span class="p">,</span> <span class="n">SubjectFileList</span><span class="p">,</span> <span class="n">varargin</span><span class="p">)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Inputs:</th><td class="field-body"><dl class="first docutils">
<dt><strong>dat:</strong></dt>
<dd><p class="first last">a canlab_dataset object</p>
</dd>
<dt><strong>ExperimentFileName:</strong></dt>
<dd><p class="first last">the absolute path of the experiment data file</p>
</dd>
<dt><strong>SubjectFileList:</strong></dt>
<dd><dl class="first last docutils">
<dt>list of absolute paths for individual subject files</dt>
<dd><ul class="first last simple">
<li>plays well with filenames()</li>
</ul>
</dd>
</dl>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Optional inputs:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body"><dl class="first docutils">
<dt><strong>fmri:</strong></dt>
<dd><p class="first last">Indicates construction of canlab_dataset object using &#8216;fmri&#8217;
code. Suppresses overwrite warnings specific to &#8216;fmri&#8217; inputs.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Outputs:</th><td class="field-body"><dl class="first docutils">
<dt><strong>dat:</strong></dt>
<dd><p class="first last">canlab_dataset object with uploaded values</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Examples:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>% To output a file into a raw fmri dataset

DesignFile = fullfile(pwd,&#39;Sample_canlab_dataset_experiment_level.xlsx&#39;);
SubjectFiles = filenames(fullfile(pwd,&#39;Sample_canlab_dataset_subject*.xlsx&#39;));
dat = canlab_dataset(&#39;fmri&#39;);
dat = read_from_excel(dat,DesignFile,SubjectFiles,&#39;fmri&#39;);
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="&#64;canlab_dataset.scattermatrix">
<code class="descclassname">&#64;canlab_dataset.</code><code class="descname">scattermatrix</code><span class="sig-paren">(</span><em>D</em>, <em>wh_level</em>, <em>wh_vars</em><span class="sig-paren">)</span><a class="headerlink" href="#@canlab_dataset.scattermatrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Scatterplot matrix of pairwise event-level variables</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="n">fig_han</span> <span class="o">=</span> <span class="n">scattermatrix</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="n">wh_level</span><span class="p">,</span> <span class="n">wh_vars</span><span class="p">)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Inputs:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>wh_level:</strong></dt>
<dd><p class="first last">1 (Subject) or 2 (Event)</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p>Examples:</p>
<div class="highlight-python"><div class="highlight"><pre>fig_han = scattermatrix(D);

wh = [5:9];
fig_han = scattermatrix(D, 2, wh);

f = scattermatrix(D, 2, {&#39;Choice&#39; &#39;RT&#39; &#39;Pain&#39; &#39;SwitchNext&#39; &#39;Frustration&#39; &#39;Anxiety&#39; &#39;Control&#39;});
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="&#64;canlab_dataset.scatterplot">
<code class="descclassname">&#64;canlab_dataset.</code><code class="descname">scatterplot</code><span class="sig-paren">(</span><em>D</em>, <em>v1</em>, <em>v2</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@canlab_dataset.scatterplot" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Scatterplot of two variables in dataset</dt>
<dd><ul class="first last simple">
<li>can be either event-level or subject-level</li>
<li>event-level data is plotted as multi-line plot, one line per subject</li>
<li>both variables must be valid names (case-sensitive)</li>
</ul>
</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="n">fig_han</span> <span class="o">=</span> <span class="n">scatterplot</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="n">varname1</span><span class="p">,</span> <span class="n">varname2</span><span class="p">,</span> <span class="n">varargin</span><span class="p">)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name" colspan="2">Optional Inputs:</th></tr>
<tr class="field-odd field"><td>&nbsp;</td><td class="field-body"><blockquote class="first">
<div><dl class="docutils">
<dt><strong>nofig:</strong></dt>
<dd><p class="first last">suppress creation of new figure</p>
</dd>
<dt><strong>subjtype:</strong></dt>
<dd><p class="first last">group by the following variable name</p>
</dd>
<dt><strong>wh_keep:</strong></dt>
<dd><p class="first last">followed by logical</p>
</dd>
<dt><strong>colors:</strong></dt>
<dd><p class="first last">followed by colors.</p>
</dd>
<dt><strong>dorobust:</strong></dt>
<dd><p class="first last">do robust corr.  if enabled, colors will not work and subjtype grouping will not work well until</p>
</dd>
</dl>
</div></blockquote>
<p>the function plot_correlation_samefig is updated, at some point in the future.</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>scatterplot(D, &#39;Anxiety&#39;, &#39;Frustration&#39;);
fig_han = scatterplot(D, D.Subj_Level.names{1}, D.Subj_Level.names{2});
scatterplot(D, D.Event_Level.names{1}, D.Event_Level.names{2});
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="&#64;canlab_dataset.spm2canlab_dataset">
<code class="descclassname">&#64;canlab_dataset.</code><code class="descname">spm2canlab_dataset</code><span class="sig-paren">(</span><em>obj</em>, <em>subject</em>, <em>spm</em><span class="sig-paren">)</span><a class="headerlink" href="#@canlab_dataset.spm2canlab_dataset" title="Permalink to this definition">¶</a></dt>
<dd><p>Extract Event_Level data from subjects&#8217; SPM.mat files to add data to
canlab_dataset object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="n">D</span> <span class="o">=</span> <span class="n">spm2canlab_dataset</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="n">subjects</span><span class="p">,</span> <span class="n">spm</span><span class="p">)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Inputs:</th><td class="field-body"><dl class="first docutils">
<dt><strong>D:</strong></dt>
<dd><p class="first last">Canlab_dataset object (see canlab_dataset)</p>
</dd>
<dt><strong>subjects:</strong></dt>
<dd><p class="first last">Subject list (it could be one subject [in a string 
format], or it could be multiple subjects in cell array)</p>
</dd>
<dt><strong>spm:</strong></dt>
<dd><p class="first last">This could be loaded SPM (struct), or one path for one 
subject&#8217;s SPM.mat file (string), or multiple loaded SPM or
paths in cell array</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Outputs:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>D:</strong></dt>
<dd><p class="first last">Canlab_dataset object with new data</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p>fter running this, please check D.Subj_Level.data and
D.Event_level.data to see if there are NaNs. NaNs could be there when 
information cannot be extracted from the given SPM.mat files.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Examples:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>subj = {&#39;dpsp002&#39;,&#39;dpsp003&#39;};
spm = {&#39;dpsp002_SPM.mat&#39;, &#39;dpsp003_SPM.mat&#39;};

D = canlab_dataset; % if D doesn&#39;t exist yet
D = spm2canlab_dataset(D, subj, spm);
</pre></div>
</div>
<p>See also canlab_dataset, spm_mat2batchinput</p>
</dd></dl>

<dl class="function">
<dt id="&#64;canlab_dataset.ttest2">
<code class="descclassname">&#64;canlab_dataset.</code><code class="descname">ttest2</code><span class="sig-paren">(</span><em>D</em>, <em>varname</em>, <em>wh_keep1</em>, <em>wh_keep2</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@canlab_dataset.ttest2" title="Permalink to this definition">¶</a></dt>
<dd><p>Two sample ttest for two samples of one subject-level variable</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="n">ttest2</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="n">varname</span><span class="p">,</span> <span class="n">wh_keep1</span><span class="p">,</span> <span class="n">wh_keep2</span><span class="p">,</span> <span class="n">varargin</span><span class="p">)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Inputs:</th><td class="field-body"><dl class="first docutils">
<dt><strong>D:</strong></dt>
<dd><p class="first last">a canlab_dataset object</p>
</dd>
<dt><strong>varname:</strong></dt>
<dd><p class="first last">the name of a valid variable to get from dataset</p>
</dd>
<dt><strong>wh_keep1:</strong></dt>
<dd><p class="first last">subjects forming first sample</p>
</dd>
<dt><strong>wh_keep2:</strong></dt>
<dd><p class="first last">subjects forming second sample</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Optional Inputs:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body"><dl class="first docutils">
<dt><a href="#id3"><span class="problematic" id="id4">**</span></a>varargin:     passed directly to MATLAB&#8217;s ttest2</dt>
<dd><p class="first last">&#8216;noverbose&#8217; will suppress print out of results and bargraph</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Outputs:</th><td class="field-body"><p class="first last">as from MATLAB&#8217;s ttest2,</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="&#64;canlab_dataset.write_text">
<code class="descclassname">&#64;canlab_dataset.</code><code class="descname">write_text</code><span class="sig-paren">(</span><em>D</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@canlab_dataset.write_text" title="Permalink to this definition">¶</a></dt>
<dd><p>&#8220;Flatten&#8221; dataset and write text files with header and data
For all Event-level and Subject-level data.  Files are created in the
current working directory.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="n">function</span> <span class="p">[</span><span class="n">headername</span><span class="p">,</span> <span class="n">dataname</span><span class="p">,</span> <span class="n">fid</span><span class="p">]</span> <span class="o">=</span> <span class="n">write_text</span><span class="p">(</span><span class="n">D</span><span class="p">)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Inputs:</th><td class="field-body">First <a href="#id5"><span class="problematic" id="id6">**</span></a>varargin* parameter is the delimiter. Comma-delimited by default.</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-&#64;fmri_data">
<span id="fmri-data"></span><h1>fmri_data<a class="headerlink" href="#module-@fmri_data" title="Permalink to this headline">¶</a></h1>
<dl class="function">
<dt id="&#64;fmri_data.canlab_connectivity_preproc">
<code class="descclassname">&#64;fmri_data.</code><code class="descname">canlab_connectivity_preproc</code><span class="sig-paren">(</span><em>dat</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@fmri_data.canlab_connectivity_preproc" title="Permalink to this definition">¶</a></dt>
<dd><p>This function prepares data for connectivity analysis by removing nuisance
variables and temporal filtering (high, low, or bandpass filter). This also
can extract values from given masks and return averaged activity or pattern
expression values.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="p">[</span><span class="n">preprocessed_dat</span><span class="p">,</span> <span class="n">roi_val</span><span class="p">]</span> <span class="o">=</span> <span class="n">canlab_connectivity_preproc</span><span class="p">(</span><span class="n">dat</span><span class="p">,</span> <span class="n">varargin</span><span class="p">)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Features:</th><td class="field-body"><ul class="first last simple">
<li>can regress out nuisance variables with any additional nuisance matrix</li>
<li>can remove signal from ventricle and white matter (calls
canlab_extract_ventricle_wm_timeseries.m and canlab_create_wm_ventricle_masks.m)</li>
<li>can do temporal filtering, including high-pass, low-pass, or bandpass
filtering (it uses conn_filter.m from conn toolbox; see subfunction below)</li>
<li>can extract data from given ROIs, and return averaged value or pattern
expression value (dot-product).</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt><em>Steps in order [with defaults]:</em></dt>
<dd><ol class="first last arabic simple">
<li>Remove nuisance covariates (and linear trend if requested)</li>
<li>Remove ventricle and white matter - needs structural images</li>
<li>Windsorize based on distribution of full data matrix</li>
<li>High/low/bandpass filter</li>
<li>Extract region-by-region average ROI or pattern expression data</li>
</ol>
</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Inputs:</th><td class="field-body"><dl class="first docutils">
<dt><strong>dat:</strong></dt>
<dd><p class="first last">fmri_data object with data</p>
</dd>
<dt><strong>dat.covariate:</strong></dt>
<dd><p class="first last">basic nuisance matrix</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Optional Inputs:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body"><dl class="first docutils">
<dt><strong>additional_nuisance</strong></dt>
<dd><p class="first last">When you have additional nuisance variables that you want
regress out from the data, you can use this option. This
option should be followed by a nuisance matrix (or values).
The matrix should have the same number of rows with the
number of images.</p>
</dd>
<dt><strong>vw</strong></dt>
<dd><p class="first">When you want to regress out signals from ventricle and
white matter, you can use this option. To use this option,
You should provide the directory where the subjects&#8217; data
are saved using the &#8216;datdir&#8217; (for example, see below).
Requires specific subdirectory structure (CANlab) - see code.</p>
<p class="last">You can also choose what to use to remove ventricle and
white matter signal between raw data or top 5 PCA
components (default). You can just put &#8216;raw&#8217; if you want to
use raw signal than PCA compoenents.
also see: canlab_extract_ventricle_wm_timeseries.m
canlab_create_wm_ventricle_masks.m)
- <em>Example:</em> &#8216;vw&#8217;, &#8216;datdir&#8217;, subject_dir, &#8216;raw&#8217;</p>
</dd>
<dt><strong>windsorize:</strong></dt>
<dd><p class="first last">Windsorizing entire data matrix to k x STD.
- <em>Example:</em> &#8216;windsorize&#8217;, 5 (windsorize to 5 STD)</p>
</dd>
<dt><strong>linear_trend:</strong></dt>
<dd><p class="first last">This option will include the linear trend to nuisance variables.</p>
</dd>
<dt><strong>hpf&#8217;, &#8216;lpf&#8217;, or &#8216;bpf:</strong></dt>
<dd><p class="first">This option will do temporal filtering.
- &#8216;hpf&#8217;: high pass filter. This option should be followed by</p>
<blockquote>
<div><p>the lower bound of the frequency (e.g., .01 Hz [= 100 sec]).</p>
</div></blockquote>
<ul class="last">
<li><dl class="first docutils">
<dt>&#8216;lpf&#8217;: low pass filter. This option should be followed by</dt>
<dd><p class="first last">the upper bound of the frequency (e.g., .25 Hz [= 4 sec]).</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>&#8216;bpf&#8217;: bandpass filter. This should be followed by lower</dt>
<dd><p class="first last">and upper bounds of the frequency (e.g., [.01 .25]).
After the frequency value, you need to provide TR.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><em>Example:</em> &#8216;hpf&#8217;, .01, TR</dt>
<dd><p class="first last">&#8216;bpf&#8217;, [.01 .25], TR</p>
</dd>
</dl>
</li>
</ul>
</dd>
<dt><strong>extract_roi:</strong></dt>
<dd><p class="first">This option will extract data from ROIs specified. This
option should be followed by one or more masks.
For one mask (potentially multiple ROIs, enter a char array with the mask name.
For multiple masks (1 or more), enter in a cell array of mask names.
You can specify methods with &#8216;roi_methods&#8217; option.
- &#8216;average_over&#8217; (default): calculate averaged value across the ROIs.
- &#8216;pattern_expression&#8217;: calculate dot-products between</p>
<blockquote>
<div><p>pattern mask and data</p>
</div></blockquote>
<ul class="last">
<li><dl class="first docutils">
<dt>&#8216;unique_mask_values&#8217; (default): will divide a mask into</dt>
<dd><p class="first last">multiple regions that have different discrete values.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>&#8216;contiguous_regions&#8217;: will divide a mask into multiple</dt>
<dd><p class="first last">contiguous regions.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>&#8216;whole&#8217;: will do average_over or pattern_expression across</dt>
<dd><p class="first last">all the voxels within the mask.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><em>Example:</em> &#8216;extract_roi&#8217;, mask, &#8216;contiguous_regions&#8217;</dt>
<dd><p class="first last">&#8216;extract_roi&#8217;, mask, &#8216;pattern_expression&#8217;</p>
</dd>
</dl>
</li>
</ul>
</dd>
<dt><strong>no_preproc:</strong></dt>
<dd><p class="first last">If you want to skip the preprocessing part, and want to
extract ROI values only, you can use this option.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Outputs:</th><td class="field-body"><dl class="first docutils">
<dt><strong>preprocessed_dat:</strong></dt>
<dd><p class="first last">fmri_data object after removing nuisance variables and
filtering temporal confounds.</p>
</dd>
<dt><strong>roi_val:</strong></dt>
<dd><p class="first last">returns values extracted from ROIs in cell arrays (if there are many different ROIs).
Each cell will have roi_val.dat, roi_val.mask_name, and roi_val.methods.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Examples:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>roi_masks = which(&#39;weights_NSF_grouppred_cvpcr.img&#39;);
[preprocessed_dat, roi_val] = canlab_connectivity_preproc(dat, &#39;vw&#39;, &#39;datdir&#39;,
       subject_dir, &#39;bpf&#39;, [.008 .25], TR, &#39;extract_roi&#39;, roi_masks, &#39;pattern_expression&#39;);
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="&#64;fmri_data.create">
<code class="descclassname">&#64;fmri_data.</code><code class="descname">create</code><span class="sig-paren">(</span><em>obj</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@fmri_data.create" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an object from an empty obj structure, assigning fieldname/value
pairs as optional arguments.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>[obj = create(obj, varargin)
</pre></div>
</div>
<p>Used in fmri_data.m class constructor.
if &#8216;noverbose&#8217; is entered, suppress output</p>
</dd></dl>

<dl class="function">
<dt id="&#64;fmri_data.extract_roi_averages">
<code class="descclassname">&#64;fmri_data.</code><code class="descname">extract_roi_averages</code><span class="sig-paren">(</span><em>obj</em>, <em>mask_image</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@fmri_data.extract_roi_averages" title="Permalink to this definition">¶</a></dt>
<dd><p>This fmri_data method a extracts and averages data stored in an fmri_data object 
from a set of ROIs defined in a mask.</p>
<p>If no mask_image is entered, it uses the mask defined with the fmri_data object as a default.</p>
<dl class="docutils">
<dt>If mask_image is a new image file name, this method:</dt>
<dd><ol class="first last arabic simple">
<li>Defines an fmri_mask_image object using create_fmri_mask</li>
<li>Maps to the space in fmri_data object using resample_to_image_space</li>
</ol>
</dd>
</dl>
<p>Regions to average over can be either regions of contiguous voxels
bounded by voxels with values of 0 or NaN, which are considered non-data
values, or regions defined by unique integer codes in the mask image
(i.e., for atlas images with unique codes for each defined region.)</p>
<p>Mask/Atlas image does NOT have to be in the same space as the images to
extract from.  It will be remapped/resliced.
NOTE: Mask is <em>reloaded</em> from original data if space is remapped, and you
cannot use manual thresholding of the mask. This is a feature of the
map_to_image_space method and scn_map_image</p>
<p>Extracted data is returned in single data format.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>[[cl, clroimean, clpattern] = extract_roi_averages(fmri_data obj, [mask_image], [average_over])
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Inputs:</th><td class="field-body"><ol class="first arabic simple">
<li>char array of strings containing 4D image file names (data extracted from these)</li>
<li>mask_image to extract from.</li>
</ol>
</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Optional inputs:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body"><dl class="first docutils">
<dt><strong>how to average</strong></dt>
<dd><p class="first last">Default = &#8216;unique_mask_values&#8217; to average over unique integer codes in the mask image
bounded by voxels of 0 or NaN (non-data values)
(i.e., for atlas images with unique codes for each defined region)
Alt. option = &#8216;contiguous_regions&#8217; to average over contiguous voxels</p>
</dd>
<dt><strong>pattern_expression</strong></dt>
<dd><p class="first">Use values in mask images to get weighted average within each
region, rather than simple average.  See also apply_mask with
&#8216;pattern_expression&#8217; option.</p>
<p class="last">Optional outputs (varargout): 
[cl, cl_roimean, cl_roipattern] = ...
roimean: pattern expression is average over ROI (unit vector)
roipattern: pattern expression is dot product of activity and mean-centered pattern weights</p>
</dd>
<dt><strong>nonorm</strong></dt>
<dd><p class="first last">Turn off L1 norm in pattern expression.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Examples:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="n">imgs_to_extract_from</span> <span class="o">=</span> <span class="n">filenames</span><span class="p">(</span><span class="s">&#39;w*.nii&#39;</span><span class="p">,</span><span class="s">&#39;char&#39;</span><span class="p">);</span>
<span class="n">mask_image</span> <span class="o">=</span> <span class="n">which</span><span class="p">(</span><span class="s">&#39;anat_lbpa_thal.img&#39;</span><span class="p">);</span>
<span class="p">[</span><span class="n">cl</span><span class="p">,</span> <span class="n">clroimean</span><span class="p">,</span> <span class="n">clpattern</span><span class="p">]</span> <span class="o">=</span> <span class="n">extract_image_data</span><span class="p">(</span><span class="n">imgs_to_extract_from</span><span class="p">,</span> <span class="n">mask_image</span><span class="p">);</span>

<span class="n">region_obj</span> <span class="o">=</span> <span class="n">extract_roi_averages</span><span class="p">(</span><span class="n">data_obj</span><span class="p">,</span> <span class="n">mask_char_name</span><span class="p">,</span> <span class="s">&#39;pattern_expression&#39;</span><span class="p">,</span> <span class="s">&#39;contiguous_regions&#39;</span><span class="p">);</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name" colspan="2">Related functions:</th></tr>
<tr class="field-odd field"><td>&nbsp;</td><td class="field-body">For an non-object-oriented alternative, see extract_image_data.m</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="&#64;fmri_data.horzcat">
<code class="descclassname">&#64;fmri_data.</code><code class="descname">horzcat</code><span class="sig-paren">(</span><em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@fmri_data.horzcat" title="Permalink to this definition">¶</a></dt>
<dd><p>Implements the horzcat ([a b]) operator on image_vector objects across voxels.
Requires that each object has an equal number of columns and voxels</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>function s = horzcat(varargin)
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>c = [dat1 dat2];
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="&#64;fmri_data.hrf_fit">
<code class="descclassname">&#64;fmri_data.</code><code class="descname">hrf_fit</code><span class="sig-paren">(</span><em>obj</em>, <em>TR</em>, <em>Runc</em>, <em>T</em>, <em>method</em>, <em>mode</em><span class="sig-paren">)</span><a class="headerlink" href="#@fmri_data.hrf_fit" title="Permalink to this definition">¶</a></dt>
<dd><p>HRF estimation on fmri_data class object</p>
<p>HRF estimation function for a single voxel;</p>
<p>Implemented methods include: IL-model (Deterministic/Stochastic), FIR
(Regular/Smooth), and HRF (Canonical/+ temporal/+ temporal &amp; dispersion)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Inputs:</th><td class="field-body"><dl class="first docutils">
<dt><strong>obj</strong></dt>
<dd><p class="first last">fMRI object</p>
</dd>
<dt><strong>TR</strong></dt>
<dd><p class="first last">time resolution</p>
</dd>
<dt><strong>Runs</strong></dt>
<dd><p class="first last">expermental design</p>
</dd>
<dt><strong>T</strong></dt>
<dd><p class="first last">length of estimated HRF ij seconds</p>
</dd>
<dt><strong>type</strong></dt>
<dd><p class="first last">Model type: &#8216;FIR&#8217;, &#8216;IL&#8217;, or &#8216;CHRF&#8217;</p>
</dd>
<dt><strong>mode</strong></dt>
<dd><p class="first last">Mode</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Model Types:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<ol class="upperalpha">
<li><dl class="first docutils">
<dt><strong>Fit HRF using IL-function</strong></dt>
<dd><dl class="first docutils">
<dt>Choose mode (deterministic/stochastic)</dt>
<dd><ul class="first last simple">
<li>0 - deterministic aproach</li>
<li>1 - simulated annealing approach</li>
</ul>
</dd>
</dl>
<p class="last">Please note that when using simulated annealing approach you
may need to perform some tuning before use.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><strong>Fit HRF using FIR-model</strong></dt>
<dd><dl class="first last docutils">
<dt>Choose mode (FIR/sFIR)</dt>
<dd><ul class="first last simple">
<li>0 - FIR</li>
<li>1 - smooth FIR</li>
</ul>
</dd>
</dl>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><strong>Fit HRF using FIR-model</strong></dt>
<dd><dl class="first last docutils">
<dt>Choose mode (FIR/sFIR)</dt>
<dd><ul class="first last simple">
<li>0 - FIR</li>
<li>1 - smooth FIR</li>
</ul>
</dd>
</dl>
</dd>
</dl>
</li>
</ol>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Examples:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<p>SIMULATE DATA AND RUN</p>
<div class="highlight-python"><div class="highlight"><pre>%params for sim and fitting
TR = 2;   % repetition time (sec)
n = 200;  % time points measured (for simulation) must be multiple of 10
T = 30;   % duration of HRF to estimate (seconds)
nconds = 2; % num conditions
nevents = 8; % events per condition

% Create fake data
h = spm_hrf(TR);
y = zeros(n, 1);

% onsets - indicator
Condition = {};
for i = 1:nconds
    Condition{i} = zeros(n,1);
    wh = randperm(n);
    Condition{i}(wh(1:nevents)) = 1;

    ytmp{i} =  conv(Condition{i}, h);
    ytmp{i} = ytmp{i}(1:n);
end

y = sum(cat(2, ytmp{:}), 2);

dat = fmri_data(&#39;VMPFC_mask_neurosynth.img&#39;);  % AVAILABLE ON WIKI IN MASK GALLERY
dat = threshold(dat, [5 Inf], &#39;raw-between&#39;);

v = size(dat.dat, 1); % voxels in mask
dat.dat = repmat(y&#39;,v, 1) + .1 * randn(v, n);

% Fit data - estimate HRFs across the brain mask
[params_obj hrf_obj] = hrf_fit(dat,TR, Condition, T,&#39;FIR&#39;, 1);

hrf = fmri_data(&#39;HRF_timecourse_cond0001.img&#39;);
hrf = remove_empty(hrf);
create_figure(&#39;hrfs&#39;, 1, 2); 
plot(hrf.dat&#39;);
title(&#39;Condition 1&#39;)
hrf = fmri_data(&#39;HRF_timecourse_cond0002.img&#39;);
hrf = remove_empty(hrf);
subplot(1, 2, 2);
plot(hrf.dat&#39;);
title(&#39;Condition 2&#39;)
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="&#64;fmri_data.plot">
<code class="descclassname">&#64;fmri_data.</code><code class="descname">plot</code><span class="sig-paren">(</span><em>fmridat</em>, <em>plotmethod</em><span class="sig-paren">)</span><a class="headerlink" href="#@fmri_data.plot" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot means by condition
plot(fmri_data_object, &#8216;means_for_unique_Y&#8217;)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Inputs:</th><td class="field-body"><dl class="first docutils">
<dt>Plot methods:</dt>
<dd><ul class="first last simple">
<li>plot data matrix</li>
<li>plot(fmri_data_object)</li>
</ul>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="n">plot</span><span class="p">(</span><span class="n">fmridat</span><span class="p">,</span> <span class="p">[</span><span class="n">plotmethod</span><span class="p">])</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Outputs:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<p>5 plots and an SPM orthviews presentation of the data.  In the below 
and elsewhere, &#8220;image&#8221; connotes a 3D brain volume captured every TR.</p>
<blockquote>
<div><dl class="docutils">
<dt><strong>subplot 1:</strong></dt>
<dd>the fMRI data itself. Color is intensity of signal.</dd>
<dt><strong>subplot 2:</strong></dt>
<dd>presented as a histogram of values for every voxel collected.
The low values are typically out-of-brain voxels, as there is
no signal there.</dd>
<dt><strong>subplot 3:</strong></dt>
<dd>each point is an image.  The point&#8217;s X value is the mean
intensity of every voxel in that image, and the Y value is the
stdev of intensities for all voxels in that image.</dd>
<dt><strong>subplot 4:</strong></dt>
<dd>covariance between images</dd>
<dt><strong>subplot 5:</strong></dt>
<dd>each point is an image (case = image).  X value is image
number in the run, Y is image mean intensity, and the size of
the circular marker represents stdev for that image</dd>
<dt><strong>Orthviews:</strong></dt>
<dd>mean and STD for a given voxel averaged over time.  Note that
the values for mean and STD here are higher than in the plots
above. That is because mean and STD are calculated here by
voxel, but in the plots above they are calculated by image.
Images also include out-of-brain areas.</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="&#64;fmri_data.predict">
<code class="descclassname">&#64;fmri_data.</code><code class="descname">predict</code><span class="sig-paren">(</span><em>obj</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@fmri_data.predict" title="Permalink to this definition">¶</a></dt>
<dd><p>Predict outcome (Y) from brain data and test cross-validated error rate for an fmri_data object</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="p">[</span><span class="n">cverr</span><span class="p">,</span> <span class="n">stats</span><span class="p">,</span> <span class="n">optional_outputs</span><span class="p">]</span> <span class="o">=</span> <span class="n">predict</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">varargin</span><span class="p">)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Features:</th><td class="field-body"><ul class="first simple">
<li>flexible specification of algorithm by function name</li>
<li>k-fold cross-validation, default = 5-fold, can enter custom fold membership</li>
<li>folds are stratified on outcome</li>
<li>choice of multiple error metrics (class loss, mse, etc.)</li>
<li>by default, chooses error metric based on outcome type (classes vs. continuous-valued)</li>
<li>returns all outputs for each fold returned by the algorithm in optout cell array variable</li>
<li>bootstrapping of weights built in [optional keyword]</li>
<li>select variable number of components (for pcr-based techniques)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Inputs:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>obj is mandatory, rest are optional</dt>
<dd><dl class="first last docutils">
<dt><strong>obj:</strong></dt>
<dd>fmri_data or image_vector object, with fields .dat (data used to predict) and .Y (outcome)</dd>
</dl>
</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name" colspan="2">Optional inputs:</th></tr>
<tr class="field-odd field"><td>&nbsp;</td><td class="field-body"><p class="first">(with their default values)</p>
<dl class="docutils">
<dt><strong>nfolds</strong> = 5</dt>
<dd><p class="first last">number of folds</p>
</dd>
<dt><strong>nfolds</strong> = [vector of integers]</dt>
<dd><p class="first last">can also input vector of integers for holdout set IDs</p>
</dd>
<dt><strong>error_type</strong> = mcr</dt>
<dd><p class="first last">mcr, mse: misclassification rate or mean sq. error</p>
</dd>
<dt><strong>algorithm_name</strong> = &#8216;cv_regress&#8217;</dt>
<dd><p class="first last">name of m-file defining training/test function</p>
</dd>
<dt><strong>useparallel</strong> = 1</dt>
<dd><p class="first last">Use parallel processing, if available; follow by 1 for yes, 0 for no</p>
</dd>
<dt><strong>bootweights</strong> = 0</dt>
<dd><p class="first last">bootstrap voxel weights; enter bootweights do bootstrapping of weight maps (based on all observations)</p>
</dd>
<dt><strong>savebootweights</strong></dt>
<dd><p class="first last">save bootstraped weights (useful for combining across multiple iterations of predict())</p>
</dd>
<dt><strong>bootsamples</strong> = 100</dt>
<dd><p class="first last">number of bootstrap samples to use</p>
</dd>
<dt><strong>numcomponents</strong> = xxx:</dt>
<dd><p class="first last">save first xxx components (for pca-based methods)</p>
</dd>
<dt><strong>nopcr</strong></dt>
<dd><p class="first last">for cv_lassopcr and cv_lassopcrmatlab: do not do pcr, use original variables</p>
</dd>
<dt><strong>lasso_num</strong> = xxx</dt>
<dd><p class="first last">followed by number of components/vars to retain after shrinkage</p>
</dd>
<dt><strong>hvblock</strong> = [h,v]</dt>
<dd><p class="first last">use hvblock cross-validation with a block size of &#8216;h&#8217; (0 reduces to v-fold xval) and
number of test observations &#8216;v&#8217; (0 reduces to h-block xval)</p>
</dd>
<dt><strong>rolling</strong> = [h,v,g]</dt>
<dd><p class="first last">use rolling cross-validation with a block size of &#8216;h&#8217; (0 reduces to v-fold xval) and
number of test observations &#8216;v&#8217; (0 reduces to h-block xval), and a training size
of g * 2 surrounding hv</p>
</dd>
<dt><strong>verbose</strong> = 1</dt>
<dd><p class="first last">Set to 0 to suppress output to command window</p>
</dd>
<dt><strong>platt_scaling</strong></dt>
<dd><p class="first last">calculate cross-validated platt scaling if using SVM.
Softmax parameters [A,B] are in other_output{3}</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Algorithm choices:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body"><p class="first">You can input the name (as a string array) of any algorithm with the
appropriate inputs and outputs. i.e., this can either be one of the
built-in choices below, or the name of another m-file.
The format for algorithm functions is :
[yfit, other_outputs] = predfun(xtrain, ytrain, xtest, optional_inputs)
Each algorithm can take/interpret its own optional inputs.
For bootstrapping of weights, algorithms MUST RETURN 3 OUTPUTS
(programming &#8216;feature&#8217;)</p>
<p>To choose an algorithm, enter &#8216;algorithm_name&#8217; followed by a text string
with a built-in algorithm name, or a function handle for a custom algorithm
Built-in algorithm choices include:</p>
<dl class="docutils">
<dt><strong>cv_multregress:</strong></dt>
<dd><p class="first last">[default] multiple regression</p>
</dd>
<dt><strong>cv_univregress:</strong></dt>
<dd><p class="first last">Average predictions from separate univariate regression of outcome on each feature</p>
</dd>
<dt><strong>cv_svr:</strong></dt>
<dd><p class="first last">Support vector regression with Spider package; requires spider</p>
</dd>
<dt><strong>cv_pcr:</strong></dt>
<dd><p class="first last">Cross-validated principal components regression</p>
</dd>
<dt><strong>cv_lassopcr:</strong></dt>
<dd><p class="first last">Cross-val LASSO-PCR; can enter &#8216;lasso_num&#8217; followed by components to retain by shrinkage
NOTE: can enter &#8216;EstimateParams&#8217; to use shrankage
lasso method based on the estimated optimal lambda
that minimizes the mean squared error (MSE) of nested
cross-validation models. Output of nested cv model is
saved in stats.other_output_cv{:,3}. Output includes
&#8216;Lambda&#8217; parameter and min MSE value.</p>
</dd>
<dt><strong>cv_lassopcrmatlab:</strong></dt>
<dd><p class="first last">Cross-val LASSO-PCR; can enter &#8216;lasso_num&#8217; followed by components to retain by shrinkage
NOTE: this uses the matlab implementation of LASSO,
but can also run ridge or elastic net. Reduces to PCR
when no lasso_num is entered by default.  Use MSE for
predicting continuous data and MCR for classifying
binary data.
NOTE: You can input any optional inputs that lassoglm
takes.
Enter &#8216;Alpha&#8217;, (0,1] as optional inputs to
run ridge (Alpha approaches 0, but excluding 0), lasso (Alpha = 1), or elastic
net (Alpha between 0 and 1)
NOTE: Requires Matlab R2012a and higher.
NOTE: Optional input: &#8216;EstimateParams&#8217; - this will
use grid search and nested cross validation to
estimate Lambda and Alpha.  Output is saved in
stats.other_output_cv{:,3}.  Output includes &#8216;Alpha&#8217;
parameter which is the elastic net mixture value
between l1 and l2 regularization, &#8216;Lambda&#8217; parameter,
which is amount of LASSO regularization/shrinkage, and
&#8216;errorMatrix&#8217;, which is the amount of error for each
parameter combination.  Use
imagesc(obj.stats_other_output_cv{:,3}.errorMatrix)
to view matrix.  Min of this matrix is the best
fitting parameters.</p>
</dd>
<dt><strong>cv_svm:</strong></dt>
<dd><p class="first last">Cross-val support vector machine using Spider package
NOTE: This is sensitive to scale of outputs! Use -1 , 1
NOTE: Optional inputs: Slack var parameter: &#8216;C&#8217;, 1 [default], &#8216;C&#8217;, 3 etc.
Distance from hyperplane saved in
stats.other_output_cv{:,2}.  Recommend using the reordered
cross-validated distance from hyperplane saved in stats.other_output{3}
stats.dist_from_hyperplane_xval =  cross-validated distance from hyperplane
stats.weight_obj = voxel (variable) weight object
e.g., orthviews(stats.weight_obj)
Intercept for calculating dist from hy is in stats.other_output_cv{:,3}
e.g., dist_hy = stats.weight_obj.dat&#8217; * obj.dat, where obj is a new set of test images
NOTE: To run nonlinear SVM using radial basis
function.  Add &#8216;rbf&#8217; followed by size of sigma (e.g., 2).
NOTE: To estimate some of the parameters using
nested cross validation add &#8216;EstimateParams&#8217; as optional input.
NOTE: To run multiclass SVM (i.e., one vs rest) add
&#8216;MultiClass&#8217; as optional input.  Important - Obj.Y must be a matrix (data x
class) with a column of 1 and -1 indicating each
class.  For example, if using 3 classes, then obj.Y
must have 3 columns.
NOTE: To run a balanced SVM where the number of cases for each class are unequal (i.e., one vs rest) add
&#8216;Balanced&#8217; as optional input, followed by a numerical value indicating the ridge amount (e.g., 0.01).</p>
</dd>
<dt><strong>cv_multilevel_glm:</strong></dt>
<dd><p class="first last">Runs glmfit_multilevel. Must pass in &#8216;&#8217;subjIDs&#8217;&#8217; followed by an array specifying which subject each trial belongs to
Subjects&#8217; trials must all be &#8220;adjacent&#8221;, i.e., don&#8217;t
put some of subject 1&#8217;s trials at the beginning and
other trials at the end &#8211; subjIDs does not handle
this case correctly. Also, 2ND LEVEL PREDICTORS NOT
CURRENTLY SUPPORTED.  code can be expanded to support this.
mean-centering X and/or Y will NOT impact the
predictor betas.  Note that it WILL impact the intercept
esimate as well as how much variance is explained
(pred_outcome_r).  Stratified CV partition not
supported either, pass in custom holdout set.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Outputs:</th><td class="field-body"><dl class="first docutils">
<dt><strong>Y:</strong></dt>
<dd><p class="first last">Copy of outcome data to be predicted</p>
</dd>
<dt><strong>algorithm_name:</strong></dt>
<dd><p class="first last">Name of algorithm; see options above</p>
</dd>
<dt><strong>function_call:</strong></dt>
<dd><p class="first last">String of the command evaluated to call the prediction function</p>
</dd>
<dt><strong>function_handle:</strong></dt>
<dd><p class="first last">Handle for the command evaluated to call the prediction function</p>
</dd>
<dt><strong>yfit:</strong></dt>
<dd><p class="first last">Predicted outcome data (cross-validated)</p>
</dd>
<dt><strong>err:</strong></dt>
<dd><p class="first last">Residuals/misclassification vector (cross-validated)</p>
</dd>
<dt><strong>error_type:</strong></dt>
<dd><p class="first last">Name of error metric used for cverr</p>
</dd>
<dt><strong>cverr:</strong></dt>
<dd><p class="first last">Cross-validated error</p>
</dd>
<dt><strong>nfolds:</strong></dt>
<dd><p class="first">Number of folds in stratified cross-validation, or
vector of integers for membership in custom holdout set of each fold</p>
<blockquote class="last">
<div><ul class="simple">
<li>if k = 1, will estimate weights for full data object
and not crossvalidate (useful for bootstrapping)</li>
</ul>
</div></blockquote>
</dd>
<dt><strong>cvpartition:</strong></dt>
<dd><p class="first last">Cross-val partition object or structure with fold info</p>
</dd>
<dt><strong>teIdx:</strong></dt>
<dd><p class="first last">Cell array of logical vectors with test samples in each fold</p>
</dd>
<dt><strong>trIdx:</strong></dt>
<dd><p class="first last">Cell array of logical vectors with training samples in each fold</p>
</dd>
<dt><strong>other_output:</strong></dt>
<dd><p class="first last">Other outputs returned by the algorithm; number and nature depend on algo choice; e.g., beta weights, svr weights, etc.
For many algorithms, other_output{1} is a vector of
weights on variables (e.g., voxels)</p>
</dd>
<dt><strong>other_output_descrip:</strong></dt>
<dd><p class="first last">String description of other outputs</p>
</dd>
<dt><strong>other_output_cv:</strong></dt>
<dd><p class="first last">Other outputs for each cross-validation fold</p>
</dd>
<dt><strong>other_output_cv_descrip:</strong></dt>
<dd><p class="first last">Other output from algorithm - for each CV fold</p>
</dd>
<dt><strong>mse:</strong></dt>
<dd><p class="first last">For regression only; mean squared error</p>
</dd>
<dt><strong>rmse:</strong></dt>
<dd><p class="first last">For regression only; root mean squared error</p>
</dd>
<dt><strong>meanabserr:</strong></dt>
<dd><p class="first last">For regression only; mean absolute error</p>
</dd>
<dt><strong>pred_outcome_r:</strong></dt>
<dd><p class="first last">For regression only; prediction-outcome correlation</p>
</dd>
<dt><strong>WTS:</strong></dt>
<dd><p class="first last">bootstrapped weights on voxels</p>
</dd>
<dt><strong>weight_obj:</strong></dt>
<dd><p class="first last">for some algorithms, an fmri_data object with the predictive weights (from full sample)</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Examples:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>obj = fmri_data;
obj.dat = randn(30, 50); %    30 voxels, 50 images (observations)
obj.Y = obj.dat&#39; * rand(30, 1) + randn(50, 1); %    toy Y, linear combo of X plus noise
[cverr, stats, regression_outputs] = predict(obj);

Simulated example with 100 observations, 1000 voxels, with bootstrapping
dat = fmri_data;
dat.Y = rand(100, 1);
dat.dat = repmat(dat.Y&#39;, 1000, 1) + 10*rand(1000, 100);
[err,stats] = predict(dat, &#39;bootweights&#39;, &#39;algorithm_name&#39;, &#39;cv_lassopcr&#39;);

[cverr, stats, regression_outputs] = predict(obj, &#39;nfolds&#39;, 3, &#39;error_type&#39;, &#39;meanabserr&#39;);
[cverr, stats, regression_outputs] = predict(obj, &#39;algorithm_name&#39;, &#39;cv_univregress&#39;, &#39;error_type&#39;, &#39;meanabserr&#39;);
[cverr, stats, optout] = predict(obj, &#39;algorithm_name&#39;, &#39;cv_lassopcr&#39;, &#39;lasso_num&#39;, 5, &#39;nfolds&#39;, 5, &#39;error_type&#39;, &#39;mse&#39;, &#39;bootweights&#39;);
[cverr, stats, optout] = predict(dat, &#39;algorithm_name&#39;, &#39;cv_svm&#39;, &#39;nfolds&#39;, 5, &#39;error_type&#39;, &#39;mse&#39;);
[cverr, stats, optout] = predict(dat, &#39;algorithm_name&#39;, &#39;cv_svm&#39;, &#39;rbf&#39;, 2, &#39;nfolds&#39;, 5, &#39;error_type&#39;, &#39;mse&#39;); %SVM w/ radial basis function
[cverr, stats, optout] = predict(dat, &#39;algorithm_name&#39;, &#39;cv_svm&#39;, &#39;rbf&#39;, 2, &#39;EstimateParams&#39;, &#39;nfolds&#39;, 5, &#39;error_type&#39;, &#39;mse&#39;); %SVM w/ radial basis function w/ parameters estimated using nested cross-valdiation
[cverr, stats, optout] = predict(dat, &#39;algorithm_name&#39;, &#39;cv_svm&#39;, &#39;nfolds&#39;, 5, &#39;MultiClass&#39;, &#39;error_type&#39;, &#39;mse&#39;);

Elastic net with first 10 components:
[cverr, stats, optout] = predict(dat_masked, &#39;algorithm_name&#39;, &#39;cv_lassopcrmatlab&#39;, &#39;nfolds&#39;, 5, &#39;error_type&#39;, &#39;mse&#39;, &#39;numcomponents&#39;, 10, &#39;Alpha&#39;, .5); stats.pred_outcome_r

Ridge with first 10 components:
[cverr, stats, optout] = predict(dat_masked, &#39;algorithm_name&#39;, &#39;cv_lassopcrmatlab&#39;, &#39;nfolds&#39;, 5, &#39;error_type&#39;, &#39;mse&#39;, &#39;numcomponents&#39;, 10, &#39;Alpha&#39;, 0.00001); stats.pred_outcome_r

Lasso with all components, but shrink to retain 2 components only:
[cverr, stats, optout] = predict(dat, &#39;algorithm_name&#39;, &#39;cv_lassopcrmatlab&#39;, &#39;nfolds&#39;, whfolds, &#39;nopcr&#39;, &#39;lasso_num&#39;, 2, &#39;Alpha&#39;, 1);
[cverr, stats, optout] = predict(dat, &#39;algorithm_name&#39;, &#39;cv_lassopcr&#39;, &#39;nfolds&#39;, whfolds, &#39;lasso_num&#39;, 2);

Lasso with the shrinkage methods based on the estimated optimal lambda that minimizes MSE of nested cross-validation models.
[cverr, stats, optout] = predict(dat, &#39;algorithm_name&#39;, &#39;cv_lassopcr&#39;, &#39;nfolds&#39;, whfolds, &#39;estimateparam&#39;);
[cverr, stats, optout] = predict(dat, &#39;algorithm_name&#39;, &#39;cv_lassopcr&#39;, &#39;nfolds&#39;, 5, &#39;estimateparam&#39;);

Lasso without doing PCR:
[cverr, stats, optout] = predict(dat, &#39;algorithm_name&#39;, &#39;cv_lassopcrmatlab&#39;, &#39;nfolds&#39;, whfolds, &#39;nopcr&#39;, &#39;lasso_num&#39;, 2, &#39;Alpha&#39;, 1);
[cverr, stats, optout] = predict(dat, &#39;algorithm_name&#39;, &#39;cv_lassopcr&#39;, &#39;nfolds&#39;, whfolds, &#39;lasso_num&#39;, 2, &#39;nopcr&#39;);
[cverr, stats, optout] = predict(dat, &#39;algorithm_name&#39;, &#39;cv_lassopcr&#39;, &#39;nfolds&#39;, 5, &#39;estimateparam&#39;, &#39;nopcr&#39;);

Lasso pcr using hvblock cross-validation on time-series, h = 3, v = 5;
[cverr, stats, optout] = predict(dat, &#39;algorithm_name&#39;, &#39;cv_lassopcr&#39;, &#39;hvblock&#39;,[3,5]);

Output display:
orthviews(stats.weight_obj)
line_plot_multisubject(stats.yfit, stats.Y, &#39;subjid&#39;, id_numbers);
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">See also:</th><td class="field-body"><p class="first">predict_test_suite method for fmri_data, which runs predict with multiple
options and summarizes output.</p>
<p class="last">xval_regression_multisubject, xval_lasso_brain</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="&#64;fmri_data.predict_test_suite">
<code class="descclassname">&#64;fmri_data.</code><code class="descname">predict_test_suite</code><span class="sig-paren">(</span><em>dat</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@fmri_data.predict_test_suite" title="Permalink to this definition">¶</a></dt>
<dd><p>Run a set of cross-validated prediction algorithms on an fmri_data object
and plot the outcome.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>[allcverr, allyhat] = predict_test_suite(dat, [optional inputs])
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Functionality:</th><td class="field-body"><ul class="first simple">
<li>Requires matlab 2012a or later for full functionality</li>
<li>Handles categorical or continuous outcomes automatically</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Inputs:</th><td class="field-body"><dl class="first docutils">
<dt><strong>dat:</strong></dt>
<dd><p class="first last">an fMRI data object. 
dat.Y must be assigned, and must have continuous or binary outcomes assigned.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Optional:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt><strong>quick:</strong></dt>
<dd>Skip extended output</dd>
<dt><strong>nfolds:</strong></dt>
<dd>Followed by number of folds or custom holdout vector (default = 5-fold balanced)</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Examples:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="n">predict_test_suite</span><span class="p">(</span><span class="n">dat</span><span class="p">,</span> <span class="s">&#39;nfolds&#39;</span><span class="p">,</span> <span class="n">subjid</span><span class="p">);</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="&#64;fmri_data.regress">
<code class="descclassname">&#64;fmri_data.</code><code class="descname">regress</code><span class="sig-paren">(</span><em>dat</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@fmri_data.regress" title="Permalink to this definition">¶</a></dt>
<dd><p>Regression method for fmri_data object</p>
<p>Regress dat.X on dat.dat at each voxel, and return voxel-wise statistic
images. Each column of dat.X is a predictor in a multiple regression,
and the intercept is the last column. Intercept will automatically be
added if not detected unless &#8216;nointercept&#8217; is specified.</p>
<p>This function can also create a map of brain regions that predict the dat.Y
vector using the &#8216;brainony&#8217; option.  This is essentially a univariate
version of the &#8216;predict&#8217; command.  Warning: this is very slow as it loops
through all voxels.</p>
<p>Regression is OLS by default, but can be robust using &#8216;robust&#8217; flag.
Warning: Running robust option is considerably slower than OLS.</p>
<p>Creates thresholded plot by default</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="n">out</span> <span class="o">=</span> <span class="n">regress</span><span class="p">(</span><span class="n">dat</span><span class="p">,</span> <span class="n">varargin</span><span class="p">)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Inputs:</th><td class="field-body"><dl class="first docutils">
<dt><strong>dat:</strong></dt>
<dd><p class="first last">should be an fmri_data object with X field defined.
dat.X can be a design_matrix() object.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Optional Inputs:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body"><dl class="first docutils">
<dt><strong>[threshold, &#8216;unc&#8217;]:</strong></dt>
<dd><p class="first last">p-value threshold string indicating threshold type
(see help statistic_image.threshold for options)</p>
</dd>
<dt><strong>nointercept:</strong></dt>
<dd><p class="first last">Do not add intercept to model</p>
</dd>
<dt><strong>nodisplay:</strong></dt>
<dd><p class="first last">Do not plot thresholded results using orthviews</p>
</dd>
<dt><strong>brainony:</strong></dt>
<dd><p class="first last">univariate approach to predict obj.Y from brain data</p>
</dd>
<dt><strong>residual:</strong></dt>
<dd><p class="first last">Output residual as fmri_data() object</p>
</dd>
<dt><strong>noverbose:</strong></dt>
<dd><p class="first last">Suppress verbose outputs</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Outputs:</th><td class="field-body"><dl class="first docutils">
<dt><strong>out:</strong></dt>
<dd><p class="first last">A structure containing stats_img and fmri_data objects.</p>
</dd>
<dt><strong>out.b:</strong></dt>
<dd><p class="first last">stats_img object of beta values estimated from regression</p>
</dd>
<dt><strong>out.t:</strong></dt>
<dd><p class="first last">stats_img object of t-values with input threshold</p>
</dd>
<dt><strong>out.df:</strong></dt>
<dd><p class="first last">fmri_data object of degrees of freedom</p>
</dd>
<dt><strong>out.sigma:</strong></dt>
<dd><p class="first last">fmri_data object of variance of residual</p>
</dd>
<dt><strong>out.residual:</strong></dt>
<dd><p class="first last">fmri_data object of residual data after model has been regressed out (optional).</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Examples:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>% Run regression with liberal threshold
out = regress(dat, .05, &#39;unc&#39;);

% Run regression with conservative threshold and save residual
out = regress(dat, .001, &#39;unc&#39;, &#39;residual);

% Run robust regression with fdr threshold
out = regress(dat, .05, &#39;fdr&#39;,&#39;robust&#39;);

% Run a regression predicting behavior from brain at liberal threshold
out  = regress(data_comb, .05, &#39;unc&#39;, &#39;brainony&#39;)

% Re-threshold at different values
out.t = threshold(out.t, .05, &#39;fdr&#39;);
out.t = threshold(out.t, .001, &#39;unc&#39;);

% Re-display results of thresholding
orthviews(out.t);

% Write out beta image to current directory
out.b.fullpath = fullfile(pwd,&#39;beta.nii&#39;);
write(out)
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="&#64;fmri_data.rescale">
<code class="descclassname">&#64;fmri_data.</code><code class="descname">rescale</code><span class="sig-paren">(</span><em>fmridat</em>, <em>meth</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@fmri_data.rescale" title="Permalink to this definition">¶</a></dt>
<dd><p>Rescales data in an fmri_data object
Data is observations x images, so operating on the columns operates on
images, and operating on the rows operates on voxels (or variables more
generally) across images.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="n">fmridat</span> <span class="o">=</span> <span class="n">rescale</span><span class="p">(</span><span class="n">fmridat</span><span class="p">,</span> <span class="n">meth</span><span class="p">)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Inputs:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>Methods:</strong></dt>
<dd><ul class="first last simple">
<li>centervoxels</li>
<li>zscorevoxels</li>
<li>centerimages</li>
<li>zscoreimages</li>
<li>rankvoxels</li>
<li>windsorizevoxels</li>
<li>percentchange</li>
<li>tanh</li>
</ul>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>Appropriate for multi-session (time series) only:</dt>
<dd><ul class="first last simple">
<li>session_global_percent_change</li>
<li>session_global_z</li>
<li>session_multiplicative</li>
</ul>
</dd>
</dl>
<p>See also fmri_data.preprocess</p>
</dd></dl>

<dl class="function">
<dt id="&#64;fmri_data.saveplots">
<code class="descclassname">&#64;fmri_data.</code><code class="descname">saveplots</code><span class="sig-paren">(</span><em>fmri_dat</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@fmri_data.saveplots" title="Permalink to this definition">¶</a></dt>
<dd><p>Output dir</p>
</dd></dl>

<dl class="function">
<dt id="&#64;fmri_data.signtest">
<code class="descclassname">&#64;fmri_data.</code><code class="descname">signtest</code><span class="sig-paren">(</span><em>dat</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@fmri_data.signtest" title="Permalink to this definition">¶</a></dt>
<dd><p>Sign test for each voxel of an fmri_data object
returns voxel-wise statistic images.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>[out, statimg] = signtest(dat, [p-val threshold], [thresh_type])
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Inputs:</th><td class="field-body"><dl class="first docutils">
<dt><strong>dat:</strong></dt>
<dd><p class="first last">Should be an fmri_data object with .dat field containing voxels x observations matrix</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Optional inputs:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body"><p class="first">in [  ] above are
<strong>p-value threshold:</strong></p>
<blockquote>
<div><p>string indicating threshold type (see help statistic_image.threshold for options)</p>
</div></blockquote>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Outputs:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>out:</strong></dt>
<dd><p class="first last">is a structure of information about the sign test</p>
</dd>
<dt><strong>statimg:</strong></dt>
<dd><blockquote class="first">
<div><p>is a statistic_image object that can be thresholded and
plotted/imaged.  statimg.dat contains signed direction values,</p>
</div></blockquote>
<p class="last">.p contains p-values</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p>c Tor Wager, 2011
..</p>
<p>See also: fmri_data.regress</p>
</dd></dl>

<dl class="function">
<dt id="&#64;fmri_data.ttest">
<code class="descclassname">&#64;fmri_data.</code><code class="descname">ttest</code><span class="sig-paren">(</span><em>fmridat</em>, <em>pvalthreshold</em>, <em>thresh_type</em><span class="sig-paren">)</span><a class="headerlink" href="#@fmri_data.ttest" title="Permalink to this definition">¶</a></dt>
<dd><p>T-test on fmri_data class object</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="n">statsimg</span> <span class="o">=</span> <span class="n">ttest</span><span class="p">(</span><span class="n">fmridat</span><span class="p">,</span> <span class="n">pvalthreshold</span><span class="p">,</span> <span class="n">thresh_type</span><span class="p">)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Inputs:</th><td class="field-body"><dl class="first docutils">
<dt><strong>p-value threshold:</strong></dt>
<dd><p class="first last">p-value, e.g., .05 or .001 or [.001 .01 .05]</p>
</dd>
<dt><strong>thresh_type:</strong></dt>
<dd><p class="first last">&#8216;uncorrected&#8217;, &#8216;fwe&#8217;, or &#8216;fdr&#8217;</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Examples:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>%T-test, Construct a stats_image object, threshold and display:
statsimg = ttest(fmridat, .001, &#39;unc&#39;);
orthviews(statsimg);

%Re-threshold and display:
statsimg = threshold(statsimg, .000001, &#39;unc&#39;);
orthviews(statsimg);

statsimg = threshold(statsimg, .01, &#39;fdr&#39;);
orthviews(statsimg);
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Note:</th><td class="field-body">for two-sample T-test, use fmri_data.regress</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="&#64;fmri_data.windsorize">
<code class="descclassname">&#64;fmri_data.</code><code class="descname">windsorize</code><span class="sig-paren">(</span><em>obj</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@fmri_data.windsorize" title="Permalink to this definition">¶</a></dt>
<dd><p>Windsorize an fMRI data object to madlimit Median Absolute Deviations.
Default = 5 MADs.
Works across rows and columns.
Registers this step in history.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="n">obj</span> <span class="o">=</span> <span class="n">windsorize</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="p">[</span><span class="n">madlimit</span><span class="p">])</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="module-&#64;fmri_mask_image">
<span id="fmri-mask-image"></span><h1>fmri_mask_image<a class="headerlink" href="#module-@fmri_mask_image" title="Permalink to this headline">¶</a></h1>
<dl class="function">
<dt id="&#64;fmri_mask_image.resample_to_image_space">
<code class="descclassname">&#64;fmri_mask_image.</code><code class="descname">resample_to_image_space</code><span class="sig-paren">(</span><em>obj</em>, <em>sampleto</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@fmri_mask_image.resample_to_image_space" title="Permalink to this definition">¶</a></dt>
<dd><p>Resamples data in an fmri_mask_image object (obj) to the space of another
image (e.g., a functional image, for data extraction)
The volInfo field will be the same as the sampleto volume info.
The mask will have zeros in obj.dat for out-of-mask voxels.
THIS FUNCTION USES SCN_MAP_IMAGE AND REQUIRES THAT THE ORIGINAL IMAGE BE
AVAILABLE ON DISK.  Multiple resamplings will break the function because
the new space will be different from the original one on disk.  Use the
more general resample_space.</p>
<p>NOTE: Mask is <em>reloaded</em> from original data if space is remapped, and you
cannot use manual thresholding of the mask. This is a feature of the
map_to_image_space method and scn_map_image</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>obj = resample_to_image_space(obj, sampleto &lt;img name or image_vector object&gt;)
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Inputs:</th><td class="field-body"><dl class="first docutils">
<dt><strong>obj:</strong></dt>
<dd><p class="first last">must be an fmri_mask_image object</p>
</dd>
<dt><strong>sampleto:</strong></dt>
<dd><dl class="first last docutils">
<dt>can be either:</dt>
<dd><ol class="first last arabic simple">
<li>An image name to sample to</li>
<li>Another fmri_mask_image object (but image must exist on path!)</li>
</ol>
</dd>
</dl>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Optional inputs:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body"><dl class="first last docutils">
<dt><strong>mask:</strong></dt>
<dd><p class="first last">Apply sampleto as mask so that only voxels in the sampleto mask
are retained in obj.dat.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p>THIS FUNCTION WORKS, BUT IS DEPRECATED BECAUSE RESAMPLE_SPACE IS MORE
GENERAL.  resample_space does not require the resampling of the original
image from disk, which this does.  resample_space is slower, though.</p>
<p>See Also: resample_space, for a method that does not require images to
exist on disk on the path.</p>
</dd></dl>

</div>
<div class="section" id="module-&#64;fmri_model">
<span id="fmri-model"></span><h1>fmri_model<a class="headerlink" href="#module-@fmri_model" title="Permalink to this headline">¶</a></h1>
<dl class="function">
<dt id="&#64;fmri_model.build">
<code class="descclassname">&#64;fmri_model.</code><code class="descname">build</code><span class="sig-paren">(</span><em>obj</em><span class="sig-paren">)</span><a class="headerlink" href="#@fmri_model.build" title="Permalink to this definition">¶</a></dt>
<dd><p>Build the design matrix (xx) for an fmri_model object</p>
<p>We assume that the same conditions are modeled for each session.
We assume that you have one basis set per condition (this is different
from SPM, which only allows a single basis set across all conditions)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="n">obj</span> <span class="o">=</span> <span class="n">build</span><span class="p">(</span><span class="n">fmri_model_obj</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="&#64;fmri_model.build_single_trial">
<code class="descclassname">&#64;fmri_model.</code><code class="descname">build_single_trial</code><span class="sig-paren">(</span><em>obj</em>, <em>inputhrf</em><span class="sig-paren">)</span><a class="headerlink" href="#@fmri_model.build_single_trial" title="Permalink to this definition">¶</a></dt>
<dd><p>Build a single-trial design matrix (xx) for an fmri_model object</p>
<p>We assume that the same conditions are modeled for each session
We assume that you have one basis set per condition (this is different
from SPM, which only allows a single basis set across all conditions)</p>
<p>This is used in single_trial_estimates, which assumes that you have
estimated an initial model and saved image data.</p>
<p>The idea behind this is somewhat different from other canlab single-trial
analyses, in that it takes in a single, custom HRF for each condition,
rather than using a basis set.  In single_trial_estimates, custom HRFs
are created for each voxel by using the condition- and voxel-specific hrf
estimates stored during model fitting.</p>
<dl class="docutils">
<dt>The sequence would be:</dt>
<dd><ol class="first last arabic simple">
<li>robustfit(my_model), to fit average model and get HRF est for each
voxel</li>
<li>single_trial_estimates(my_model), to use this function to build
single-trial design matrices and fit them.</li>
</ol>
</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="n">obj</span> <span class="o">=</span> <span class="n">build_single_trial</span><span class="p">(</span><span class="n">fmri_model_obj</span><span class="p">,</span> <span class="n">inputhrf</span><span class="p">)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Inputs:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>inputhrf:</strong></dt>
<dd><p class="first last">should be a cell array of length nconds (number of conditions).</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="&#64;fmri_model.get_condition_assignments">
<code class="descclassname">&#64;fmri_model.</code><code class="descname">get_condition_assignments</code><span class="sig-paren">(</span><em>obj</em><span class="sig-paren">)</span><a class="headerlink" href="#@fmri_model.get_condition_assignments" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Condition assignments</dt>
<dd><ul class="first last simple">
<li>Indicator matrix coding for which columns in X belong to the same
modeled condition, and are part of the same HRF fit</li>
<li>There is one set of columns for each condition modeled, and one set of
columns for each parametric modulator of each condition</li>
<li>Because parametric modulators may not exist for all conditions, we need
to build this dynamically for modulators.</li>
</ul>
</dd>
</dl>
<p>Design matrix build (which calls method get_session_X) builds columns in
this order:</p>
<p>All within Session:
Regressors of interest, basis functions within conditions
Parametric modulators, basis functions within conditions
Covariates of no interest</p>
<p>Then:
Baselines (session/run intercepts)</p>
<p>This method is called automatically in the build method.</p>
</dd></dl>

<dl class="function">
<dt id="&#64;fmri_model.get_session_X">
<code class="descclassname">&#64;fmri_model.</code><code class="descname">get_session_X</code><span class="sig-paren">(</span><em>obj</em>, <em>s</em><span class="sig-paren">)</span><a class="headerlink" href="#@fmri_model.get_session_X" title="Permalink to this definition">¶</a></dt>
<dd><p>Get design matrix (predictors) for one session of fmri_model object, using
basis functions defined in the object and onsets for one session (s).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>[Xs, delta, C, B, names] = get_session_X(obj, session number)
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="&#64;fmri_model.plot">
<code class="descclassname">&#64;fmri_model.</code><code class="descname">plot</code><span class="sig-paren">(</span><em>obj</em><span class="sig-paren">)</span><a class="headerlink" href="#@fmri_model.plot" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot an fmri_model object</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="n">plot</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="&#64;fmri_model.replace_basis_set">
<code class="descclassname">&#64;fmri_model.</code><code class="descname">replace_basis_set</code><span class="sig-paren">(</span><em>obj</em>, <em>condition_num</em>, <em>xBF_hires</em><span class="sig-paren">)</span><a class="headerlink" href="#@fmri_model.replace_basis_set" title="Permalink to this definition">¶</a></dt>
<dd><p>Replace a basis set in an fmri_model object with another one of your
choosing.</p>
<p>This allows one to use a custom basis set, and also to use different
basis sets for different trial types.</p>
<p>Each condition across all sessions must be modeled with the same basis
set. That is, there can be only one basis set per condition, e.g., one
for anticipation (used in each session) and one for pain.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="n">obj</span> <span class="o">=</span> <span class="n">replace_basis_set</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">condition_num</span><span class="p">,</span> <span class="n">xBF_hires</span><span class="p">)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Examples:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>% generate a custom spline basis set and use that for Condition 1,
% and the standard one for Condition 2:

[xBF_hires, xBF] = fmri_spline_basis(2, &#39;length&#39;, 12, &#39;nbasis&#39;, 3, &#39;order&#39;, 3, &#39;plot&#39;);

%save this to get info that is not typically in basis set until after
%model is built.
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="&#64;fmri_model.robustfit">
<code class="descclassname">&#64;fmri_model.</code><code class="descname">robustfit</code><span class="sig-paren">(</span><em>fmri_model_obj</em>, <em>fmri_data_obj</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@fmri_model.robustfit" title="Permalink to this definition">¶</a></dt>
<dd><p>Robust fit for a model object to data object</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>robustfit(fmri_model_obj, fmri_data_obj, [optional args])
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Features:</th><td class="field-body"><p class="first">spatial smoothing of weights at 12 mm FWHM
ridge regression <strong>*not yet*</strong></p>
</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Preproc scaling:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body"><ol class="first arabic simple">
<li>Remove covariates using ridge reg; ridge trace for full model</li>
<li>scale to % signal change across time (cols) OR rank time points (for
w/i ss predictions??) AND/OR rank or center rows (images; for &#8216;shape&#8217;
analysis</li>
</ol>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"><p class="first">%sig across time, rank across rows: relative % sig change</p>
<p>Different models of noise lead to different ideas about optimal preproc
If large diffs in nuisance scaling in BOLD across individuals, ranking cols may
be good idea. but then individual diffs in overall activity will be removed...</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Options:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>tune:</strong></dt>
<dd><p class="first last">tuning const for robust reg</p>
</dd>
<dt><strong>iter:</strong></dt>
<dd><p class="first last">&#8216;maxiterations&#8217;, robust reg /WLS iterations. 1 = OLS only!</p>
</dd>
<dt><strong>smooth:</strong></dt>
<dd><p class="first last">&#8216;spatial_smooth_fwhm&#8217;, 0 or smoothing kernel for weights</p>
</dd>
<dt><strong>nosmooth:</strong></dt>
<dd><p class="first last">spatial_smooth_fwhm = 0;</p>
</dd>
<dt><strong>stats:</strong></dt>
<dd><p class="first last">&#8216;calculate_stats&#8217;, calculate_stats = 1; IN DEVELOPMENT</p>
</dd>
<dt><strong>noresiduals:</strong></dt>
<dd><p class="first last">write_residuals = 0;</p>
</dd>
<dt><strong>noplots:</strong></dt>
<dd><p class="first last">save_plots = 0;</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="&#64;fmri_model.rotate_to_pca">
<code class="descclassname">&#64;fmri_model.</code><code class="descname">rotate_to_pca</code><span class="sig-paren">(</span><em>obj</em><span class="sig-paren">)</span><a class="headerlink" href="#@fmri_model.rotate_to_pca" title="Permalink to this definition">¶</a></dt>
<dd><p>Rotate design matrix columns within all conditions to principal component projection.</p>
</dd></dl>

<dl class="function">
<dt id="&#64;fmri_model.single_trial_estimates">
<code class="descclassname">&#64;fmri_model.</code><code class="descname">single_trial_estimates</code><span class="sig-paren">(</span><em>obj</em>, <em>fmri_data_obj</em><span class="sig-paren">)</span><a class="headerlink" href="#@fmri_model.single_trial_estimates" title="Permalink to this definition">¶</a></dt>
<dd><p>Write single trial estimates associated with an estimated fmri_model object.
must have estimated the model (robustfit(obj); see fmri_model.robustfit)
and saved hrf*.img images for each condition.</p>
<p>Also input an fmri_data object with time series data.</p>
<p>This function writes images, one 4-D image for each condition, with the
number of frames equalling the number of trials (onsets) for that
condition.</p>
<p>It does this by constructing a separate design matrix for each voxel,
which is based on the HRF estimates for that voxel for each condition.
Fits for all conditions are added to the same model, so that their
colinearity influences the single-trial parameter estimates.</p>
</dd></dl>

</div>
<div class="section" id="module-&#64;image_vector">
<span id="image-vector"></span><h1>image_vector<a class="headerlink" href="#module-@image_vector" title="Permalink to this headline">¶</a></h1>
<dl class="function">
<dt id="&#64;image_vector.apply_mask">
<code class="descclassname">&#64;image_vector.</code><code class="descname">apply_mask</code><span class="sig-paren">(</span><em>dat</em>, <em>mask</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@image_vector.apply_mask" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply a mask image (image filename or fmri_mask_image object) to an image_vector object
stored in dat.</p>
<dl class="docutils">
<dt>This can be used to:</dt>
<dd><ul class="first last simple">
<li>Mask an image_vector or fmri_data object with a mask</li>
<li>Obtain &#8220;pattern expression&#8221; for a weight map (entered as the
mask, here) in a series of images stored in dat.</li>
</ul>
</dd>
</dl>
<p>The mask or weight map does not have to be in the same space as the dat;
it will be resampled to the space of the data in dat.</p>
<p>To extract pattern expression values for each ROI within a mask use extract_roi_averages()</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name" colspan="2">Optional Inputs:</th></tr>
<tr class="field-odd field"><td>&nbsp;</td><td class="field-body"><dl class="first docutils">
<dt><strong>pattern_expression:</strong></dt>
<dd><p class="first last">calculate and return the cross-product of each
image in dat and the values in the mask.  This is useful if comparing
expression values that are comprised of different datasets or differing
number of voxels.</p>
</dd>
<dt><strong>correlation:</strong></dt>
<dd><p class="first last">calculate the pearson correlation coefficient of each
image in dat and the values in the mask.</p>
</dd>
<dt><strong>norm_mask:</strong></dt>
<dd><p class="first last">normalize the mask weights by L2 norm, for patt expression
only.</p>
</dd>
<dt><strong>ignore_missing:</strong></dt>
<dd><p class="first last">use with pattern expression only. Ignore weights on voxels
with zero values in test image. If this is not entered, the function will
check for these values and give a warning.</p>
</dd>
<dt><strong>invert:</strong></dt>
<dd><p class="first last">Invert the mask so that out-of-mask voxels are now in (using
the mask as an &#8216;exclude mask&#8217; rather than an include-mask. If pattern
expression is requested, the behavior is different, and it inverts the
sign of in-mask pattern weights.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Examples:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>[dat, mask] = apply_mask(dat, mask)
[dat, mask] = apply_mask(dat, mask image name)
[dat, mask] = apply_mask(dat, mask image vector object)
[pattern_exp_values] = apply_mask(dat, weight map image, &#39;pattern_expression&#39;, &#39;ignore_missing&#39;)
[pattern_exp_values] = apply_mask(dat, weight map image, &#39;pattern_expression&#39;, &#39;ignore_missing&#39;,&#39;correlation&#39;)
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">See also:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<p>extract_roi_averages, to get individual region averages / local pattern expression
apply_nps, which does whole-pattern and local regional expression</p>
</dd></dl>

<dl class="function">
<dt id="&#64;image_vector.check_image_filenames">
<code class="descclassname">&#64;image_vector.</code><code class="descname">check_image_filenames</code><span class="sig-paren">(</span><em>obj</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@image_vector.check_image_filenames" title="Permalink to this definition">¶</a></dt>
<dd><p>Check whether images listed in obj.fullpath actually exist</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="n">obj</span> <span class="o">=</span> <span class="n">check_image_filenames</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="p">[</span><span class="s">&#39;noverbose&#39;</span><span class="p">])</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Behavior:</th><td class="field-body"><ul class="first last simple">
<li>If there are no file names, do nothing.</li>
<li>If file names are entered and full path is not, attempt to find full
path.</li>
<li>If full path info is entered, check to see if files exist.
Return output in obj.files_exist, and print a warning if only some exist.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Image names should be stored in .fullpath
abbreviated image names may be stored in image_names.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Note:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<p>fullpath should have full path to each volume in a string matrixm, with
trailing ,volume# for 4-D images as per SPM style expanded list.</p>
<p>image_names should have image name only for each volume</p>
</dd></dl>

<dl class="function">
<dt id="&#64;image_vector.compare_space">
<code class="descclassname">&#64;image_vector.</code><code class="descname">compare_space</code><span class="sig-paren">(</span><em>obj</em>, <em>obj2</em><span class="sig-paren">)</span><a class="headerlink" href="#@image_vector.compare_space" title="Permalink to this definition">¶</a></dt>
<dd><p>Compare spaces of two image_vector objects</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>function isdiff = compare_space(obj, obj2)
</pre></div>
</div>
<p>Returns 0 if same, 1 if different spaces, 2 if no volInfo info for one or
more objects. 3 if same space, but different in-mask voxels in .dat or
volInfo.image_indx</p>
</dd></dl>

<dl class="function">
<dt id="&#64;image_vector.extract_gray_white_csf">
<code class="descclassname">&#64;image_vector.</code><code class="descname">extract_gray_white_csf</code><span class="sig-paren">(</span><em>obj</em><span class="sig-paren">)</span><a class="headerlink" href="#@image_vector.extract_gray_white_csf" title="Permalink to this definition">¶</a></dt>
<dd><p>Extracts mean values (values) and top 5 component scores (components)
from each of gray, white, and CSF masks.
Images must be in standard MNI space for this to apply.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="p">[</span><span class="n">values</span><span class="p">,</span> <span class="n">components</span><span class="p">]</span> <span class="o">=</span> <span class="n">extract_gray_white_csf</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Inputs:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>obj:</strong></dt>
<dd><p class="first last">an image_vector (e.g., fmri_data) object</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="&#64;image_vector.extract_roi_averages">
<code class="descclassname">&#64;image_vector.</code><code class="descname">extract_roi_averages</code><span class="sig-paren">(</span><em>obj</em>, <em>mask</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@image_vector.extract_roi_averages" title="Permalink to this definition">¶</a></dt>
<dd><p>This image_vector method a extracts and averages data stored in an fmri_data object 
from a set of ROIs defined in a mask.
It is <em>slightly</em> different from the fmri_data method, as fmri_data has
more fields.</p>
<p>This version requires the mask_image to be in the same space as the obj.</p>
<p>Regions to average over can be either regions of contiguous voxels
bounded by voxels with values of 0 or NaN, which are considered non-data
values, or regions defined by unique integer codes in the mask image
(i.e., for atlas images with unique codes for each defined region.)</p>
<p>Mask/Atlas image does NOT have to be in the same space as the images to
extract from.  It will be remapped/resliced.</p>
<p>Extracted data is returned in single data format.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>cl = extract_roi_averages(image_vector obj, mask, [average_over])
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Inputs:</th><td class="field-body"><ul class="first simple">
<li>char array of strings containing 4D image file names (data extracted from these)</li>
<li>mask_image to extract from.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Optional inputs:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body"><dl class="first docutils">
<dt><strong>average_over:</strong></dt>
<dd><ul class="first last simple">
<li>Default: &#8216;contiguous_regions&#8217; to average over contiguous voxels
bounded by voxels of 0 or NaN (non-data values)</li>
<li>Alt. option = &#8216;unique_mask_values&#8217; to average over unique integer codes in the mask image
(i.e., for atlas images with unique codes for each defined region)</li>
</ul>
</dd>
</dl>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Examples:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="n">imgs_to_extract_from</span> <span class="o">=</span> <span class="n">filenames</span><span class="p">(</span><span class="s">&#39;w*.nii&#39;</span><span class="p">,</span><span class="s">&#39;char&#39;</span><span class="p">);</span>
<span class="n">mask_image</span> <span class="o">=</span> <span class="n">which</span><span class="p">(</span><span class="s">&#39;anat_lbpa_thal.img&#39;</span><span class="p">);</span>
<span class="p">[</span><span class="n">cl</span><span class="p">,</span> <span class="n">imgdat</span><span class="p">]</span> <span class="o">=</span> <span class="n">extract_image_data</span><span class="p">(</span><span class="n">imgs_to_extract_from</span><span class="p">,</span> <span class="n">mask_image</span><span class="p">);</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">See also:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<p>For an non-object-oriented alternative, see extract_image_data.m</p>
</dd></dl>

<dl class="function">
<dt id="&#64;image_vector.fastmontage">
<code class="descclassname">&#64;image_vector.</code><code class="descname">fastmontage</code><span class="sig-paren">(</span><em>dat</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@image_vector.fastmontage" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates 3 separate montage views - ax, cor, sagg in a special figure window</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="n">fastmontage</span><span class="p">(</span><span class="n">dat</span><span class="p">,</span> <span class="p">[</span><span class="n">myview</span><span class="p">],</span> <span class="p">[</span><span class="s">&#39;spacing&#39;</span><span class="p">,</span> <span class="n">slicespacing</span><span class="p">],</span> <span class="p">[</span><span class="s">&#39;vertical&#39;</span><span class="p">])</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Examples:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="n">fastmontage</span><span class="p">(</span><span class="n">dat</span><span class="p">);</span>
<span class="n">fastmontage</span><span class="p">(</span><span class="n">dat</span><span class="p">,</span> <span class="s">&#39;coronal&#39;</span><span class="p">);</span>
<span class="n">fastmontage</span><span class="p">(</span><span class="n">dat</span><span class="p">,</span> <span class="s">&#39;saggital&#39;</span><span class="p">,</span> <span class="s">&#39;spacing&#39;</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
<span class="n">fastmontage</span><span class="p">(</span><span class="n">dat</span><span class="p">,</span> <span class="s">&#39;saggital&#39;</span><span class="p">,</span> <span class="s">&#39;spacing&#39;</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="s">&#39;vertical&#39;</span><span class="p">);</span>
<span class="n">fastmontage</span><span class="p">(</span><span class="n">dat</span><span class="p">,</span> <span class="s">&#39;saggital&#39;</span><span class="p">,</span> <span class="s">&#39;slices_per_row&#39;</span><span class="p">,</span> <span class="mi">12</span><span class="p">);</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="&#64;image_vector.flip">
<code class="descclassname">&#64;image_vector.</code><code class="descname">flip</code><span class="sig-paren">(</span><em>dat</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@image_vector.flip" title="Permalink to this definition">¶</a></dt>
<dd><p>Flips an image_vector object left to right</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name" colspan="2">Optional Inputs:</th></tr>
<tr class="field-odd field"><td>&nbsp;</td><td class="field-body">Input &#8216;mirror&#8217; to make a symmetrical image, averaging the left
and right hemispheres</td>
</tr>
<tr class="field-even field"><th class="field-name">Examples:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="n">dat</span> <span class="o">=</span> <span class="n">flip</span><span class="p">(</span><span class="n">dat</span><span class="p">,</span> <span class="p">[</span><span class="s">&#39;mirror&#39;</span><span class="p">])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="&#64;image_vector.histogram">
<code class="descclassname">&#64;image_vector.</code><code class="descname">histogram</code><span class="sig-paren">(</span><em>obj</em><span class="sig-paren">)</span><a class="headerlink" href="#@image_vector.histogram" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="&#64;image_vector.history">
<code class="descclassname">&#64;image_vector.</code><code class="descname">history</code><span class="sig-paren">(</span><em>dat</em><span class="sig-paren">)</span><a class="headerlink" href="#@image_vector.history" title="Permalink to this definition">¶</a></dt>
<dd><p>Display history for image_vector object</p>
</dd></dl>

<dl class="function">
<dt id="&#64;image_vector.horzcat">
<code class="descclassname">&#64;image_vector.</code><code class="descname">horzcat</code><span class="sig-paren">(</span><em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@image_vector.horzcat" title="Permalink to this definition">¶</a></dt>
<dd><p>Implements the horzcat ([a b]) operator on image_vector objects across voxels.
Requires that each object has an equal number of columns and voxels</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>function s = horzcat(varargin)
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Examples:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>c = [dat1 dat2];
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="&#64;image_vector.ica">
<code class="descclassname">&#64;image_vector.</code><code class="descname">ica</code><span class="sig-paren">(</span><em>fmridat_obj</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@image_vector.ica" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Spatial ICA of an fmri_data object</dt>
<dd><ul class="first last simple">
<li>icadat = ica(fmridat_obj, [number of ICs to save])</li>
<li>icadat is also an fmri_data object, with .dat field voxels x components</li>
</ul>
</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Notes:</th><td class="field-body"><ul class="first last simple">
<li>icasig = W * mixedsig</li>
<li>icasig = icadat.dat&#8217; = W * fmridat_obj.dat&#8217;</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>A is scaled version of fmridat_obj.dat&#8217; * icadat.dat</p>
<p>A and W are stored in additional_info field of icadat</p>
</dd></dl>

<dl class="function">
<dt id="&#64;image_vector.image_math">
<code class="descclassname">&#64;image_vector.</code><code class="descname">image_math</code><span class="sig-paren">(</span><em>obj1</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@image_vector.image_math" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform simple mathematical and boolean operations on image objects</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>obj_out = image_math(obj1, [optional inputs, e.g., a 2nd object, keywords])
</pre></div>
</div>
<dl class="docutils">
<dt>For objects: Type methods(object_name) for a list of special commands</dt>
<dd>Type help object_name.method_name for help on specific
methods.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Inputs:</th><td class="field-body"><dl class="first docutils">
<dt><strong>obj1:</strong></dt>
<dd><p class="first last">An image_vector object</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Optional Inputs:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body"><dl class="first docutils">
<dt><strong>obj2:</strong></dt>
<dd><p class="first last">An additional image_vector object</p>
</dd>
<dt><strong>{&#8216;add&#8217;, &#8216;plus&#8217;}:</strong></dt>
<dd><dl class="first last docutils">
<dt>Keyword to perform image-wise addition of images in obj1</dt>
<dd><p class="first last">and obj2.  Assumes these are paired/matched objects.</p>
</dd>
</dl>
</dd>
<dt><strong>{&#8216;subtract&#8217;, &#8216;minus&#8217;}:</strong></dt>
<dd><dl class="first last docutils">
<dt>Keyword to perform image-wise subtraction of images</dt>
<dd><p class="first last">in obj1 and obj2</p>
</dd>
</dl>
</dd>
<dt><strong>{&#8216;cat&#8217;, &#8216;concatenate&#8217;}:</strong></dt>
<dd><dl class="first last docutils">
<dt>Concatenate obj1 and obj2 image-wise.  Requires same</dt>
<dd><p class="first last">number of voxels in both image sets.  Returns effects
codes of 1, -1 in obj_out.Y.</p>
</dd>
</dl>
</dd>
<dt><strong>{&#8216;power&#8217;}:</strong></dt>
<dd><dl class="first last docutils">
<dt>Keyword to raise data to power element-wise; obj.dat = obj.dat.^b;</dt>
<dd><p class="first last">Followed by exponent to apply (b)</p>
</dd>
</dl>
</dd>
</dl>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Outputs:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>obj_out:</strong></dt>
<dd><p class="first last">The result - an image_vector object</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p>DEFAULTS AND INPUTS
..</p>
</dd></dl>

<dl class="function">
<dt id="&#64;image_vector.image_similarity_plot">
<code class="descclassname">&#64;image_vector.</code><code class="descname">image_similarity_plot</code><span class="sig-paren">(</span><em>obj</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@image_vector.image_similarity_plot" title="Permalink to this definition">¶</a></dt>
<dd><p>Point-biserial correlations between images in fmri_data obj and set of
&#8216;spatial basis function&#8217; images (e.g., &#8216;signatures&#8217; or pre-defined maps)</p>
<p>Usage:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">stats</span> <span class="o">=</span> <span class="n">image_similarity_plot</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s">&#39;average&#39;</span><span class="p">);</span>
</pre></div>
</div>
<p>This is a method for an image_vector object</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Inputs:</th><td class="field-body"><dl class="first docutils">
<dt><strong>obj:</strong></dt>
<dd><p class="first last">An image object with one or more images loaded</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Optional inputs:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body"><dl class="first docutils">
<dt><strong>average:</strong></dt>
<dd><p class="first last">Calculate average over images in obj with standard errors
Useful if obj contains one image per subject and you want
to test similarity with maps statistically.
Default behavior is to plot each individual image.</p>
</dd>
<dt><strong>bucknerlab</strong></dt>
<dd><p class="first last">Use 7 network parcellation from Yeo et al. as basis for
comparisons</p>
</dd>
<dt><strong>kragelemotion</strong></dt>
<dd><p class="first">Use 7 emotion-predictive models from Kragel &amp; LaBar 2015 for
basis of comparisons</p>
<p class="last"><strong>compareGroups</strong>
Perform multiple one-way ANOVAs with group as a factor (one for
each spatial basis); requires group as subsequent input</p>
</dd>
<dt><strong>group</strong></dt>
<dd><p class="first last">Indicates group membership for each image</p>
</dd>
<dt><strong>noplot</strong></dt>
<dd><p class="first last">Omits plot (print stats only)</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Outputs:</th><td class="field-body"><dl class="first docutils">
<dt><strong>stats:</strong></dt>
<dd><dl class="first last docutils">
<dt>Structure including:</dt>
<dd><ul class="first last simple">
<li>.r, Correlations in [7 networks x images in obj] matrix</li>
<li>.t, T-test (if &#8216;average&#8217; is specified)</li>
<li>.line_handles Handles to polar plot lines so you can
customize</li>
<li>.fill_handles Handles to polar plot fills so you can
customize</li>
<li>.table_spatial, ANOVA table with subject as row factor and
spatial basis as column factor (one way repeated measures
ANOVA, requires &#8216;average&#8217; to be specified)</li>
<li>.multcomp_spatial, multiple comparisons of means across
different spatial bases, critical value determined
by Tukey-Kramer method (see multcompare)</li>
</ul>
</dd>
</dl>
</dd>
<dt><strong>table_group</strong></dt>
<dd><p class="first last">multiple one-way ANOVA tables (one for each
spatial basis) with group as column factor (requires
&#8216;average&#8217; to be specified)</p>
</dd>
<dt><strong>multcomp_group</strong></dt>
<dd><p class="first last">mutiple comparisons of means across groups, one output
cell for each spatial basis, critical value determined
by Tukey-Kramer method (see multcompare)</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Examples:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>% corrdat is an fmri_data object with 18 images from searchlight
% correlation in it.  Then:
stats = image_similarity_plot_bucknermaps(corrdat, &#39;average&#39;);

% t_diff is a thresholded statistic_image object
stats = image_similarity_plot_bucknermaps(t_diff);
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">See also:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<p>tor_polar_plot</p>
<p>List dates and changes here, and author of changes
11/30/2015 (Phil Kragel)</p>
<blockquote>
<div><ul class="simple">
<li>added anova (rm) comparing means across spatial bases</li>
<li>added anova (1-way) comparing means across groups for each spatial
basis (e.g., for each buckner network)</li>
</ul>
</div></blockquote>
<dl class="docutils">
<dt>12/15/2015 (Phil Kragel)</dt>
<dd><ul class="first last simple">
<li>added option to omit plotting</li>
</ul>
</dd>
</dl>
<p>DEFAULTS AND INPUTS
..</p>
</dd></dl>

<dl class="function">
<dt id="&#64;image_vector.image_similarity_plot_bucknermaps">
<code class="descclassname">&#64;image_vector.</code><code class="descname">image_similarity_plot_bucknermaps</code><span class="sig-paren">(</span><em>obj</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@image_vector.image_similarity_plot_bucknermaps" title="Permalink to this definition">¶</a></dt>
<dd><p>Point-biserial correlations between images in fmri_data obj and Bucker
Lab 7-network maps, with polar plot</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="n">stats</span> <span class="o">=</span> <span class="n">image_similarity_plot_bucknermaps</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s">&#39;average&#39;</span><span class="p">);</span>
</pre></div>
</div>
<p>This is a method for an image_vector object</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Inputs:</th><td class="field-body"><dl class="first docutils">
<dt><strong>obj:</strong></dt>
<dd><p class="first last">An image object with one or more images loaded</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Optional inputs:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body"><dl class="first docutils">
<dt><strong>average:</strong></dt>
<dd><p class="first last">Calculate average over images in obj with standard errors
Useful if obj contains one image per subject and you want
to test similarity with maps statistically.
Default behavior is to plot each individual image.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Outputs:</th><td class="field-body"><dl class="first docutils">
<dt><strong>stats:</strong></dt>
<dd><dl class="first last docutils">
<dt>Structure including:</dt>
<dd><ul class="first last simple">
<li>.r, Correlations in [7 networks x images in obj] matrix</li>
<li>.t, T-test (if &#8216;average&#8217; is specified)</li>
<li>.line_handles Handles to polar plot lines so you can
customize</li>
<li>.fill_handles Handles to polar plot fills so you can
customize</li>
</ul>
</dd>
</dl>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Examples:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>% corrdat is an fmri_data object with 18 images from searchlight
% correlation in it.  Then:
stats = image_similarity_plot_bucknermaps(corrdat, &#39;average&#39;);

% t_diff is a thresholded statistic_image object
stats = image_similarity_plot_bucknermaps(t_diff);
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">See also:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<p>tor_polar_plot</p>
<p>DEFAULTS AND INPUTS
..</p>
</dd></dl>

<dl class="function">
<dt id="&#64;image_vector.interpolate">
<code class="descclassname">&#64;image_vector.</code><code class="descname">interpolate</code><span class="sig-paren">(</span><em>dat</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@image_vector.interpolate" title="Permalink to this definition">¶</a></dt>
<dd><p>Interpolate over missing values in image_vector object</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="n">dat</span> <span class="o">=</span> <span class="n">interpolate</span><span class="p">(</span><span class="n">dat</span><span class="p">,</span> <span class="n">varargin</span><span class="p">)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Input:</th><td class="field-body">image_vector object (dat; e.g., an fmri_data object)</td>
</tr>
</tbody>
</table>
<p>Use when there are some missing values in the mask image
Performs 3-D linear interpolation to fill in all values in the original
mask.</p>
<p>e.g., For a standard brain image space that is 91 x 109 x 91, you may
have 300,000 in-mask values. Only 150,000 of these may be defined in the
image, however, and the rest are missing (0 or NaN).
This function will return a dat image with non-missing values for all
300,000 voxels (the &#8220;in-mask&#8221; space). 
It will not return values for all voxels in the 91 x 109 x 91 space,
however.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Note:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<p>This function does not upsample the data now, but could be extended
to do so fairly easily.</p>
</dd></dl>

<dl class="function">
<dt id="&#64;image_vector.mean">
<code class="descclassname">&#64;image_vector.</code><code class="descname">mean</code><span class="sig-paren">(</span><em>obj</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@image_vector.mean" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an image_vector object with mean values for each voxel (cols)
across images (rows) of an fmri_data object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>function m = mean(obj, [optional args])
</pre></div>
</div>
<p>m is an image_vector object whose data contains the mean values.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name" colspan="2">Optional Inputs:</th></tr>
<tr class="field-odd field"><td>&nbsp;</td><td class="field-body"><ul class="first simple">
<li>&#8216;write&#8217;, followed by file name</li>
<li>&#8216;path&#8217;, followed by location for file (default = current directory)</li>
<li>&#8216;orthviews&#8217; -&gt; show orthviews for this image, same as orthviews(m)</li>
<li>&#8216;histogram&#8217; -&gt; show histogram for this image, same as histogram(m)</li>
<li>&#8216;plot&#8217; -&gt; do both</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Examples:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>% If sdat is an fmri_data object with multiple images,
m = mean(sdat, &#39;plot&#39;, &#39;write&#39;, anatmeanname, &#39;path&#39;, maskdir);
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="&#64;image_vector.minus">
<code class="descclassname">&#64;image_vector.</code><code class="descname">minus</code><span class="sig-paren">(</span><em>obj1</em>, <em>obj2</em><span class="sig-paren">)</span><a class="headerlink" href="#@image_vector.minus" title="Permalink to this definition">¶</a></dt>
<dd><p>Implements the minus (-) operator on image_vector objects across voxels.
Requires that each object has an equal number of columns and voxels</p>
</dd></dl>

<dl class="function">
<dt id="&#64;image_vector.montage">
<code class="descclassname">&#64;image_vector.</code><code class="descname">montage</code><span class="sig-paren">(</span><em>image_obj</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@image_vector.montage" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a montage of an image_vector (or statistic_image or fmri_data) object</p>
<p><a href="#id7"><span class="problematic" id="id8">*</span></a>Usage:</p>
<div class="highlight-python"><div class="highlight"><pre>[fig_handle or o2 fmridisp object] = montage(image_obj, [optional arguments])
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name" colspan="2">Optional inputs:</th></tr>
<tr class="field-odd field"><td>&nbsp;</td><td class="field-body"><dl class="first docutils">
<dt><strong>fmridisplay:</strong></dt>
<dd><p class="first last">for fmridisplay object style montage [default]</p>
</dd>
<dt><strong>scnmontage:</strong></dt>
<dd><p class="first last">for circa 2008-style SCN lab montage for each image vector</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Examples:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="n">o2</span> <span class="o">=</span> <span class="n">montage</span><span class="p">(</span><span class="n">mask</span><span class="p">);</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="&#64;image_vector.orthviews">
<code class="descclassname">&#64;image_vector.</code><code class="descname">orthviews</code><span class="sig-paren">(</span><em>image_obj</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@image_vector.orthviews" title="Permalink to this definition">¶</a></dt>
<dd><p>Orthviews display (SPM) for CANlab image_vector (or fmri_data, statistic_image) object</p>
<p><a href="#id9"><span class="problematic" id="id10">*</span></a>Usage:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">orthviews</span><span class="p">(</span><span class="n">image_obj</span><span class="p">,</span> <span class="n">varargin</span><span class="p">)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name" colspan="2">Optional Inputs:</th></tr>
<tr class="field-odd field"><td>&nbsp;</td><td class="field-body"><dl class="first last docutils">
<dt><strong>posneg:</strong></dt>
<dd><p class="first last">input generates orthviews using solid colors.</p>
</dd>
<dt><strong>largest_region:</strong></dt>
<dd><p class="first last">to center the orthviews on the largest region in the image</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="&#64;image_vector.plot_current_orthviews_coord">
<code class="descclassname">&#64;image_vector.</code><code class="descname">plot_current_orthviews_coord</code><span class="sig-paren">(</span><em>dat</em><span class="sig-paren">)</span><a class="headerlink" href="#@image_vector.plot_current_orthviews_coord" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieves and plots the image data series at the current crosshairs in spm_orthviews</p>
</dd></dl>

<dl class="function">
<dt id="&#64;image_vector.plus">
<code class="descclassname">&#64;image_vector.</code><code class="descname">plus</code><span class="sig-paren">(</span><em>obj1</em>, <em>obj2</em><span class="sig-paren">)</span><a class="headerlink" href="#@image_vector.plus" title="Permalink to this definition">¶</a></dt>
<dd><p>Implements the plus (+) operator on image_vector objects across voxels.
Requires that each object has an equal number of columns and voxels</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Examples:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="n">c</span> <span class="o">=</span> <span class="n">dat1</span> <span class="o">+</span> <span class="n">dat2</span><span class="p">;</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="&#64;image_vector.power">
<code class="descclassname">&#64;image_vector.</code><code class="descname">power</code><span class="sig-paren">(</span><em>obj</em>, <em>b</em><span class="sig-paren">)</span><a class="headerlink" href="#@image_vector.power" title="Permalink to this definition">¶</a></dt>
<dd><p>Implements the power (^) operator on image_vector objects across voxels.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Examples:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="n">c</span> <span class="o">=</span> <span class="n">dat1</span><span class="o">^</span><span class="mi">2</span><span class="p">;</span>
</pre></div>
</div>
<p>Programmer Notes:
Created 3/14/14 by Luke Chang
..</p>
</dd></dl>

<dl class="function">
<dt id="&#64;image_vector.preprocess">
<code class="descclassname">&#64;image_vector.</code><code class="descname">preprocess</code><span class="sig-paren">(</span><em>obj</em>, <em>meth</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@image_vector.preprocess" title="Permalink to this definition">¶</a></dt>
<dd><p>Preprocesses data in an fmri_data object</p>
<p>Data is observations (i.e., voxels, subjects) x images, so operating on the columns operates on
images, and operating on the rows operates on voxels (or variables more
generally) across images.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Inputs:</th><td class="field-body"><p class="first"><strong>meth:</strong> Options</p>
<dl class="docutils">
<dt><strong>resid:</strong></dt>
<dd><p class="first last">Residualize voxels with respect to covariates
Uses obj.covariates, obj.dat.
Adds intercept automatically. You can tell it to add the mean response per voxel back in:
obj = preprocess(obj, &#8216;resid&#8217;, [add mean back in flag])</p>
</dd>
<dt><strong>hpfilter:</strong></dt>
<dd><p class="first last">High-pass filter and remove run intercepts and first two
images per run. Uses obj.dat, obj.images_per_session
obj = preprocess(obj, &#8216;hpfilter&#8217;, HPlen in s, TR)</p>
</dd>
<dt><strong>windsorize:</strong></dt>
<dd><p class="first last">Windsorize entire data matrix to 3 STD</p>
</dd>
<dt><strong>windsorizevoxels:</strong></dt>
<dd><p class="first last">Windsorize each time series in data matrix to 3 STD</p>
</dd>
<dt><strong>session_outliers:</strong></dt>
<dd><p class="first last">Identify session-wise (run-wise) outliers with significant
based on mahalanobis distance with FDR-corrected P-values in chi-square test.
Impute session grand mean outliers.</p>
</dd>
<dt><strong>outliers:</strong></dt>
<dd><p class="first last">Identify outlier time points for each session based on
mahalanobis distance (see above) across global mean for slices and
spatial STD for slices, as in scn_session_spike_id.
Outliers at 3 SD based on timeseries added to obj.covariates.</p>
</dd>
<dt><strong>outliers_rmssd:</strong></dt>
<dd><p class="first last">Identify outlier time points for each session based on
root-mean-square successive differences between images (across voxels.)
this is the std (across voxels) of the successive diffs across images.
Outliers at 3.5 SD based on timeseries added to obj.covariates.</p>
</dd>
<dt><strong>smooth:</strong></dt>
<dd><dl class="first docutils">
<dt>Smoothed images with Gaussian filter</dt>
<dd><ul class="first last simple">
<li>obj = preprocess(obj, &#8216;smooth&#8217;, FWHM in mm)</li>
</ul>
</dd>
</dl>
<p class="last"><em>NOTE</em> SMOOTHING KERNEL MAY BE IN VOX, AS VOL INFO IS NOT PASSED IN</p>
</dd>
<dt><strong>interp_images:</strong></dt>
<dd><p class="first">Interpolate all voxels in a series of images specified
by logical vector whout.</p>
<blockquote class="last">
<div><ul class="simple">
<li>obj = preprocess(obj, &#8216;interp_images&#8217;, whout);</li>
</ul>
</div></blockquote>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Examples:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>% two complementary ways to get and plot outliers:
dat = preprocess(dat, &#39;outliers&#39;, &#39;plot&#39;);
subplot(5, 1, 5); % go to new panel...
dat = preprocess(dat, &#39;outliers_rmssd&#39;, &#39;plot&#39;);
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="&#64;image_vector.read_from_file">
<code class="descclassname">&#64;image_vector.</code><code class="descname">read_from_file</code><span class="sig-paren">(</span><em>obj</em><span class="sig-paren">)</span><a class="headerlink" href="#@image_vector.read_from_file" title="Permalink to this definition">¶</a></dt>
<dd><p>Reads data from image filenames into obj.dat</p>
<p>Try obj = check_image_filenames(obj) first.</p>
<p>This is automatically called if you create a new image_vector object with
names but do not directly enter data. e.g., the commands below will load data:</p>
<blockquote>
<div><ul class="simple">
<li>name = &#8216;salientmap.nii&#8217;;</li>
<li>img = image_vector(&#8216;image_names&#8217;, name);</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="&#64;image_vector.rebuild_volinfo_from_dat">
<code class="descclassname">&#64;image_vector.</code><code class="descname">rebuild_volinfo_from_dat</code><span class="sig-paren">(</span><em>dat</em>, <em>newdat</em><span class="sig-paren">)</span><a class="headerlink" href="#@image_vector.rebuild_volinfo_from_dat" title="Permalink to this definition">¶</a></dt>
<dd><p>Will rebuild volInfo (the image space, or sometimes &#8220;mask&#8221;) from a vectorized image. 
In other words, will rebuild dat.volInfo from newdat.</p>
<p>Also resets all voxels to be significant, if a statistic image</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Input:</th><td class="field-body"><dl class="first docutils">
<dt><strong>dat:</strong></dt>
<dd><p class="first last">an image_vector</p>
</dd>
<dt><strong>newdat:</strong></dt>
<dd><p class="first last">a vector that MUST be size of ENTIRE image (dat.volInfo.nvox)</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Output:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>dat:</strong></dt>
<dd><p class="first last">dat.dat contains the non-zero values of newdat, and dat.volInfo is
correctly defining the image space</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="&#64;image_vector.reconstruct_image">
<code class="descclassname">&#64;image_vector.</code><code class="descname">reconstruct_image</code><span class="sig-paren">(</span><em>obj</em><span class="sig-paren">)</span><a class="headerlink" href="#@image_vector.reconstruct_image" title="Permalink to this definition">¶</a></dt>
<dd><p>Reconstruct a 3-D or 4-D image from image_vector object obj</p>
<p>voldata is and X x Y x Z x Images matrix
vectorized_voldata is the same, with all voxels vectorized</p>
<p>This output has one element for every voxel in THE ENTIRE IMAGE, and so
can be very memory-intensive.  But it&#8217;s useful for lining up voxels
across images with different masks/in-mask voxels.</p>
<p>This function returns output in memory;
see image_vector.write for writing .img files to disk.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Outputs:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>voldata:</strong></dt>
<dd><p class="first last">3-D recon volume</p>
</dd>
<dt><strong>vectorized_voldata:</strong></dt>
<dd><p class="first last">volume in column vetor, iimg_xxx function format</p>
</dd>
<dt><strong>xyz_coord_struct:</strong></dt>
<dd><dl class="first last docutils">
<dt>has fields with coordinate information in mm (world) space</dt>
<dd><ul class="first last simple">
<li>x, y, z : vectors of coordinates in mm for each of the 3
dimensions of the image</li>
<li>X, Y, Z : output matrices from meshgrid with mm coordinates,
for volume visualization.
These can be passed to surf or isocaps functions for volume
visualization in world space (mm).</li>
</ul>
</dd>
</dl>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="&#64;image_vector.remove_empty">
<code class="descclassname">&#64;image_vector.</code><code class="descname">remove_empty</code><span class="sig-paren">(</span><em>dat</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@image_vector.remove_empty" title="Permalink to this definition">¶</a></dt>
<dd><p>remove vox: logical vector of custom voxels to remove, VOX x 1</p>
<p>remove im: logical vector of custom images to remove, 1 x IMAGES</p>
<p>indices of removed data will be stored in removed_voxels and
removed_images fields, to preserve ability to later reconstruct into 3D images</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>dat = remove_empty(dat, [logical vector of custom voxels to remove], [logical vector of imgs to remove])
</pre></div>
</div>
<p>Indicator vectors stored in:
removed_images
removed_voxels</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">See also:</th><td class="field-body">replace_empty</td>
</tr>
</tbody>
</table>
<p>force logical</p>
</dd></dl>

<dl class="function">
<dt id="&#64;image_vector.reparse_contiguous">
<code class="descclassname">&#64;image_vector.</code><code class="descname">reparse_contiguous</code><span class="sig-paren">(</span><em>obj</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@image_vector.reparse_contiguous" title="Permalink to this definition">¶</a></dt>
<dd><p>Re-construct list of contiguous voxels in an image based on in-image
voxel coordinates.  Coordinates are taken from obj.volInfo.xyzlist.</p>
<p>Results are saved in obj.volInfo.cluster.</p>
<p>xyzlist can be generated from iimg_read_img, and is done automatically by
object-oriented fMRI image classes (fmri_image, image_vector,
statistic_image)</p>
<p>If &#8216;nonempty&#8217; is entered as an optional argument, will use only voxels
that are non-zero, non-nan in all columns of obj.dat.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="n">obj</span> <span class="o">=</span> <span class="n">reparse_contiguous</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="p">[</span><span class="s">&#39;nonempty&#39;</span><span class="p">])</span>
</pre></div>
</div>
<p>.cluster and .xyzlist should both always be length v in-mask voxels
if &#8216;nonempty&#8217; is entered, then .dat should be length v in-mask voxels too</p>
</dd></dl>

<dl class="function">
<dt id="&#64;image_vector.replace_empty">
<code class="descclassname">&#64;image_vector.</code><code class="descname">replace_empty</code><span class="sig-paren">(</span><em>obj</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@image_vector.replace_empty" title="Permalink to this definition">¶</a></dt>
<dd><p>Replace empty/missing values in an image data object</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>obj = replace_empty(obj, [optional keywords])
</pre></div>
</div>
<p>Replace missing values in obj.dat stored in obj.removed_voxels and
obj.removed_images with zeros.  This returns obj.dat in a format that can
be reconstructed into a 3-D or 4-D image matrix for brain visualization.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name" colspan="2">Optional keywords:</th></tr>
<tr class="field-odd field"><td>&nbsp;</td><td class="field-body"><dl class="first last docutils">
<dt><strong>&#8216;voxels&#8217; or &#8216;images&#8217;:</strong></dt>
<dd><p class="first last">replace only missing voxels/images</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">See also:</th><td class="field-body">remove_empty, zeroinsert, nanremove, naninsert</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="&#64;image_vector.resample_space">
<code class="descclassname">&#64;image_vector.</code><code class="descname">resample_space</code><span class="sig-paren">(</span><em>obj</em>, <em>sampleto</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@image_vector.resample_space" title="Permalink to this definition">¶</a></dt>
<dd><p>Resample the images in an fmri_data object (obj) to the space of another
image (sampleto; e.g., a mask image). Works for all image_vector objects.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>obj = resample_space(obj, sampleto, [sampling method])
</pre></div>
</div>
<dl class="docutils">
<dt>Sampleto may be one of these:</dt>
<dd><ol class="first last arabic simple">
<li>a volInfo structure (the image does not have to exist on the path)</li>
<li>an image_vector, fmri_data, fmri_mask_image object</li>
<li>a string with the name of an image</li>
</ol>
</dd>
</dl>
<p>Can enter resampling method as optional input. Takes any input to
interp3:</p>
<blockquote>
<div><p>&#8216;nearest&#8217; - nearest neighbor interpolation
&#8216;linear&#8217;  - linear interpolation (default)
&#8216;spline&#8217;  - spline interpolation
&#8216;cubic&#8217;   - cubic interpolation as long as the data is uniformly</p>
<blockquote>
<div>spaced, otherwise the same as &#8216;spline&#8217;</div></blockquote>
</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Examples:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>label_mask = fmri_data(which(&#39;atlas_labels_combined.img&#39;));
label_mask = resample_space(label_mask, ivec, &#39;nearest&#39;) % resamples and masks label image
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="&#64;image_vector.resample_time">
<code class="descclassname">&#64;image_vector.</code><code class="descname">resample_time</code><span class="sig-paren">(</span><em>obj</em>, <em>source_TR</em>, <em>target_TR</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@image_vector.resample_time" title="Permalink to this definition">¶</a></dt>
<dd><p>Resample the time-series images (source_time_interval) in an fmri_data object (obj) 
to the different time series (target_time_interval). Works for all image_vector objects.</p>
<blockquote>
<div><ul class="simple">
<li>obj = resample_time(obj, source_time_interval, target_time_interval, varargin)</li>
</ul>
</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name" colspan="2">Optional Inputs:</th></tr>
<tr class="field-odd field"><td>&nbsp;</td><td class="field-body"><dl class="first docutils">
<dt><strong>meth (Interpolation methods):</strong></dt>
<dd><dl class="first last docutils">
<dt>You can enter resampling method as optional input. Takes any input to</dt>
<dd><ul class="first last">
<li><p class="first">&#8216;nearest&#8217; - nearest neighbor interpolation</p>
</li>
<li><p class="first">&#8216;linear&#8217;  - linear interpolation (default)</p>
</li>
<li><p class="first">&#8216;spline&#8217;  - spline interpolation</p>
</li>
<li><dl class="first docutils">
<dt>&#8216;cubic&#8217;   - cubic interpolation as long as the data is uniformly</dt>
<dd><p class="first last">spaced, otherwise the same as &#8216;spline&#8217;</p>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</dd>
<dt><strong>slice:</strong></dt>
<dd><p class="first last">A fraction of the slice timing correction.
The default is 0.5, meaning if your TR is 2s, the time point of your TR image
will be considered as the middle point of the TR bins. You can use this option
to use different time points. If you are upsampling your data (i.e.,
your target TR is shorter than your source TR), you need to discard the
first column of your data. This function will return the first time point data as NaN.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Examples:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>dat = fmri_data(&#39;/Volumes/RAID1/labdata/current/BMRK3/Imaging/spatiotemp_biomarker/STmarker1.img&#39;);
dat = resample_time(dat, 2, 1.3) 

% with options:
dat = resample_time(dat, 2, 1.3, &#39;meth&#39;, &#39;linear&#39;, &#39;slice&#39;, .3)
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="&#64;image_vector.sagg_slice_movie">
<code class="descclassname">&#64;image_vector.</code><code class="descname">sagg_slice_movie</code><span class="sig-paren">(</span><em>dat</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@image_vector.sagg_slice_movie" title="Permalink to this definition">¶</a></dt>
<dd><p>Movie of successive differences (sagittal slice)
Enter an image_vector or fmri_data object (usually with time series)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="n">sagg_slice_movie</span><span class="p">(</span><span class="n">dat</span><span class="p">,</span> <span class="p">[</span><span class="n">full_path_of_movie_output_file</span><span class="p">,</span><span class="n">image_skip_interval</span><span class="p">])</span>
</pre></div>
</div>
<p><a href="#id11"><span class="problematic" id="id12">*</span></a>Optional Inputs:</p>
<blockquote>
<div><dl class="docutils">
<dt><strong>movie_output_file:</strong></dt>
<dd><dl class="first last docutils">
<dt>a char array detailing the full path to save the</dt>
<dd>movie file</dd>
</dl>
</dd>
<dt><strong>image_skip_interval:</strong></dt>
<dd><blockquote class="first">
<div>An integer value describing the interval 
between images in each subsequent frame of the movie</div></blockquote>
<p class="last">(default = 1)</p>
</dd>
</dl>
</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Examples:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre> sagg_slice_movie(fmri_dat, ...
            &#39;/Volumes/engram/labdata/fmri_data/Study1/Subj1/qc_images&#39;, 5)

This would save an movie based on the images in fmri_dat to the
above directory, with an interval of 5 images between each
frame (so, the movie would show image 1, 6, 11, 16, etc)
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="&#64;image_vector.searchlight">
<code class="descclassname">&#64;image_vector.</code><code class="descname">searchlight</code><span class="sig-paren">(</span><em>dat</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@image_vector.searchlight" title="Permalink to this definition">¶</a></dt>
<dd><p>Run searchlight multivariate prediction/classification on an image_vector
or fmri_data object OR two objects, for cross-prediction.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>[list outputs here] = function_name(list inputs here, [optional inputs])
[results_obj, indx] = searchlight(dat, [optional inputs])
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Features:</th><td class="field-body"><ul class="first last simple">
<li>Runs searchlight with standard, pre-defined algorithms</li>
<li>Custom-entry definition of holdout sets</li>
<li>Can re-use searchlight spheres after initial definition</li>
<li>Custom-entry definition of any spheres/regions of interest</li>
<li>Uses Matlab&#8217;s parallel processing toolbox (parfor)</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Type help image_vector.searchlight to display this help information</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Inputs:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>dat:</strong></dt>
<dd><p class="first last">image_vector or fmri_data object with data</p>
</dd>
<dt><strong>dat.Y:</strong></dt>
<dd><p class="first last">required: true outcomes for each observation (image) in dat</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p>:Optional Inputs:* Keyword followed by input variable:</p>
<blockquote>
<div><dl class="docutils">
<dt><strong>r:</strong></dt>
<dd>searchlight radius, voxels</dd>
<dt><strong>dat2:</strong></dt>
<dd>second dataset, for cross-prediction</dd>
<dt><strong>indx:</strong></dt>
<dd>sparse logical matrix. each COLUMN is index of inclusion sets for each region/sphere in searchlight
This takes a long time to calculate, but can be saved and
re-used for a given mask</dd>
</dl>
</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Outputs:</th><td class="field-body"><dl class="first docutils">
<dt><strong>results_obj:</strong></dt>
<dd><p class="first last">fmri_data object with results maps</p>
</dd>
<dt><strong>stats:</strong></dt>
<dd><p class="first last">selected statistics for each sphere in searchlight</p>
</dd>
<dt><strong>indx:</strong></dt>
<dd><p class="first last">sparse logical matrix. each COLUMN is index of inclusion sets for each region/sphere in searchlight
* this can be re-used for all data with the same mask/structure. *</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Examples:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>% Define a sensible gray-matter mask:
dat = fmri_data(which(&#39;scalped_avg152T1_graymatter.img&#39;));
dat = threshold(dat, [.8 Inf], &#39;raw-between&#39;);
dat = trim_mask(dat);

% Create fake data and holdout indicator index vector
dat.dat = randn(dat.volInfo.n_inmask, 30);
dat.Y = dat.dat(111111, :)&#39; + .3 * randn(30, 1);
holdout_set = ones(6, 1); for i = 2:5, holdout_set = [holdout_set; i*ones(6, 1)]; end

% Run, and run again with existing indx
pool = parpool(12);  % initialize parallel processing (12 cores)
[results_obj, indx] = searchlight(dat, &#39;holdout_set&#39;, holdout_set);
results_obj = searchlight(dat, &#39;holdout_set&#39;, holdout_set, &#39;indx&#39;, indx);
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">See also:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<p>region.m, fmri_data.predict.m</p>
<p>DEFAULTS AND INPUTS
..</p>
</dd></dl>

<dl class="function">
<dt id="&#64;image_vector.slices">
<code class="descclassname">&#64;image_vector.</code><code class="descname">slices</code><span class="sig-paren">(</span><em>obj</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@image_vector.slices" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a montage of single-slice results for every image in an
image_vector object</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="n">o</span> <span class="o">=</span> <span class="n">slices</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s">&#39;orientation&#39;</span><span class="p">,</span> <span class="p">[</span><span class="n">orientation</span><span class="p">],</span> <span class="s">&#39;slice&#39;</span><span class="p">,</span> <span class="p">[</span><span class="n">slice_mm</span><span class="p">],</span> <span class="s">&#39;nimages&#39;</span><span class="p">,</span> <span class="p">[</span><span class="n">nimgs</span><span class="p">])</span>
</pre></div>
</div>
<p>obj is an image_vector, fmri_data, or statistic_image object with
multiple images (only the first 64 will display), which are stored as
columns in its .dat field.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name" colspan="2">Optional Inputs:</th></tr>
<tr class="field-odd field"><td>&nbsp;</td><td class="field-body"><dl class="first last docutils">
<dt><strong>orientation:</strong></dt>
<dd><p class="first last">can be followed by &#8216;saggital&#8217;, &#8216;axial&#8217;, or &#8216;coronal&#8217;</p>
</dd>
<dt><strong>slice_mm:</strong></dt>
<dd><p class="first last">is followed by the mm coord of the slice to display; default = 0</p>
</dd>
<dt><strong>nimgs:</strong></dt>
<dd><p class="first last">can be followed by the number of images to display, 1:nimgs</p>
</dd>
<dt><strong>names:</strong></dt>
<dd><p class="first last">is followed by a cell array of names for the images.</p>
</dd>
<dt><strong>color:</strong></dt>
<dd><p class="first last">is followed by color vector or string specification. default is
color-mapped with split colors (hot/cool) for pos and neg effects.</p>
</dd>
<dt><strong>outline:</strong></dt>
<dd><p class="first last">is followed by a color vector for outline around blobs.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p>The output, o, is an fmridisplay object.</p>
<p>This function uses fmridisplay objects, and may be memory-intensive for
older computers.</p>
<p><em>Common Errors:</em></p>
<p>This function uses the volInfo.cluster field. If you create a mask in an
ad hoc way, this field may not be updated.  use this to fix:</p>
<blockquote>
<div><ul class="simple">
<li>mask = reparse_contiguous(mask);</li>
</ul>
</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Examples:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>slices(dat);
slices(dat, &#39;orientation&#39;, &#39;axial&#39;);
slices(dat, &#39;slice&#39;, -5);                 % display sagg at x = -5
o = slices(dat, &#39;names&#39;, terms); % use &#39;terms&#39; var as names

o2 = slices(all_chi2_images, &#39;orientation&#39;, &#39;saggital&#39;, &#39;slice&#39;, 0);
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="&#64;image_vector.surface">
<code class="descclassname">&#64;image_vector.</code><code class="descname">surface</code><span class="sig-paren">(</span><em>obj</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@image_vector.surface" title="Permalink to this definition">¶</a></dt>
<dd><p>[all_surf_handles, pcl, ncl] = surface(obj)</p>
<dl class="docutils">
<dt><em>Usage:</em></dt>
<dd><ul class="first last simple">
<li>[all_surf_handles, pcl, ncl] = surface(r, [&#8216;cutaways&#8217;, any optional inputs to surface_cutaway])</li>
</ul>
</dd>
</dl>
<p>This function uses region.surface to create surface figures.
See help region.surface for options.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Examples:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>% Create an initial surface plot from an fmri_data object:
han = surface(regionmasks{2});  

% Now add a second region in green:
cluster_surf(region(regionmasks{2}), {[0 1 0]}, han, 5);

% Use optional arguments taken by surface_cutaway:
poscm = colormap_tor([1 .3 0], [1 1 0]); % orange to yellow
[all_surf_handles, pcl, ncl] = surface(t, &#39;cutaway&#39;, &#39;ycut_mm&#39;, -30, &#39;pos_colormap&#39;, poscm, &#39;existingfig&#39;);
[all_surf_handles2, pcl, ncl] = surface(t, &#39;foursurfaces&#39;, &#39;pos_colormap&#39;, poscm, &#39;neg_colormap&#39;, negcm);
[all_surf_handles2, pcl, ncl] = surface(t, &#39;foursurfaces&#39;, &#39;existingfig&#39;, &#39;color_upperboundpercentile&#39;, 95, &#39;color_lowerboundpercentile&#39;, 5, &#39;neg_colormap&#39;, colormap_tor([0 0 1], [.3 0 .5]));

% Use mediation_brain_surface_figs and re-make colors
all_surf_handles = mediation_brain_surface_figs([]);
surface(t2, &#39;cutaway&#39;, &#39;surface_handles&#39;, all_surf_handles, &#39;color_upperboundpercentile&#39;, 95, &#39;color_lowerboundpercentile&#39;, 5, &#39;neg_colormap&#39;, colormap_tor([0 0 1], [.2 0 .5]));
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="&#64;image_vector.threshold">
<code class="descclassname">&#64;image_vector.</code><code class="descname">threshold</code><span class="sig-paren">(</span><em>obj</em>, <em>input_threshold</em>, <em>thresh_type</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@image_vector.threshold" title="Permalink to this definition">¶</a></dt>
<dd><p>Threshold image_vector (or fmri_data or fmri_obj_image) object based on
raw threshold values. For statistical thresholding, convert to a
statistic_image object and see the threshold method for that object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>obj = threshold(obj, input_threshold, thresh_type, [optional arguments])
</pre></div>
</div>
<p>This is a method for an image_vector object</p>
<p>Thresholding is not reversible. For statistic_image objects it is.</p>
<dl class="docutils">
<dt>For objects: Type methods(object_name) for a list of special commands</dt>
<dd>Type help object_name.method_name for help on specific
methods.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Inputs:</th><td class="field-body"><dl class="first docutils">
<dt><strong>obj:</strong></dt>
<dd><p class="first last">image_vector object</p>
</dd>
<dt><strong>input_threshold:</strong></dt>
<dd><p class="first last">Vector of 2 values defining data value bounds at which
to threshold, e.g., [0 Inf] or [-3 3]</p>
</dd>
<dt><strong>thresh_type:</strong></dt>
<dd><p class="first last">String: &#8216;raw-between&#8217; or &#8216;raw-outside&#8217;</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Optional Inputs:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body"><p class="first">Argument or argument followed by value:</p>
<dl class="docutils">
<dt><strong>k:</strong></dt>
<dd><p class="first last">Followed by extent threshold cluster size, default = 1</p>
</dd>
<dt><strong>trim_mask:</strong></dt>
<dd><p class="first last">Reduce the mask in obj.voInfo based on thresholding</p>
</dd>
<dt><strong>noverbose:</strong></dt>
<dd><p class="first last">Suppress verbose output</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Outputs:</th><td class="field-body"><dl class="first docutils">
<dt><strong>obj:</strong></dt>
<dd><p class="first last">thresholded image_vector object</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Examples:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>% Retain positive values, cluster extent &gt; 100 voxels
obj = threshold(obj, [0 Inf], &#39;raw-between&#39;, &#39;k&#39;, 100)

% Retain voxels with absolute value &gt; 3
obj = threshold(obj, [-3 3], &#39;raw-outside&#39;)
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">See also:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<p>statistic_image.threshold, statistic_image.multi_threshold</p>
</dd></dl>

<dl class="function">
<dt id="&#64;image_vector.trim_mask">
<code class="descclassname">&#64;image_vector.</code><code class="descname">trim_mask</code><span class="sig-paren">(</span><em>obj</em><span class="sig-paren">)</span><a class="headerlink" href="#@image_vector.trim_mask" title="Permalink to this definition">¶</a></dt>
<dd><p>Exclude empty voxels from mask information in obj.volInfo structure, and re-make obj.volInfo</p>
</dd></dl>

<dl class="function">
<dt id="&#64;image_vector.union">
<code class="descclassname">&#64;image_vector.</code><code class="descname">union</code><span class="sig-paren">(</span><em>dat1</em>, <em>dat2</em>, <em>outputname</em><span class="sig-paren">)</span><a class="headerlink" href="#@image_vector.union" title="Permalink to this definition">¶</a></dt>
<dd><p>Union and intersection masks for two image_vector objects</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>[dat_union, dat_intersection] = union(dat1, dat2, outputname)

 dat = union(dat1, dat2, outputname)
 outputname = character array name for union image
               INCLUDE .img at the end.
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="&#64;image_vector.write">
<code class="descclassname">&#64;image_vector.</code><code class="descname">write</code><span class="sig-paren">(</span><em>obj</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@image_vector.write" title="Permalink to this definition">¶</a></dt>
<dd><p>Write an image_vector object to an Analyze image.
Option to write thresholded image, for statistic_image objects.</p>
<p>obj.dat should contain data, with one COLUMN for each 3-D frame in the
4-D image to be written.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>write(obj)  -&gt; writes to the image(s) specified in obj.fullpath
write(obj, &#39;thresh&#39;) -&gt; for statistic_image objects, writes thresholded
write(obj, &#39;fname&#39;, &#39;~/Documents/test.nii&#39;)  -&gt; writes the image(s) to specific path
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name" colspan="2">Optional Inputs:</th></tr>
<tr class="field-odd field"><td>&nbsp;</td><td class="field-body"><dl class="first docutils">
<dt><strong>mni:</strong></dt>
<dd><p class="first last">resample image to standard MNI FOV (91x109x91)
uses mri_data.resample_space</p>
</dd>
<dt><strong>keepdt:</strong></dt>
<dd><p class="first last">output image will be keep original data type (default = float32)</p>
</dd>
<dt><strong>fname:</strong></dt>
<dd><p class="first last">writes out image to specific file name.  &#8216;fname&#8217; must be
followed by image name with path</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Examples:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>% If m is an image_vector object m.X(m.X &lt; .12) = 0; % apply an 
% arbitrary but reasonable custom threshold
orthviews(m);

% write the thresholded image to disk:
anatmeanname = &#39;mean_gray_matter_mask.img&#39;;
m.filename = anatmeanname;
m.fullpath = fullfile(maskdir, anatmeanname);
write(m)
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="module-&#64;region">
<span id="region"></span><h1>region<a class="headerlink" href="#module-@region" title="Permalink to this headline">¶</a></h1>
<dl class="function">
<dt id="&#64;region.check_extracted_data">
<code class="descclassname">&#64;region.</code><code class="descname">check_extracted_data</code><span class="sig-paren">(</span><em>cl</em><span class="sig-paren">)</span><a class="headerlink" href="#@region.check_extracted_data" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Checks the data, just in case of space/programming issues, </dt>
<dd>by re-extracting the region average data from 5 random regions 
using spm_get_data.m, and compares it to the already-saved values</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Inputs:</th><td class="field-body"><blockquote class="first">
<div><dl class="docutils">
<dt><strong>cl:</strong></dt>
<dd><p class="first last">must be a valid region object (see region.m)
and cl(1).source_images must still be on the path.</p>
</dd>
</dl>
</div></blockquote>
<p class="last">You should not need to run this regularly &#8211; but you should if you
suspect things have gone awry.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="&#64;region.extract_data">
<code class="descclassname">&#64;region.</code><code class="descname">extract_data</code><span class="sig-paren">(</span><em>r</em>, <em>data_obj</em><span class="sig-paren">)</span><a class="headerlink" href="#@region.extract_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Extract data from image_vector object (data_obj) for voxels specified
by a region object (r). Returns extracted data and averages.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="n">region_obj</span> <span class="o">=</span> <span class="n">extract_data</span><span class="p">(</span><span class="n">region_obj</span><span class="p">,</span> <span class="n">data_obj</span><span class="p">)</span>
</pre></div>
</div>
<p>Type methods(region) for a list of special commands for region object
Type help object_name.method_name for help on specific methods.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Features:</th><td class="field-body">data_obj does not have to be in the same space, uses mm coordinates</td>
</tr>
</tbody>
</table>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Inputs:</th><td class="field-body"><dl class="first docutils">
<dt><strong>r:</strong></dt>
<dd><p class="first last">a region object</p>
</dd>
<dt><strong>data_obj:</strong></dt>
<dd><p class="first last">an image_vector or fmri_data object to extract data from
does not have to be in the same space, uses mm coordinates</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Outputs:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>r:</strong></dt>
<dd><p class="first last">a region object, with data attached</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="&#64;region.merge">
<code class="descclassname">&#64;region.</code><code class="descname">merge</code><span class="sig-paren">(</span><em>cl</em>, <em>wh_merge</em><span class="sig-paren">)</span><a class="headerlink" href="#@region.merge" title="Permalink to this definition">¶</a></dt>
<dd><p>Merge two or more regions together in a region object.
Combines fields from all clusters in the named series with the first one
in the series.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>wh_merge = [3 4];
cl = merge(cl, wh_merge)
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="&#64;region.posneg_separate">
<code class="descclassname">&#64;region.</code><code class="descname">posneg_separate</code><span class="sig-paren">(</span><em>cl</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@region.posneg_separate" title="Permalink to this definition">¶</a></dt>
<dd><p>Separate a region object (cl) into clusters with positive and negative
peak values, based on max (peak) value in .val or .Z field (default =
val)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="p">[</span><span class="n">pcl</span><span class="p">,</span> <span class="n">ncl</span><span class="p">]</span> <span class="o">=</span> <span class="n">posneg_separate</span><span class="p">(</span><span class="n">cl</span><span class="p">,</span> <span class="p">[</span><span class="s">&#39;Z&#39;</span><span class="p">])</span>
</pre></div>
</div>
<p>Returns pcl and ncl, region structures with positive- and negative-valued
peaks, respectively, copied from the original cl input.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Optional Input:</th><td class="field-body"><dl class="first docutils">
<dt><strong>Z:</strong></dt>
<dd><p class="first last">To use .Z field</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Note:</th><td class="field-body"><p class="first last">You may have to use reparse_continguous to get this to work right.</p>
</td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="n">r</span> <span class="o">=</span> <span class="n">reparse_continguous</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>
<span class="p">[</span><span class="n">pcl</span><span class="p">,</span> <span class="n">ncl</span><span class="p">]</span> <span class="o">=</span> <span class="n">posneg_separate</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="&#64;region.region2imagevec">
<code class="descclassname">&#64;region.</code><code class="descname">region2imagevec</code><span class="sig-paren">(</span><em>cl</em><span class="sig-paren">)</span><a class="headerlink" href="#@region.region2imagevec" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a region object to an image_vector object, replacing the voxels
and reconstructing as much info as possible.</p>
<p>The .dat field of the new &#8220;ivecobj&#8221; is made from the cl.all_data field.
if this is empty, uses cl.val field, then cl.Z as a backup.
Mask information is available in ivecobj.volInfo.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="n">ivecobj</span> <span class="o">=</span> <span class="n">region2imagevec</span><span class="p">(</span><span class="n">cl</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="&#64;region.region2imagevec2tmp">
<code class="descclassname">&#64;region.</code><code class="descname">region2imagevec2tmp</code><span class="sig-paren">(</span><em>cl</em><span class="sig-paren">)</span><a class="headerlink" href="#@region.region2imagevec2tmp" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a region object to an image_vector object, replacing the voxels
and reconstructing as much info as possible.</p>
<p>The .dat field of the new &#8220;ivecobj&#8221; is made from the cl.all_data field.
if this is empty, uses cl.val field, then cl.Z as a backup.
Mask information is available in ivecobj.volInfo.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="n">ivecobj</span> <span class="o">=</span> <span class="n">region2imagevec</span><span class="p">(</span><span class="n">cl</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="&#64;region.region2struct">
<code class="descclassname">&#64;region.</code><code class="descname">region2struct</code><span class="sig-paren">(</span><em>cl</em><span class="sig-paren">)</span><a class="headerlink" href="#@region.region2struct" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a region object to a simple structure, primarily for
compatibility with other, older CANlab tools.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">See also:</th><td class="field-body">cluster2region, for the reverse transformation</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="&#64;region.reparse_continguous">
<code class="descclassname">&#64;region.</code><code class="descname">reparse_continguous</code><span class="sig-paren">(</span><em>cl</em><span class="sig-paren">)</span><a class="headerlink" href="#@region.reparse_continguous" title="Permalink to this definition">¶</a></dt>
<dd><p>Re-define regions in region object based on contiguous blobs</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="n">clout</span> <span class="o">=</span> <span class="n">reparse_continguous</span><span class="p">(</span><span class="n">cl</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="&#64;region.subdivide_by_atlas">
<code class="descclassname">&#64;region.</code><code class="descname">subdivide_by_atlas</code><span class="sig-paren">(</span><em>r</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@region.subdivide_by_atlas" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>r = subdivide_by_atlas(r, [atlas name])
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Inputs:</th><td class="field-body"><dl class="first docutils">
<dt><strong>r:</strong></dt>
<dd><p class="first last">a region object, defined using region(mask)</p>
</dd>
<dt><strong>atlas name:</strong></dt>
<dd><p class="first last">Optional mask image with integer codes defining in-mask
regions.  Default is &#8216;atlas_labels_combined.img&#8217;</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Output:</th><td class="field-body"><p class="first">A region object with separate clusters for each contiguous blob,
subdivided by regions labeled in atlas.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>r = subdivide_by_atlas(r);
r(cat(1, r.numVox) &lt; 20) = []; % get rid of small regions
cluster_orthviews(r, &#39;unique&#39;);
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="&#64;region.subdivide_by_local_max">
<code class="descclassname">&#64;region.</code><code class="descname">subdivide_by_local_max</code><span class="sig-paren">(</span><em>r</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@region.subdivide_by_local_max" title="Permalink to this definition">¶</a></dt>
<dd><p>Subdivide regions into sub-regions based on local peak Z-scores/maxima</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="n">subregions</span> <span class="o">=</span> <span class="n">subdivide_by_local_max</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="p">[</span><span class="s">&#39;mm_distance&#39;</span><span class="p">,</span> <span class="n">value</span><span class="p">],</span> <span class="p">[</span><span class="s">&#39;noorthviews&#39;</span><span class="p">])</span>
</pre></div>
</div>
<dl class="docutils">
<dt>For objects: Type methods(object_name) for a list of special commands</dt>
<dd>Type help object_name.method_name for help on specific
methods.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name" colspan="2">Optional Inputs:</th></tr>
<tr class="field-odd field"><td>&nbsp;</td><td class="field-body"><dl class="first docutils">
<dt><strong>mm_distance:</strong></dt>
<dd><p class="first last">Followed by mm distance minimum for dividing subclusters</p>
</dd>
<dt><strong>noorthviews:</strong></dt>
<dd><p class="first last">Suppress display of orthviews</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Outputs:</th><td class="field-body"><dl class="first docutils">
<dt><strong>subregions:</strong></dt>
<dd><p class="first last">subdivided region object</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">See also:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<p>region.subdivide_by_atlas, subclusters_from_local_max, cluster_local_maxima</p>
</dd></dl>

<dl class="function">
<dt id="&#64;region.surface">
<code class="descclassname">&#64;region.</code><code class="descname">surface</code><span class="sig-paren">(</span><em>r</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@region.surface" title="Permalink to this definition">¶</a></dt>
<dd><p>Surface method for region object - renders blobs on multiple types of 3-D surface</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>[all_surf_handles, pcl, ncl] = surface(r, [&#39;cutaways&#39;, any optional inputs to surface_cutaway])
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Inputs:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>r:</strong></dt>
<dd><p class="first last">A region object</p>
</dd>
<dt><strong>cutaway:</strong></dt>
<dd><dl class="first last docutils">
<dt>String command for rendering cutaways instead of the default</dt>
<dd><ul class="first last simple">
<li>default is call to mediation_brain_surface_figs</li>
<li>cutaways calls surface_cutaway</li>
<li>all optional arguments are passed to surface_cutaway</li>
</ul>
</dd>
</dl>
</dd>
<dt><strong>rightsurface:</strong></dt>
<dd><dl class="first last docutils">
<dt>String command for rendering a right frontal cortical</dt>
<dd><p class="first last">view complementary to &#8216;cutaways&#8217;</p>
</dd>
</dl>
</dd>
<dt><strong>foursurfaces:</strong></dt>
<dd><p class="first last">Compact plots of four surfaces</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p>Other optional inputs to surface_cutaway
e.g., &#8216;pos_colormap&#8217;</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Outputs:</th><td class="field-body"><dl class="first docutils">
<dt><strong>all_surf_handles:</strong></dt>
<dd><p class="first last">surface patch handles</p>
</dd>
<dt><strong>pcl:</strong></dt>
<dd><p class="first last">region object with positive-only clusters</p>
</dd>
<dt><strong>ncl:</strong></dt>
<dd><p class="first last">region object with negative-only clusters</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>% Use surface(r), with optional arguments taken by surface_cutaway:
poscm = colormap_tor([1 .3 0], [1 1 0]); % orange to yellow
[all_surf_handles, pcl, ncl] = surface(r, &#39;cutaway&#39;, &#39;ycut_mm&#39;, -30, &#39;pos_colormap&#39;, poscm, &#39;existingfig&#39;);
[all_surf_handles2, pcl, ncl] = surface(r, &#39;foursurfaces&#39;, &#39;pos_colormap&#39;, poscm, &#39;neg_colormap&#39;, negcm);
[all_surf_handles2, pcl, ncl] = surface(r, &#39;foursurfaces&#39;, &#39;existingfig&#39;, &#39;color_upperboundpercentile&#39;, 95, &#39;color_lowerboundpercentile&#39;, 5, &#39;neg_colormap&#39;, colormap_tor([0 0 1], [.4 0 .7]));

% use mediation_brain_surface_figs and re-make colors
all_surf_handles = mediation_brain_surface_figs([]);
surface(r, &#39;cutaway&#39;, &#39;surface_handles&#39;, all_surf_handles, &#39;color_upperboundpercentile&#39;, 95, &#39;color_lowerboundpercentile&#39;, 5, &#39;neg_colormap&#39;, colormap_tor([0 0 1], [.2 0 .5]));
</pre></div>
</div>
<p>:See also:*</p>
<p>surface_cutaway, cluster_surf, mediation_brain_surface_figs
..</p>
<blockquote>
<div>DEFAULTS AND INPUTS</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="&#64;region.table">
<code class="descclassname">&#64;region.</code><code class="descname">table</code><span class="sig-paren">(</span><em>cl</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@region.table" title="Permalink to this definition">¶</a></dt>
<dd><p>Print a table of all regions in a region object (cl)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>[poscl, negcl] = table(cl, [optional inputs])
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name" colspan="2">Optional inputs:</th></tr>
<tr class="field-odd field"><td>&nbsp;</td><td class="field-body"><dl class="first docutils">
<dt><strong>k:</strong></dt>
<dd><p class="first last">Print only regions with k or more contiguous voxels</p>
</dd>
<dt><strong>nosep:</strong></dt>
<dd><p class="first last">do not separate cl with pos and neg effects based on peak in .val</p>
</dd>
<dt><strong>names:</strong></dt>
<dd><p class="first last">name clusters before printing to table and output; saves in .shorttitle field</p>
</dd>
<dt><strong>forcenames:</strong></dt>
<dd><p class="first last">force naming of cl by removing existing names in .shorttitle field</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Outputs:</th><td class="field-body"><p class="first last">Returns region objects for cl with pos and neg effects, limited by size if entered
and named if entered as optional input</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-&#64;statistic_image">
<span id="statistic-image"></span><h1>statistic_image<a class="headerlink" href="#module-@statistic_image" title="Permalink to this headline">¶</a></h1>
<dl class="function">
<dt id="&#64;statistic_image.conjunction">
<code class="descclassname">&#64;statistic_image.</code><code class="descname">conjunction</code><span class="sig-paren">(</span><em>si1</em>, <em>si2</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@statistic_image.conjunction" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the conjunction of two statistic_images.  considers positive and
negative activations separately.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Inputs:</th><td class="field-body">Two thresholded statistic images.  Optional 3rd argument:  -1 to</td>
</tr>
</tbody>
</table>
<p>get only negative conjunction, or 1 to get only positive conjunction</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Output:</th><td class="field-body">A statistic_image with all voxels suprathreshold (in the same direction) in both input</td>
</tr>
</tbody>
</table>
<p>images.  Voxel values are set to 1 and -1, to indicate direction.</p>
</dd></dl>

<dl class="function">
<dt id="&#64;statistic_image.convert2mask">
<code class="descclassname">&#64;statistic_image.</code><code class="descname">convert2mask</code><span class="sig-paren">(</span><em>stats_image_obj</em><span class="sig-paren">)</span><a class="headerlink" href="#@statistic_image.convert2mask" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts each image in a statistic_image object into a mask object, based
on significant voxels in the .sig field.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="n">cl</span> <span class="o">=</span> <span class="n">region</span><span class="p">(</span><span class="n">convert2mask</span><span class="p">(</span><span class="n">timg</span><span class="p">),</span> <span class="n">group</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="&#64;statistic_image.multi_threshold">
<code class="descclassname">&#64;statistic_image.</code><code class="descname">multi_threshold</code><span class="sig-paren">(</span><em>dat</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@statistic_image.multi_threshold" title="Permalink to this definition">¶</a></dt>
<dd><p>Multiple threshold function for statistic_image object for visualization</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>[o2, sig, pcl, ncl] = multi_threshold(dat, [optional inputs])
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Inputs:</th><td class="field-body"><dl class="first docutils">
<dt><strong>dat:</strong></dt>
<dd><p class="first last">a statistic_image object</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Optional Inputs:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body"><dl class="first docutils">
<dt><strong>poscolors:</strong></dt>
<dd><p class="first last">followed by cell array of colors for positive values, one per thresh</p>
</dd>
<dt><strong>negcolors:</strong></dt>
<dd><p class="first last">followed by cell array of colors for negative values, one per thresh</p>
</dd>
<dt><strong>thresh:</strong></dt>
<dd><p class="first last">followed vector of p-value thresholds, one per thresh</p>
</dd>
<dt><strong>sizethresh:</strong></dt>
<dd><dl class="first last docutils">
<dt>followed by vector of cluster sizes, one per thresh</dt>
<dd><ul class="first last simple">
<li>this &#8216;prunes&#8217; by default, so sizes after first can be 1
voxel</li>
<li>Default thresholds: thresh = [.001 .005 .05],
10 voxels at .001, &#8220;pruned&#8221;</li>
</ul>
</dd>
</dl>
</dd>
<dt><strong>nodisplay:</strong></dt>
<dd><p class="first last">suppress fmridisplay</p>
</dd>
<dt><strong>o2:</strong></dt>
<dd><dl class="first last docutils">
<dt>followed by an existing fmridisplay object</dt>
<dd><ul class="first last simple">
<li>will remove blobs and re-use montages</li>
</ul>
</dd>
</dl>
</dd>
</dl>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Outputs:</th><td class="field-body"><dl class="first docutils">
<dt><strong>o2:</strong></dt>
<dd><p class="first last">handle to fmridisplay object created by default</p>
</dd>
<dt><strong>sig:</strong></dt>
<dd><dl class="first last docutils">
<dt>vector of significant voxels at each thresh, for each region</dt>
<dd><ul class="first simple">
<li>cell array of images in object with matrix of values</li>
</ul>
<p class="last">for each threshold</p>
</dd>
</dl>
</dd>
<dt><strong>pcl:</strong></dt>
<dd><dl class="first last docutils">
<dt>positive valued clusters cell, one cell per threshold</dt>
<dd><ul class="first last simple">
<li>FIRST image in object only</li>
<li>pass into mediation_brain_surface_figs.m</li>
</ul>
</dd>
</dl>
</dd>
<dt><strong>ncl:</strong></dt>
<dd><dl class="first last docutils">
<dt>positive valued clusters cell, one cell per threshold</dt>
<dd><ul class="first last simple">
<li>FIRST image in object only</li>
<li>pass into mediation_brain_surface_figs.m</li>
</ul>
</dd>
</dl>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Examples:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>[o2, sig, poscl, negcl] = multi_threshold(hr_intercept, &#39;nodisplay&#39;);
mediation_brain_surface_figs(poscl, negcl);

% Create empty montage set and (re)use it:
o2 = canlab_results_fmridisplay([], &#39;compact2&#39;, &#39;noverbose&#39;);
o2 = multi_threshold(out.t, &#39;o2&#39;, o2);
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">See also:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<p>mediation_brain_surface_figs, iimg_multi_threshold, mediation_brain_results</p>
</dd></dl>

<dl class="function">
<dt id="&#64;statistic_image.orthviews">
<code class="descclassname">&#64;statistic_image.</code><code class="descname">orthviews</code><span class="sig-paren">(</span><em>image_obj</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@statistic_image.orthviews" title="Permalink to this definition">¶</a></dt>
<dd><p>Orthviews display (SPM) for CANlab object</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>cl = orthviews(image_object)

% OR

cl = orthviews(image_object, handle_number of existing orthviews)
</pre></div>
</div>
<p>Output is clusters structure (see also region.m)</p>
<p>Pass in &#8216;largest_region&#8217; to center the orthviews on the largest region in the  image</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>% T-test, Construct a stats_image object, threshold and display:
statsimg = ttest(fmridat, .001, &#39;unc&#39;);

% Re-threshold and display:
statsimg = threshold(statsimg, .000001, &#39;unc&#39;);
orthviews(statsimg);

statsimg = threshold(statsimg, .01, &#39;fdr&#39;);
orthviews(statsimg);

% Create an orthviews and view at multiple thresholds in different panes:
overlay = which(&#39;SPM8_colin27T1_seg.img&#39;);
spm_check_registration(repmat(overlay, n, 1));
statsimg = ttest(fmridat);
statsimg = threshold(statsimg, .001, &#39;unc&#39;);
orthviews(statsimg, &#39;handle&#39;, 1);

statsimg = threshold(statsimg, .000001, &#39;unc&#39;);
orthviews(statsimg, &#39;handle&#39;, 2);
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">See also:</th><td class="field-body">statistic_image.multi_threshold</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="&#64;statistic_image.reparse_contiguous">
<code class="descclassname">&#64;statistic_image.</code><code class="descname">reparse_contiguous</code><span class="sig-paren">(</span><em>obj</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@statistic_image.reparse_contiguous" title="Permalink to this definition">¶</a></dt>
<dd><p>Re-construct list of contiguous voxels in an image based on in-image
voxel coordinates.  Coordinates are taken from obj.volInfo.xyzlist.
Results are saved in obj.volInfo.cluster.
xyzlist can be generated from iimg_read_img, and is done automatically by
object-oriented fMRI image classes (fmri_image, image_vector,
statistic_image)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="n">obj</span> <span class="o">=</span> <span class="n">reparse_contiguous</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="p">[</span><span class="s">&#39;nonempty&#39;</span><span class="p">])</span>
</pre></div>
</div>
<p>If &#8216;nonempty&#8217; is entered as an optional argument, will use only voxels
that are non-zero, non-nan in the first column of obj.dat.</p>
<p>The statistic_image object version of reparse_contiguous uses 
the significance of the first image in the object (obj.sig(:, 1)) as a
filter as well, so clustering will be based on the latest threshold applied.
it is not usually necessary to enter &#8216;nonempty&#8217;.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>% Given timg, a statistic_image object:
test = reparse_contiguous(timg, &#39;nonempty&#39;);
cl = region(test, &#39;contiguous_regions&#39;);
cluster_orthviews(cl, &#39;unique&#39;)
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="&#64;statistic_image.select_one_image">
<code class="descclassname">&#64;statistic_image.</code><code class="descname">select_one_image</code><span class="sig-paren">(</span><em>obj</em>, <em>wh</em><span class="sig-paren">)</span><a class="headerlink" href="#@statistic_image.select_one_image" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Inputs:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>obj:</strong></dt>
<dd><p class="first last">A statistic_image object</p>
</dd>
<dt><strong>wh:</strong></dt>
<dd><p class="first last">An integer for which image in a series of images stored in obj you want</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="&#64;statistic_image.threshold">
<code class="descclassname">&#64;statistic_image.</code><code class="descname">threshold</code><span class="sig-paren">(</span><em>stats_image_obj</em>, <em>input_threshold</em>, <em>thresh_type</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@statistic_image.threshold" title="Permalink to this definition">¶</a></dt>
<dd><p>Threshold statistic_image object based on statistical threshold values.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>stats_image_obj = threshold(stats_image_obj, pvalthreshold or other thresh, thresh_type, [&#39;k&#39;, extent_thresh])
</pre></div>
</div>
<p>This is a method for an statistic_image object.
Thresholding is reversible.</p>
<dl class="docutils">
<dt>For objects: Type methods(object_name) for a list of special commands</dt>
<dd>Type help object_name.method_name for help on specific
methods.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Inputs:</th><td class="field-body"><dl class="first docutils">
<dt><strong>stats_image_obj:</strong></dt>
<dd><p class="first last">statistic_image object</p>
</dd>
<dt><strong>input_threshold:</strong></dt>
<dd><p class="first last">[pvalthreshold or other thresh]
A numeric value corresponding to the threshold desired.
Either a p-value or a range of raw values, depending on the threshold
type.</p>
</dd>
<dt><strong>thresh_type:</strong></dt>
<dd><dl class="first last docutils">
<dt>Threshold type which can be one of:</dt>
<dd><ul class="first last simple">
<li>&#8216;fdr&#8217; : FDR-correct based on p-values already stored in image .p field</li>
<li>&#8216;fwe&#8217; : FWE-correct; not implemented</li>
<li>&#8216;bfr&#8217; : Bonferroni correction (FWE).</li>
<li>&#8216;unc&#8217; : Uncorrected p-value threshold: p-value, e.g., .05 or .001</li>
<li>&#8216;raw-between&#8217; : threshold raw image values; save those &gt; input_threshold(1) and &lt; input_threshold(2)</li>
<li>&#8216;raw-outside&#8217; : threshold raw image values; save those &lt; input_threshold(1) or &gt; input_threshold(2)</li>
</ul>
</dd>
</dl>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Optional Inputs:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body"><dl class="first docutils">
<dt><strong>k:</strong></dt>
<dd><p class="first last">Followed by cluster extent in voxels: extent-based thresholding of any of the above</p>
</dd>
<dt><strong>noverbose:</strong></dt>
<dd><p class="first last">Suppress verbose output</p>
</dd>
<dt><strong>mask:</strong></dt>
<dd><dl class="first last docutils">
<dt>Followed by name of mask or fmri_mask_image object</dt>
<dd><ul class="first last simple">
<li>this will affect corrected significance levels</li>
</ul>
</dd>
</dl>
</dd>
</dl>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Outputs:</th><td class="field-body"><dl class="first docutils">
<dt><strong>stats_image_obj:</strong></dt>
<dd><p class="first last">thresholded statistic_image object</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>% Retain sig pos or neg results at p &lt; .001 uncorrected, cluster extent &gt;= 100 voxels
obj = threshold(obj, .001, &#39;unc&#39;, &#39;k&#39;, 100)

% Retain sig pos or neg results at q &lt; .05 FDR, cluster extent &gt;= 10 voxels
obj = threshold(obj, .05, &#39;fdr&#39;, &#39;k&#39;, 10)

% Retain voxels with absolute statistic/data value &gt; 3
obj = threshold(obj, [-3 3], &#39;raw-outside&#39;)

dat = threshold(dat, 0.001, &#39;unc&#39;, &#39;k&#39;, 35, &#39;mask&#39;, which(&#39;scalped_avg152T1_graymatter_smoothed.img&#39;));
dat = threshold(dat, 0.001, &#39;unc&#39;, &#39;k&#39;, 35, &#39;mask&#39;, maskobj);
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">See also:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<p>image_vector.threshold, statistic_image.multi_threshold</p>
</dd></dl>

</div>
<div class="section" id="cluster-contig-region-tools">
<h1>Cluster_contig_region_tools<a class="headerlink" href="#cluster-contig-region-tools" title="Permalink to this headline">¶</a></h1>
<span class="target" id="module-Cluster_contig_region_tools"></span><dl class="function">
<dt id="Cluster_contig_region_tools.anat_subclusters">
<code class="descclassname">Cluster_contig_region_tools.</code><code class="descname">anat_subclusters</code><span class="sig-paren">(</span><em>cl</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#Cluster_contig_region_tools.anat_subclusters" title="Permalink to this definition">¶</a></dt>
<dd><p>Clusters voxels within &#8216;clusters&#8217; structure based on anatomical locations
in space.  Outputs subgroups of smaller clusters.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>clout = anat_subclusters(cl,[resume at],[output cl to resume])
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="Cluster_contig_region_tools.cluster2region">
<code class="descclassname">Cluster_contig_region_tools.</code><code class="descname">cluster2region</code><span class="sig-paren">(</span><em>cl</em><span class="sig-paren">)</span><a class="headerlink" href="#Cluster_contig_region_tools.cluster2region" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform a CANlab/SCANlab &#8220;clusters&#8221; structure into a region object, the
standard in 2011 toolbox functions and beyond.</p>
</dd></dl>

<dl class="function">
<dt id="Cluster_contig_region_tools.cluster2subclusters">
<code class="descclassname">Cluster_contig_region_tools.</code><code class="descname">cluster2subclusters</code><span class="sig-paren">(</span><em>cl_in</em>, <em>class</em><span class="sig-paren">)</span><a class="headerlink" href="#Cluster_contig_region_tools.cluster2subclusters" title="Permalink to this definition">¶</a></dt>
<dd><p>Take a single cluster cl_in and separate into subclusters based on
vector of integers class</p>
<p>Class must code unique subclusters subcluster order is only preserved
if class contains all integers from 1 to nclasses:</p>
<p>i.e., class 3 will only be in subcluster 3 if there are no missing class
numbers in class</p>
</dd></dl>

<dl class="function">
<dt id="Cluster_contig_region_tools.cluster_close_enough">
<code class="descclassname">Cluster_contig_region_tools.</code><code class="descname">cluster_close_enough</code><span class="sig-paren">(</span><em>cl_match_to</em>, <em>cl_match</em>, <em>mind</em><span class="sig-paren">)</span><a class="headerlink" href="#Cluster_contig_region_tools.cluster_close_enough" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds whether each cluster center in cl_match is within mind mm of a cluster
center in cl_match_to.</p>
<p>Useful for selecting a list of clusters that are not close to another
list to, e.g., make a table of.  or this could be used to find clusters
in a set of correlated clusters that are close to centers in activated
clsuters.</p>
</dd></dl>

<dl class="function">
<dt id="Cluster_contig_region_tools.cluster_export_pngs">
<code class="descclassname">Cluster_contig_region_tools.</code><code class="descname">cluster_export_pngs</code><span class="sig-paren">(</span><em>cl</em>, <em>useexisting</em>, <em>overlay</em>, <em>xhairson</em><span class="sig-paren">)</span><a class="headerlink" href="#Cluster_contig_region_tools.cluster_export_pngs" title="Permalink to this definition">¶</a></dt>
<dd><p>Save png images of SPM orthviews windows for each cluster in a set (cl
structure)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="n">cl</span> <span class="o">=</span> <span class="n">cluster_export_pngs</span><span class="p">(</span><span class="n">cl</span><span class="p">,[</span><span class="n">useexisting</span><span class="p">],[</span><span class="n">overlayimagename</span><span class="p">],[</span><span class="n">xhairson</span><span class="p">])</span>
</pre></div>
</div>
<p>names from cl(x).shorttitle are used
useexisting is optional: 1 uses existing orthviews display (default), 0 creates a
new one with the clusters</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>% use existing
cluster_export_pngs(cl, 1, EXPT.overlay);
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="Cluster_contig_region_tools.cluster_find_index">
<code class="descclassname">Cluster_contig_region_tools.</code><code class="descname">cluster_find_index</code><span class="sig-paren">(</span><em>cl</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#Cluster_contig_region_tools.cluster_find_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Ever see an interesting blob when visualizing a clusters structure, but
don&#8217;t know which index number in the clusters structure vector it
corresponds to?</p>
<p>With this function, find the index number of the closest cluster to one you specify
graphically by clicking on.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>function [wh_cluster, min_distance] = cluster_find_index(cl, [keep display flag, 1/0])
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="Cluster_contig_region_tools.cluster_interp">
<code class="descclassname">Cluster_contig_region_tools.</code><code class="descname">cluster_interp</code><span class="sig-paren">(</span><em>cl</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#Cluster_contig_region_tools.cluster_interp" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Interpolates voxels and mm in a clusters structure (cl) to match the</dt>
<dd><p class="first">image dimensions and voxel sizes of a target mask image.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>function cl = cluster_interp(cl,maskimg,[keep sep clusters flag])
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="last highlight-python"><div class="highlight"><pre>cl = cluster_interp(cl,maskimg,1);

%default mask 2 x 2 x 2, SPM2 default:
cl = cluster_interp(cl,[],1);
</pre></div>
</div>
</dd>
</dl>
<p>maskimg = which(&#8216;scalped_avg152T1_graymatter_smoothed.img&#8217;);</p>
</dd></dl>

<dl class="function">
<dt id="Cluster_contig_region_tools.cluster_intersection">
<code class="descclassname">Cluster_contig_region_tools.</code><code class="descname">cluster_intersection</code><span class="sig-paren">(</span><em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#Cluster_contig_region_tools.cluster_intersection" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the intersection of the clusters passed in.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>intersect_cl = cluster_intersection(cl1, cl2, cl3, ...)

% simple intersection
cl = cluster_intersection(robust0001_poscl(2), robust0002_poscl(4), robust0003_poscl(17));

% intersection between sets of clusters
% alternatively, see cluster_set_intersection.m
cl = cluster_intersection(clusters2CLU(robust0001_poscl), clusters2CLU(robust0002_poscl));
</pre></div>
</div>
<dl class="docutils">
<dt>Note:</dt>
<dd>Only works with single clusters. To compute the intersection between sets of clusters,
use cluster_set_intersection()</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="Cluster_contig_region_tools.cluster_local_maxima">
<code class="descclassname">Cluster_contig_region_tools.</code><code class="descname">cluster_local_maxima</code><span class="sig-paren">(</span><em>cl</em>, <em>dthresh</em>, <em>verbose</em><span class="sig-paren">)</span><a class="headerlink" href="#Cluster_contig_region_tools.cluster_local_maxima" title="Permalink to this definition">¶</a></dt>
<dd><p>Clusters are chosen so that they must be at least dthresh mm apart
default is 10 mm</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>[xyz, XYZmm, Z, class] = cluster_local_maxima(cl, [dthresh], [verbose])
</pre></div>
</div>
<p>verbose output: 1/0, default is 0</p>
<p>additional optional outputs (slower):</p>
<p>class: vector of integers for which subcluster this cluster belongs to</p>
</dd></dl>

<dl class="function">
<dt id="Cluster_contig_region_tools.cluster_set_intersection">
<code class="descclassname">Cluster_contig_region_tools.</code><code class="descname">cluster_set_intersection</code><span class="sig-paren">(</span><em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#Cluster_contig_region_tools.cluster_set_intersection" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the intersection of the sets of clusters passed in.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="n">intersect_cl</span> <span class="o">=</span> <span class="n">cluster_set_intersection</span><span class="p">(</span><span class="n">cls1</span><span class="p">,</span> <span class="n">cls2</span><span class="p">,</span> <span class="n">cls3</span><span class="p">,</span> <span class="o">...</span><span class="p">)</span>
<span class="n">cl</span> <span class="o">=</span> <span class="n">cluster_intersection</span><span class="p">(</span><span class="n">robust0001_poscls</span><span class="p">,</span> <span class="n">robust0002_poscls</span><span class="p">,</span> <span class="n">robust0003_poscls</span><span class="p">);</span>
</pre></div>
</div>
<dl class="docutils">
<dt>Note:</dt>
<dd>Designed for sets of clusters. To compute the intersection between individual clusters,
use cluster_intersection(). cluster_set_intersection will work, but is not needed.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="Cluster_contig_region_tools.cluster_table">
<code class="descclassname">Cluster_contig_region_tools.</code><code class="descname">cluster_table</code><span class="sig-paren">(</span><em>clusters</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#Cluster_contig_region_tools.cluster_table" title="Permalink to this definition">¶</a></dt>
<dd><p>Print output of clusters in table</p>
<p>Option to print text labels from Carmack atlas.</p>
<p>Database loading is done from talairach_info.mat which should be in the 
path.</p>
<p>To speed up performance, load talairach_info.mat in the base workspace or
calling function and include xyz, L3 and L5 as inputs to cluster_table.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>% create subclusters on the fly, prompt for labels
cluster_table(cl);

% no subclusters, no labels
cluster_table(cl, 0, 0);

% do subclusters, no labels
cluster_table(cl, 1, 0);

create subclusters on the fly, do labels
cluster_table(cl, 1, 1);

% 3 input variables following &#39;tal_info&#39; are interpreted as xyz, L3,
% and L5 from talairach_info.mat.
cluster_table(..., &#39;tal_info&#39;, xyz, L3, L5);

% loads labels from taldata.mat (Talairach database) instead of
% talairach_info.mat. Note that you should use the &#39;tal_info&#39; call
% above if xyz, L3, and L5 have already been loaded to theworkspace
% from taldata.mat. Also, if the talairach database is being used,
% your cl.XYZmm values MUST correspond to the TALAIRACH, NOT MNI,
% database, or the labels will be innaccurate.
cluster_table(..., &#39;talairach&#39;);

% print table to ASCII file, &#39;filename&#39;, instead of to the matlab
% command window.
cluster_table(..., &#39;writefile&#39;,&#39;filename&#39;);

% any set of inputs from above, also print clusters.myfield in output
cluster_table(..., &#39;myfield&#39;);
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="Cluster_contig_region_tools.cluster_table_successive_threshold">
<code class="descclassname">Cluster_contig_region_tools.</code><code class="descname">cluster_table_successive_threshold</code><span class="sig-paren">(</span><em>cl</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#Cluster_contig_region_tools.cluster_table_successive_threshold" title="Permalink to this definition">¶</a></dt>
<dd><p>Cluster table of a cell array of clusters cl{1} cl{2} etc.
Prints table of cl{1} and then any additional regions in cl{2:n} that are
not within 10 mm of a previously printed cluster</p>
<p>Also: merges clusters in set within 10 mm</p>
<p>Table titles are hard-coded to be consistent with meta-analysis toolbox right now</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="n">cl</span> <span class="o">=</span> <span class="n">cluster_table_successive_threshold</span><span class="p">(</span><span class="n">cl</span><span class="p">,[</span><span class="n">sizethr</span><span class="p">])</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>% Print a series of tables with custom fields:
cl = cluster_table_successive_threshold(cl,5,&#39;myfield1&#39;,&#39;myfield2&#39;)
</pre></div>
</div>
<p>Use <em>merge_nearby_clusters</em> and <em>subclusters_from_local_max</em>
or some other way to get clusters appropriately separated and distanced
before running.
see Meta_cluster_tools for code to run this for meta-analysis.</p>
</dd></dl>

<dl class="function">
<dt id="Cluster_contig_region_tools.clusters2CLU">
<code class="descclassname">Cluster_contig_region_tools.</code><code class="descname">clusters2CLU</code><span class="sig-paren">(</span><em>clusters</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#Cluster_contig_region_tools.clusters2CLU" title="Permalink to this definition">¶</a></dt>
<dd><p>Inputting an M matrix will transform the coordinates
by that M, to convert between voxel sizes, etc.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>function CLU = clusters2CLU(clusters,[opt] M)
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="Cluster_contig_region_tools.clusters2mask">
<code class="descclassname">Cluster_contig_region_tools.</code><code class="descname">clusters2mask</code><span class="sig-paren">(</span><em>cl</em>, <em>V</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#Cluster_contig_region_tools.clusters2mask" title="Permalink to this definition">¶</a></dt>
<dd><p>This function has 2 modes!  If V is a structure:</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>[m,V,cl] = clusters2mask(cl,V,[opt: write Z-scores])
</pre></div>
</div>
<p>Converts clusters structure to a mask image, given V structure with V.mat
field.  V.mat is an SPM mat file. V.dim is dims of image uses cl.XYZmm
m is mask img data, V is mask vol info.</p>
<p>Also replaces cl.XYZ (voxels)</p>
<p>If V is a vector of mask dimensions:
converts clusters to mask image using existing XYZ and dims of mask</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">See also:</th><td class="field-body">voxels2mask, for a faster function that uses XYZ voxel coords</td>
</tr>
<tr class="field-even field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>% Save an image file with just one cluster from a set (#7 in this ex.)
cl = mask2clusters(&#39;roi_group1.img&#39;);
V = spm_vol(&#39;roi_group1.img&#39;);  % we need .mat and .dim from this, or

% just dim
[m,V,cl] = clusters2mask(cl(7),struct(&#39;mat&#39;,cl(1).M,&#39;dim&#39;,V.dim));
%or
[m,V,cl] = clusters2mask(cl(7),V);

clusters2mask(cl,struct(&#39;mat&#39;,V.mat,&#39;dim&#39;,V.dim),0,&#39;spm2_hy.img&#39;);

%for SPM5:
clusters2mask(cl,struct(&#39;mat&#39;,V.mat,&#39;dim&#39;,V.dim, &#39;dt&#39;, V.dt),0,&#39;spm2_hy.img&#39;);
clusters2mask(cl,
struct(&#39;mat&#39;,MC_Setup.volInfo.mat,&#39;dim&#39;,MC_Setup.volInfo.dim, &#39;dt&#39;, MC_Setup.volInfo.dt),0,&#39;acc_roi_mask.img&#39;);
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="Cluster_contig_region_tools.image2clusters">
<code class="descclassname">Cluster_contig_region_tools.</code><code class="descname">image2clusters</code><span class="sig-paren">(</span><em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#Cluster_contig_region_tools.image2clusters" title="Permalink to this definition">¶</a></dt>
<dd><p>Menu-driven function for getting clusters from an image file (e.g., a
t-image)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>cl = image2clusters([overlay image name])
</pre></div>
</div>
<p>Can also return clusters active in two contrasts, sorted by increases in
both, decreases in both, inc in first, dec in first
useful for testing whether something is both activated and correlated!
e.g., see active_plus_corr_scatterplot_plugin</p>
<p>% :Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="p">[</span><span class="n">pospos</span><span class="p">,</span><span class="n">negneg</span><span class="p">,</span><span class="n">posneg</span><span class="p">,</span><span class="n">negpos</span><span class="p">]</span> <span class="o">=</span> <span class="n">image2clusters</span><span class="p">(</span><span class="n">overlay</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="Cluster_contig_region_tools.mask2clusters">
<code class="descclassname">Cluster_contig_region_tools.</code><code class="descname">mask2clusters</code><span class="sig-paren">(</span><em>P</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#Cluster_contig_region_tools.mask2clusters" title="Permalink to this definition">¶</a></dt>
<dd><p>Extracts clusters and con img data from mask</p>
<p>Use with <em>mask_intersection.m</em></p>
<p>To get clusters but not extract data, enter only one argument.</p>
<p>To get clusters and choose extraction imgs with the GUI, enter an empty [] 2nd argument.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>[clusters,CLU,subclusters] = mask2clusters(img mask file with voxels,[imgs to extract data from],[df])
</pre></div>
</div>
<p>DOES <em>NOT</em> CONVERT BETWEEN DIFFERENT VOXEL SIZES AND POSITIONS BETWEEN IMNAMES AND SPM/VOL STRUCTS</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">See also:</th><td class="field-body">roi_probe</td>
</tr>
</tbody>
</table>
<p>If no imgs are entered, Z-scores are values from mask</p>
<p>If df is entered, values in mask img are converted to Z-scores with spm_t2z.m</p>
<p>If extract img names are empty and df is entered, assume we&#8217;re using
values from mask as t-values and convert to Z-scores</p>
<p>WARNING: for spm2 compatibility, ABSOLUTE VALUES of voxel sizes are
returned; e.g., ignores analyze flipping in SPM2.</p>
<p>% Matlab 6.5/OSX bug gives seg fault or something if mask is too big.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>cl = mask2clusters(&#39;myimage.img&#39;,[img string mtx],[]); % no z-score
conversion, extracts data from [img string mtx]

cl = mask2clusters(&#39;rob_tmap_0002_filt_t_3-05_k10_neg.img&#39;)

% This one works with already-loaded image data and a mat matrix:
V = spm_vol(&#39;rob_tmap_0002_filt_t_3-05_k10_neg.img&#39;); dat = spm_read_vols(V);
cl = mask2clusters(dat,V.mat);
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="Cluster_contig_region_tools.mask2struct">
<code class="descclassname">Cluster_contig_region_tools.</code><code class="descname">mask2struct</code><span class="sig-paren">(</span><em>maskname</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#Cluster_contig_region_tools.mask2struct" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>function V = mask2struct(maskname,crit_t,cl_size)
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Inputs:</th><td class="field-body"><dl class="first docutils">
<dt><strong>maskname:</strong></dt>
<dd><p class="first last">name of spmT, con, or filtered image without .img extension,
in single quotes</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Optional Inputs:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body"><dl class="first docutils">
<dt><strong>crit_t, cl_size::</strong></dt>
<dd><p class="first last">critical t and cluster size at which to mask</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Outputs:</th><td class="field-body"><p class="first">structure compatible with SPM viewing and with cluster definition
algorithm tor_extract_rois</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>% to extract clusters:
[clusters] = tor_extract_rois(maskname,V,V);

% to display:
spm_image   (and choose anatomical)
spm_orthviews(&#39;AddBlobs&#39;,1,V.XYZ,V.Z,V.mat)
spm_orthviews(&#39;AddColouredBlobs&#39;,1,V.XYZ,V.Z,V.mat,[0 0 1])

% to overlay on Talairach atlas
fixed_TSU(clusters)
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="Cluster_contig_region_tools.merge_clusters">
<code class="descclassname">Cluster_contig_region_tools.</code><code class="descname">merge_clusters</code><span class="sig-paren">(</span><em>c2m</em>, <em>subcl</em><span class="sig-paren">)</span><a class="headerlink" href="#Cluster_contig_region_tools.merge_clusters" title="Permalink to this definition">¶</a></dt>
<dd><p>Function for synchronizing the field list of cluster structures
and merging them</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="n">subclusters</span> <span class="o">=</span> <span class="n">merge_clusters</span><span class="p">(</span><span class="n">clusters_to_match</span><span class="p">,</span> <span class="n">subclusters_to_change</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="Cluster_contig_region_tools.merge_nearby_clusters">
<code class="descclassname">Cluster_contig_region_tools.</code><code class="descname">merge_nearby_clusters</code><span class="sig-paren">(</span><em>cl</em>, <em>thr</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#Cluster_contig_region_tools.merge_nearby_clusters" title="Permalink to this definition">¶</a></dt>
<dd><p>Merge sets of clusters whose centers are all within thr mm of each other
uses parcel_complete_sets.m</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="n">newcl</span> <span class="o">=</span> <span class="n">merge_nearby_clusters</span><span class="p">(</span><span class="n">cl</span><span class="p">,</span> <span class="n">thr</span><span class="p">)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>% The command below runs the function recursively until all clusters are
% greater than thr mm apart
newcl = merge_nearby_clusters(cl, thr, &#39;recursive&#39;)
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="Cluster_contig_region_tools.subclusters_from_local_max">
<code class="descclassname">Cluster_contig_region_tools.</code><code class="descname">subclusters_from_local_max</code><span class="sig-paren">(</span><em>cl</em>, <em>dist_thresh</em><span class="sig-paren">)</span><a class="headerlink" href="#Cluster_contig_region_tools.subclusters_from_local_max" title="Permalink to this definition">¶</a></dt>
<dd><p>Breaks apart a cluster into smaller clusters</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="n">subcl</span> <span class="o">=</span> <span class="n">subclusters_from_local_max</span><span class="p">(</span><span class="n">cl</span><span class="p">,</span> <span class="n">dist_thresh</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="Cluster_contig_region_tools.xyz2clusters">
<code class="descclassname">Cluster_contig_region_tools.</code><code class="descname">xyz2clusters</code><span class="sig-paren">(</span><em>xyz</em>, <em>P</em><span class="sig-paren">)</span><a class="headerlink" href="#Cluster_contig_region_tools.xyz2clusters" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts a 3-column x, y, z list of mm coordinates to a clusters
structure given P, the filename of an analyze .img file to provide
dimensions and voxel sizes.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>function cl = xyz2clusters(xyz,P)
</pre></div>
</div>
<dl class="docutils">
<dt>Uses this info from the image:</dt>
<dd><ul class="first last simple">
<li>VOL.M     - spm-style mat matrix</li>
<li>VOL.VOX   - voxel sizes</li>
<li>SPM.Z     - now 1s; could stores values in the original image in clusters.Z</li>
</ul>
</dd>
<dt>The following is created internally:</dt>
<dd><ul class="first last simple">
<li>SPM.XYZmm - mm coords, you input these</li>
<li>SPM.XYZ   - voxel coords</li>
</ul>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-Data_extraction">
<span id="data-extraction"></span><h1>Data_extraction<a class="headerlink" href="#module-Data_extraction" title="Permalink to this headline">¶</a></h1>
<dl class="function">
<dt id="Data_extraction.canlab_maskstats">
<code class="descclassname">Data_extraction.</code><code class="descname">canlab_maskstats</code><span class="sig-paren">(</span><em>msks</em>, <em>imgs</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#Data_extraction.canlab_maskstats" title="Permalink to this definition">¶</a></dt>
<dd><p>Produces comparison of pattern mask and images
e.g., look at NPS pattern expression in set of beta images</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="n">MASKSTATS</span> <span class="o">=</span> <span class="n">canlab_maskstats</span><span class="p">(</span><span class="n">maskfiles</span><span class="p">,</span><span class="n">imgfiles</span><span class="p">,[</span><span class="n">options</span><span class="p">])</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Inputs:</th><td class="field-body"><dl class="first docutils">
<dt><strong>maskfiles:</strong></dt>
<dd><p class="first last">string or cellstring of mask filenames or fmri_data object</p>
</dd>
<dt><strong>imgfiles:</strong></dt>
<dd><p class="first last">string or cellstring of image filenames or fmri_data object</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Optional Inputs:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body"><dl class="first docutils">
<dt><strong>ts:</strong></dt>
<dd><p class="first">timeseries treatment: each string in imgfiles is assumed to be
a 4D file. Data will be returned with one column per time series and
one volume per row. If not all timeseries are same length, all will
be NaN-padded to the length of the longest timeseries.</p>
<p class="last">Note: does not work with imgfiles input as fmri_data object</p>
</dd>
<dt><strong>dir2cell:</strong></dt>
<dd><p class="first">will sort stats into cells based on directory containing the imgfile
they belong to such that each cell contains one directory&#8217;s worth of
stats which is a vector with a value for each imgfile.
:Examples:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># Input: a list of single trial betas for a set of subjects</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">filenames</span><span class="p">(</span><span class="s">&#39;sub*/*heat_trials*.img&#39;</span><span class="p">);</span>
<span class="n">ms</span> <span class="o">=</span> <span class="n">canlab_maskstats</span><span class="p">(</span><span class="s">&#39;nps&#39;</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="s">&#39;dot_product&#39;</span><span class="p">,</span><span class="s">&#39;dir2cell&#39;</span><span class="p">);</span>
</pre></div>
</div>
<p class="last">Output: includes the set of cells that are input to a mediation
analysis.</p>
</dd>
<dt><strong>keepzeros:</strong></dt>
<dd><p class="first last">don&#8217;t remove zeros from imgfiles before taking measurements</p>
</dd>
<dt><strong>keepzerosmask:</strong></dt>
<dd><p class="first last">don&#8217;t remove zeros from maskfiles before taking measurements</p>
</dd>
<dt><strong>single:</strong></dt>
<dd><p class="first last">leave data as single (DEFAULT: convert to double)</p>
</dd>
<dt><strong>trinarize:</strong></dt>
<dd><p class="first last">trinarize maskfile (set values larger than 0 to 1 and values less than
zero to -1)</p>
</dd>
<dt><strong>noreshape:</strong></dt>
<dd><p class="first last">don&#8217;t attempt to reshape results according to imgfiles array</p>
</dd>
<dt><strong>nobin:</strong></dt>
<dd><p class="first last">don&#8217;t binarize mask before extracting mean or std</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Note:</th><td class="field-body"><p class="first last">ts, dir2cell, and noreshape are mutually exclusive options</p>
</td>
</tr>
</tbody>
</table>
<p><strong>Built-In Masks</strong>
The following strings can be given as the maskfile argument to
call up built-in mask files:</p>
<blockquote>
<div><dl class="docutils">
<dt><strong>nps:</strong></dt>
<dd>weights_NSF_grouppred_cvpcr.img</dd>
<dt><strong>nps_thresh:</strong></dt>
<dd>weights_NSF_grouppred_cvpcr_FDR05.img</dd>
<dt><strong>nps_thresh_smooth:</strong></dt>
<dd>weights_NSF_grouppred_cvpcr_FDR05_smoothed_fwhm05.img</dd>
</dl>
</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name" colspan="2">Measure Options:</th></tr>
<tr class="field-odd field"><td>&nbsp;</td><td class="field-body"><dl class="first docutils">
<dt><strong>all:</strong></dt>
<dd><dl class="first last docutils">
<dt>add: mean, dot_product, centered_dot_product,</dt>
<dd><p class="first last">cosine_similarity, and correlation</p>
</dd>
</dl>
</dd>
<dt><strong>mean:</strong> (DEFAULT)</dt>
<dd><p class="first last">apply binarized mask to images and return means
mean(img .* abs(bin(mask)))</p>
</dd>
<dt><strong>std:</strong></dt>
<dd><p class="first last">apply binarized mask to images and return standard deviations
std(img .* abs(bin(mask)))</p>
</dd>
<dt><strong>dot_product:</strong></dt>
<dd><p class="first last">dot(mask, img)</p>
</dd>
<dt><strong>cosine_similarity:</strong></dt>
<dd><p class="first last">dot(mask, img) / (norm(mask) * norm(img))</p>
</dd>
<dt><strong>correlation:</strong></dt>
<dd><p class="first last">corr(mask, img)</p>
</dd>
<dt><strong>centered_dot_product:</strong></dt>
<dd><p class="first last">dot(mask-mean(mask), img-mean(img))</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Details:</th><td class="field-body"><ul class="first last simple">
<li>imgfiles are spatially resampled to maskfiles</li>
<li>voxels with zeros in maskfile are removed</li>
<li>in-mask voxels with zeros in imgfiles will generate warnings</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Data_extraction.cluster_tmask">
<code class="descclassname">Data_extraction.</code><code class="descname">cluster_tmask</code><span class="sig-paren">(</span><em>cl</em>, <em>tm</em>, <em>si</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#Data_extraction.cluster_tmask" title="Permalink to this definition">¶</a></dt>
<dd><p>Given clusters and a string name of a t-image,  finds voxels that exceed a
specified t-threshold</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="p">[</span><span class="n">cl</span><span class="p">,</span> <span class="n">varargout</span><span class="p">]</span> <span class="o">=</span> <span class="n">cluster_tmask</span><span class="p">(</span><span class="n">cl</span><span class="p">,</span> <span class="n">tm</span><span class="p">,</span> <span class="n">si</span><span class="p">,</span> <span class="n">varargin</span><span class="p">)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Inputs:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>cl:</strong></dt>
<dd><p class="first last">clusters</p>
</dd>
<dt><strong>tm:</strong></dt>
<dd><p class="first last">t-image</p>
</dd>
<dt><strong>si:</strong></dt>
<dd><p class="first last">subject index integer</p>
</dd>
<dt><strong>[dat]:</strong></dt>
<dd><p class="first last">cluster_barplot data structure</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p>creates new XYZ in the space of t-image using cl.XYZmm coordinates in mm.
Required fields of cl:  XYZmm</p>
<dl class="docutils">
<dt>Calculates and saves single-subject data avgd over voxels if:</dt>
<dd><ol class="first last upperalpha">
<li><dl class="first docutils">
<dt>cl.all_data field is present</dt>
<dd><p class="first last">THIS WORKS if all_data has individual subject contrast estimates
in it,  with rows as subjects and columns as voxels
indiv data saved in cl(region).timeseries(subject)</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>cl.raw_data is present</dt>
<dd><p class="first last">raw_data should be time x voxels x subjects,  a 3D matrix
see output of extract_raw_data.
indiv data saved in cl(region).indiv_timeseries(:, subject)</p>
</dd>
</dl>
</li>
</ol>
</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Note:</th><td class="field-body">Retains upper 50% of voxels; highest t-values</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Data_extraction.extract_contrast_data">
<code class="descclassname">Data_extraction.</code><code class="descname">extract_contrast_data</code><span class="sig-paren">(</span><em>P</em>, <em>clusters</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#Data_extraction.extract_contrast_data" title="Permalink to this definition">¶</a></dt>
<dd><p>This function does not plot,  but separates subclusters using pca / cluster_princomp.m
based on pattern across all conditions,  covariance (not correlation),</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="n">function</span> <span class="p">[</span><span class="n">clusters</span><span class="p">,</span> <span class="n">subcl</span><span class="p">]</span> <span class="o">=</span> <span class="n">extract_contrast_data</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">clusters</span><span class="p">)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Inputs:</th><td class="field-body"><dl class="first docutils">
<dt><strong>P:</strong></dt>
<dd><p class="first last">cell array of strings containing image file names (data extracted from these)</p>
</dd>
</dl>
<p><strong>clusters:</strong></p>
</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Optional Inputs:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body"><dl class="first docutils">
<dt><strong>subclusters:</strong></dt>
<dd><p class="first last">to get sub-clustering based on pca and clustering of voxels
add the string &#8216;subclusters&#8217; as an input argument</p>
</dd>
</dl>
<p><strong>cell array:</strong> of strings with condition names</p>
<dl class="docutils">
<dt><strong>split:</strong></dt>
<dd><p class="first">value is 1: to split into 2 plots (first half and last half of P)</p>
<p class="last">value is 2: to plot individual subjects over bars</p>
</dd>
<dt><strong>center:</strong></dt>
<dd><p class="first last">center parmeter values in plot (subtract row means)
this gives closer to correct &#8220;within subjects&#8221; error bars
and may be used when the overall parameter values have no meaning</p>
</dd>
<dt><strong>covs:</strong></dt>
<dd><p class="first last">followed by between-subject covariates (e.g.,  behavioral regressors)
plots remove these before plotting means and std. errors</p>
</dd>
<dt><strong>max:</strong></dt>
<dd><p class="first last">to make plots based on max z-values within region for each dataset P
not compatible with &#8216;split&#8217; and &#8216;center&#8217; (ignores these commands)
right now,  special for inhib - see also inhib2_cluster_barplot (good function)</p>
</dd>
<dt><strong>indiv:</strong></dt>
<dd><p class="first">to threshold based on individual t-statistics or contrast values</p>
<p class="last">FOLLOW with cell array of t-images or con images &#8211; usually,  there will be one cell,  with images 
for each subject in rows,  to define voxels for each ss.
BUT Tnames can be the same length as
contrast images,  one t-img per subject per contrast,  if
desired.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Outputs:</th><td class="field-body"><p class="first last">clusters struture,  with CONTRAST substructure added
substructure contains data extracted and image file names</p>
</td>
</tr>
</tbody>
</table>
<p>This program uses XYZmm millimeter coordinates in clusters to find voxels
So clusters and data files may have different dimensions.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Examples:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>cl = extract_contrast_data(EXPT.SNPM.P, cl, &#39;indiv&#39;, EXPT.FILES.Timgs{1});
cluster_barplot(EXPT.SNPM.P(7:12), clusters(2:3), {&#39;ObjE&#39; &#39;AttE&#39; &#39;InteractE&#39; &#39;ObjI&#39; &#39;AttI&#39; &#39;InteractI&#39;}, &#39;split&#39;)
[clusters, subclusters] = cluster_barplot(EXPT.SNPM.P(17:24), clusters, &#39;subclusters&#39;, &#39;split&#39;)
RS2_8vs2_placeboCP = cluster_barplot(EXPT.SNPM.P([8 10 12 14 16]), RS2meta, &#39;indiv&#39;, T);
</pre></div>
</div>
<p>also see mask2clusters.m,  a simpler version that just extracts clusters from a mask file.</p>
</dd></dl>

<dl class="function">
<dt id="Data_extraction.extract_from_rois">
<code class="descclassname">Data_extraction.</code><code class="descname">extract_from_rois</code><span class="sig-paren">(</span><em>imgs_to_extract_from</em>, <em>mask_image</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#Data_extraction.extract_from_rois" title="Permalink to this definition">¶</a></dt>
<dd><p>Generic function for extracting image data from a mask or atlas image,
and returning the data and averages within regions specified by the user.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>  [cl, imgdat] = extract_from_rois(imgs_to_extract_from, mask_image, varargin)

Regions to average over can be either regions of contiguous voxels
bounded by voxels with values of 0 or NaN, which are considered non-data
values, or regions defined by unique integer codes in the mask image
(i.e., for atlas images with unique codes for each defined region.)

Mask/Atlas image does NOT have to be in the same space as the images to
extract from.  It will be remapped/resliced.

extracted data is returned in single data format.
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Inputs:</th><td class="field-body"><p class="first"><strong>char array</strong> of strings containing 4D image file names (data extracted from these)</p>
<p><strong>mask_image</strong> to extract from</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Optional Inputs:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body"><dl class="first docutils">
<dt><strong>average_over:</strong></dt>
<dd><p class="first">Default = &#8216;unique_mask_values&#8217; to average over unique integer codes in the mask image
(i.e., for atlas images with unique codes for each defined region)</p>
<p class="last">OPT = &#8216;contiguous_regions&#8217; to average over contiguous voxels
bounded by voxels of 0 or NaN (non-data values)</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Examples:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="n">imgs_to_extract_from</span> <span class="o">=</span> <span class="n">filenames</span><span class="p">(</span><span class="s">&#39;w*.nii&#39;</span><span class="p">,</span><span class="s">&#39;char&#39;</span><span class="p">);</span>
<span class="n">mask_image</span> <span class="o">=</span> <span class="n">which</span><span class="p">(</span><span class="s">&#39;anat_lbpa_thal.img&#39;</span><span class="p">);</span>
<span class="p">[</span><span class="n">cl</span><span class="p">,</span> <span class="n">imgdat</span><span class="p">]</span> <span class="o">=</span> <span class="n">extract_from_rois</span><span class="p">(</span><span class="n">imgs_to_extract_from</span><span class="p">,</span> <span class="n">mask_image</span><span class="p">);</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="Data_extraction.extract_image_data">
<code class="descclassname">Data_extraction.</code><code class="descname">extract_image_data</code><span class="sig-paren">(</span><em>imgs_to_extract_from</em>, <em>mask_image</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#Data_extraction.extract_image_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Generic function for extracting image data from a mask or atlas image,
and returning the data and averages within regions specified by the user.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="p">[</span><span class="n">imgdat</span><span class="p">,</span> <span class="n">volInfo</span><span class="p">,</span> <span class="n">cl</span><span class="p">]</span> <span class="o">=</span> <span class="n">extract_image_data</span><span class="p">(</span><span class="n">imgs_to_extract_from</span><span class="p">,</span> <span class="n">mask_image</span><span class="p">,</span> <span class="n">varargin</span><span class="p">)</span>
</pre></div>
</div>
<p>Regions to average over can be either regions of contiguous voxels
bounded by voxels with values of 0 or NaN, which are considered non-data
values, or regions defined by unique integer codes in the mask image
(i.e., for atlas images with unique codes for each defined region.)</p>
<p>Mask/Atlas image does NOT have to be in the same space as the images to
extract from.  It will be remapped/resliced.</p>
<p>extracted data is returned in single data format.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Inputs:</th><td class="field-body"><p class="first"><strong>char array</strong> of strings containing 4D image file names (data extracted from these)</p>
<p><strong>mask_image</strong> to extract from</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Optional inputs:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body"><dl class="first docutils">
<dt><strong>average_over:</strong></dt>
<dd><p class="first">Default = &#8216;contiguous_regions&#8217; to average over contiguous voxels
bounded by voxels of 0 or NaN (non-data values)</p>
<p class="last">Alt. option = &#8216;unique_mask_values&#8217; to average over unique integer codes in the mask image
(i.e., for atlas images with unique codes for each defined
region)</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Examples:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="n">imgs_to_extract_from</span> <span class="o">=</span> <span class="n">filenames</span><span class="p">(</span><span class="s">&#39;w*.nii&#39;</span><span class="p">,</span><span class="s">&#39;char&#39;</span><span class="p">);</span>
<span class="n">mask_image</span> <span class="o">=</span> <span class="n">which</span><span class="p">(</span><span class="s">&#39;anat_lbpa_thal.img&#39;</span><span class="p">);</span>
<span class="p">[</span><span class="n">imgdat</span><span class="p">,</span> <span class="n">volInfo</span><span class="p">,</span> <span class="n">cl</span><span class="p">]</span> <span class="o">=</span> <span class="n">extract_image_data</span><span class="p">(</span><span class="n">imgs_to_extract_from</span><span class="p">,</span> <span class="n">mask_image</span><span class="p">,</span> <span class="s">&#39;unique_mask_values&#39;</span><span class="p">);</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name" colspan="2">Related functions:</th></tr>
<tr class="field-odd field"><td>&nbsp;</td><td class="field-body"></td>
</tr>
</tbody>
</table>
<p>For an object-oriented alternative, see the fmri_data class and extract_roi_averages method</p>
</dd></dl>

<dl class="function">
<dt id="Data_extraction.extract_indiv_peak_data">
<code class="descclassname">Data_extraction.</code><code class="descname">extract_indiv_peak_data</code><span class="sig-paren">(</span><em>cl</em>, <em>imgs</em><span class="sig-paren">)</span><a class="headerlink" href="#Data_extraction.extract_indiv_peak_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Purpose: to find individually significant regions within each subject
and save average timecourses for each individual ROI for each subject</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="n">cl</span> <span class="o">=</span> <span class="n">extract_indiv_peak_data</span><span class="p">(</span><span class="n">cl</span><span class="p">,</span><span class="n">imgs</span><span class="p">)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Inputs:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>cl:</strong></dt>
<dd><p class="first last">is a clusters structure with one element per region.  Each element
(cluster) is a structure containing coordinates and data.</p>
</dd>
<dt><strong>imgs:</strong></dt>
<dd><p class="first last">is a string matrix with one row per subject, with names of images
used to define thresholds.  These may be contrast or t-images from
individual subjects</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p>The method of extraction is defined in cluster_tmask, which is currently
to use 50% of voxels with the highest values in imgs(subject) for each
subject, or 100% if 50% returns less than 5 voxels.  
It&#8217;s easy in cluster_tmask to use absolute t-thresholds instead.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name" colspan="2">Required fields of cl:</th></tr>
<tr class="field-odd field"><td>&nbsp;</td><td class="field-body"><dl class="first last docutils">
<dt><strong>XYZmm:</strong></dt>
<dd><p class="first last">3 x k list of k coordinates in mm space</p>
</dd>
<dt><strong>raw_data:</strong></dt>
<dd><p class="first last">time x voxels x subjects matrix of data for this region</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p>Outputs appended to cl structure:
indiv_timeseries, time x subjects averaged individual ROI timecourses</p>
<dl class="docutils">
<dt>:.INDIV:, a structure with the following information:</dt>
<dd><ul class="first last simple">
<li>tname, the name of the t-mask (or contrast mask) entered</li>
<li>XYZ, voxel coords for significant voxels for each subject</li>
<li>XYZmm, mm coords for sig voxels for each subject</li>
<li>sigt, logical matrix subjects x voxels for sig voxels</li>
<li>maxt, max map value for each subject</li>
<li>center, average coordinate for sig voxels for each subject</li>
<li>mm_center, the same in mm</li>
</ul>
</dd>
</dl>
<p>The spatial information may be used to correlate peak voxel location with
behavior, for example.</p>
</dd></dl>

<dl class="function">
<dt id="Data_extraction.read_hdr">
<code class="descclassname">Data_extraction.</code><code class="descname">read_hdr</code><span class="sig-paren">(</span><em>name</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#Data_extraction.read_hdr" title="Permalink to this definition">¶</a></dt>
<dd><p>Loads the analyze format header file from a file &#8216;name&#8217;</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>function hdr = read_hdr(name,[opt] datatype)
</pre></div>
</div>
<p>The function returns a structure defined as</p>
<dl class="docutils">
<dt>hdr = struct(...</dt>
<dd><p class="first">&#8216;sizeof_hdr&#8217;, fread(pFile, 1,&#8217;int32&#8217;),...</p>
<p>&#8216;pad1&#8217;, setstr(fread(pFile, 28, &#8216;char&#8217;)),...</p>
<p>&#8216;extents&#8217;, fread(pFile, 1,&#8217;int32&#8217;),...</p>
<p>&#8216;pad2&#8217;, setstr(fread(pFile, 2, &#8216;char&#8217;)),...</p>
<p>&#8216;regular&#8217;,setstr(fread(pFile, 1,&#8217;char&#8217;)), ...</p>
<p>&#8216;pad3&#8217;, setstr(fread(pFile,1, &#8216;char&#8217;)),...</p>
<p>&#8216;dims&#8217;, fread(pFile, 1,&#8217;int16&#8217;),...</p>
<p>&#8216;xdim&#8217;, fread(pFile, 1,&#8217;int16&#8217;),...</p>
<p>&#8216;ydim&#8217;, fread(pFile, 1,&#8217;int16&#8217;),...</p>
<p>&#8216;zdim&#8217;, fread(pFile, 1,&#8217;int16&#8217;),...</p>
<p>&#8216;tdim&#8217;, fread(pFile, 1,&#8217;int16&#8217;),...</p>
<p>&#8216;pad4&#8217;, setstr(fread(pFile,20, &#8216;char&#8217;)),...</p>
<p>&#8216;datatype&#8217;, fread(pFile, 1,&#8217;int16&#8217;),...</p>
<p>&#8216;bits&#8217;, fread(pFile, 1,&#8217;int16&#8217;),...</p>
<p>&#8216;pad5&#8217;, setstr(fread(pFile, 6, &#8216;char&#8217;)),...</p>
<p>&#8216;xsize&#8217;, fread(pFile, 1,&#8217;float&#8217;),...</p>
<p>&#8216;ysize&#8217;, fread(pFile, 1,&#8217;float&#8217;),...</p>
<p>&#8216;zsize&#8217;, fread(pFile, 1,&#8217;float&#8217;),...</p>
<p>&#8216;pad6&#8217;, setstr(fread(pFile, 48, &#8216;char&#8217;))...</p>
<p>&#8216;glmax&#8217;, fread(pFile, 1,&#8217;int32&#8217;),...</p>
<p>&#8216;glmin&#8217;, fread(pFile, 1,&#8217;int32&#8217;),... 
&#8216;descrip&#8217;, setstr(fread(pFile, 80,&#8217;char&#8217;)),...</p>
<p>&#8216;aux_file&#8217;        , setstr(fread(pFile,24,&#8217;char&#8217;))&#8217;,...</p>
<p>&#8216;orient&#8217;          , fread(pFile,1,&#8217;char&#8217;),...</p>
<p>&#8216;origin&#8217;          , fread(pFile,5,&#8217;int16&#8217;),...</p>
<p>&#8216;generated&#8217;       , setstr(fread(pFile,10,&#8217;char&#8217;))&#8217;,...</p>
<p>&#8216;scannum&#8217;         , setstr(fread(pFile,10,&#8217;char&#8217;))&#8217;,...</p>
<p>&#8216;patient_id&#8217;      , setstr(fread(pFile,10,&#8217;char&#8217;))&#8217;,...</p>
<p>&#8216;exp_date&#8217;        , setstr(fread(pFile,10,&#8217;char&#8217;))&#8217;,...</p>
<p>&#8216;exp_time&#8217;        , setstr(fread(pFile,10,&#8217;char&#8217;))&#8217;,...</p>
<p>&#8216;hist_un0&#8217;        , setstr(fread(pFile,3,&#8217;char&#8217;))&#8217;,...</p>
<p>&#8216;views&#8217;           , fread(pFile,1,&#8217;int32&#8217;),...</p>
<p>&#8216;vols_added&#8217;      , fread(pFile,1,&#8217;int32&#8217;),...</p>
<p>&#8216;start_field&#8217;     , fread(pFile,1,&#8217;int32&#8217;),...</p>
<p>&#8216;field_skip&#8217;      , fread(pFile,1,&#8217;int32&#8217;),...</p>
<p>&#8216;omax&#8217;            , fread(pFile,1,&#8217;int32&#8217;),...</p>
<p>&#8216;omin&#8217;            , fread(pFile,1,&#8217;int32&#8217;),...</p>
<p>&#8216;smax&#8217;            , fread(pFile,1,&#8217;int32&#8217;),...</p>
<p class="last">&#8216;smin&#8217;            , fread(pFile,1,&#8217;int32&#8217;) );</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="Data_extraction.readim2">
<code class="descclassname">Data_extraction.</code><code class="descname">readim2</code><span class="sig-paren">(</span><em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#Data_extraction.readim2" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="p">[</span><span class="n">array</span><span class="p">,</span><span class="n">hdr</span><span class="p">,</span><span class="n">h</span><span class="p">,</span><span class="n">whichslices</span><span class="p">,</span><span class="n">rows</span><span class="p">,</span><span class="n">cols</span><span class="p">,</span><span class="n">figh</span><span class="p">]</span> <span class="o">=</span> <span class="n">readim2</span><span class="p">(</span><span class="n">basename</span> <span class="ow">or</span> <span class="n">array</span> <span class="p">[</span><span class="n">opt</span><span class="p">],</span><span class="s">&#39;p&#39;</span> <span class="p">[</span><span class="n">opt</span><span class="p">],</span> <span class="s">&#39;sagg&#39;</span> <span class="ow">or</span> <span class="s">&#39;cor&#39;</span> <span class="p">[</span><span class="n">opt</span><span class="p">],</span><span class="n">flipy</span><span class="p">[</span><span class="n">opy</span><span class="p">],</span><span class="nb">range</span> <span class="p">[</span><span class="n">opt</span><span class="p">])</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Inputs:</th><td class="field-body"><ul class="first simple">
<li>basename of file, without image extension ,OR</li>
<li>3-D array in the workspace to plot, OR</li>
<li>nothing, to browse for file</li>
</ul>
<dl class="docutils">
<dt><strong>p:</strong></dt>
<dd><p class="first last">to plot montage of slices to the screen</p>
</dd>
<dt><strong>sagg:</strong></dt>
<dd><p class="first last">to rotate to saggital view</p>
</dd>
<dt><strong>cor:</strong></dt>
<dd><p class="first last">to rotate to coronal view</p>
</dd>
<dt><strong>t:</strong></dt>
<dd><p class="first last">to save array as double instead of int16 - to save negative t values.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Outputs:</th><td class="field-body"><ul class="first simple">
<li>3d array of image</li>
<li>hdr of image</li>
<li>handles for axes of montage if plotting</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name" colspan="2">Special Features:</th></tr>
<tr class="field-odd field"><td>&nbsp;</td><td class="field-body"><dl class="first last docutils">
<dt><strong>range:</strong></dt>
<dd><dl class="first last docutils">
<dt>specified in mm, must be LAST and FIFTH input argument. </dt>
<dd><ul class="first last simple">
<li>OR range can specify slices, e.g. 1:4:28</li>
</ul>
</dd>
</dl>
</dd>
<dt><strong>clim:</strong></dt>
<dd><p class="first last">color limits for axis plot, must be 1st or 2nd argument.  form: [-1 1]</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Data_extraction.timeseries_extract_slice">
<code class="descclassname">Data_extraction.</code><code class="descname">timeseries_extract_slice</code><span class="sig-paren">(</span><em>V</em>, <em>sliceno</em>, <em>orientation</em><span class="sig-paren">)</span><a class="headerlink" href="#Data_extraction.timeseries_extract_slice" title="Permalink to this definition">¶</a></dt>
<dd><p>For a given set of image names or memory mapped volumes (V)
extracts data from slice # sliceno and returns an X x Y x time
matrix of data.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>function sl = timeseries_extract_slice(V,sliceno)
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="Data_extraction.tor_extract_rois">
<code class="descclassname">Data_extraction.</code><code class="descname">tor_extract_rois</code><span class="sig-paren">(</span><em>imnames</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#Data_extraction.tor_extract_rois" title="Permalink to this definition">¶</a></dt>
<dd><p>This function gets timeseries data from all clusters in an SPM results output.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>function [clusters, SPM, xX, xCon] = tor_extract_rois(imnames [can be empty],[opt] SPM, [opt] VOL, [opt] xX)
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Inputs:</th><td class="field-body"><dl class="first docutils">
<dt><strong>imnames:</strong></dt>
<dd><p class="first last">a matrix of image names, in spm_list_files output format
if empty, no timeseries data will be extracted.</p>
</dd>
<dt><strong>clusters:</strong></dt>
<dd><p class="first last">if only 2 arguments, clusters structure is 2nd arg, and we
extract data using existing clusters structure</p>
</dd>
</dl>
<p>If 3 arguments, enter SPM and VOL to extract data from VOXEL
coordinates in these structures
- SPM:        SPM variable from loaded results
- VOL:        VOL variable from loaded results</p>
<p class="last">Optional 4th argument fits a design matrix and returns betas
- xX:         xX design matrix to fit to timeseries
OR 4th argument can be 0 (or any non-structure arg), suppressing verbose output.</p>
</td>
</tr>
</tbody>
</table>
<p>[Last 2 arguments are optional.  Use if results are already loaded into workspace]</p>
<p>Automatic fitting of model to cluster timeseries average using analyze_cluster_rois
with High-Pass filter length of your choice.
This only works if you input only the file names or input all optional arguments, including xX</p>
<p>NOTE (WARNING): WORKS ON XYZ VOXEL COORDINATES - TRANSFORMATION TO
DIFFERENT SPACES ONLY IF ENTERING 2 ARGS, 1st one names, 2nd one clusters</p>
<p>see transform_coordinates.m for transformation, or check_spm_mat, or cluster_interp.</p>
</dd></dl>

</div>
<div class="section" id="data-processing-tools">
<h1>Data_processing_tools<a class="headerlink" href="#data-processing-tools" title="Permalink to this headline">¶</a></h1>
<span class="target" id="module-Data_processing_tools"></span><dl class="function">
<dt id="Data_processing_tools.center_of_mass">
<code class="descclassname">Data_processing_tools.</code><code class="descname">center_of_mass</code><span class="sig-paren">(</span><em>XYZ</em>, <em>Z</em><span class="sig-paren">)</span><a class="headerlink" href="#Data_processing_tools.center_of_mass" title="Permalink to this definition">¶</a></dt>
<dd><p>This function returns the center of mass of a cluster of voxels or mm coordinates
defined as the nearest in-list coordinate to the average of the 
coordinate values weighted by the Z-score</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="n">com</span> <span class="o">=</span> <span class="n">center_of_mass</span><span class="p">(</span><span class="n">XYZ</span><span class="p">,</span><span class="n">Z</span><span class="p">)</span>
</pre></div>
</div>
<p>assigns a rank to each coordinate based on Z scores
and includes</p>
<p>enter a 3 x n list of XYZ coordinates
returns 1 x 3 center of mass</p>
</dd></dl>

<dl class="function">
<dt id="Data_processing_tools.detransition">
<code class="descclassname">Data_processing_tools.</code><code class="descname">detransition</code><span class="sig-paren">(</span><em>y</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#Data_processing_tools.detransition" title="Permalink to this definition">¶</a></dt>
<dd><p>For fMRI timeseries that contains large &#8216;jump&#8217; artifacts due to motion correction
or other problems.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="n">y</span> <span class="o">=</span> <span class="n">detransition</span><span class="p">(</span><span class="n">y</span><span class="p">,[</span><span class="n">doplot</span><span class="p">])</span>
</pre></div>
</div>
<p>Removes these large spikes.
Updated version built into spikecorrect in trimts</p>
</dd></dl>

<dl class="function">
<dt id="Data_processing_tools.downsample_scnlab">
<code class="descclassname">Data_processing_tools.</code><code class="descname">downsample_scnlab</code><span class="sig-paren">(</span><em>y</em>, <em>orig_samprate</em>, <em>new_samprate</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#Data_processing_tools.downsample_scnlab" title="Permalink to this definition">¶</a></dt>
<dd><p>Uses linear interpolation to resample a vector from one sampling
rate to another</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="p">[</span><span class="n">yi</span><span class="p">,</span> <span class="n">xi</span><span class="p">]</span> <span class="o">=</span> <span class="n">downsample_scnlab</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">orig_samprate</span><span class="p">,</span> <span class="n">new_samprate</span><span class="p">,</span> <span class="p">[</span><span class="n">doplot</span><span class="p">])</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Inputs:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>orig_samprate:</strong></dt>
<dd><p class="first last">sampling rate in Hz</p>
</dd>
<dt><strong>new_samprate:</strong></dt>
<dd><p class="first last">desired sampling rate in Hz</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>% Downsample a 100 Hz signal to a scanning TR of 2 sec
% signal at 100 Hz, sample to low-freq TR of 0.5 hz (2 sec TR)
% every 100 / TR = 100/.5 = 200 samples

[yi, xi] = downsample_scnlab(y, 100, .5)
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="Data_processing_tools.fft_plot_scnlab">
<code class="descclassname">Data_processing_tools.</code><code class="descname">fft_plot_scnlab</code><span class="sig-paren">(</span><em>dat</em>, <em>TR</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#Data_processing_tools.fft_plot_scnlab" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="p">[</span><span class="n">myfft</span><span class="p">,</span> <span class="n">freq</span><span class="p">,</span> <span class="n">handle</span><span class="p">]</span> <span class="o">=</span> <span class="n">fft_plot_scnlab</span><span class="p">(</span><span class="n">dat</span><span class="p">,</span> <span class="n">TR</span><span class="p">,</span> <span class="n">varargin</span><span class="p">)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Inputs:</th><td class="field-body"><dl class="first docutils">
<dt><strong>dat:</strong></dt>
<dd><p class="first last">is a data vector (column)</p>
</dd>
<dt><strong>TR:</strong></dt>
<dd><p class="first last">is the sampling rate of the data you put in
in seconds / sample, or 1/Hz</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Optional inputs:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body"><ul class="first simple">
<li>&#8216;samefig&#8217;</li>
<li>&#8216;color, [&#8216;b&#8217;] or other color</li>
<li>&#8216;bar&#8217;</li>
<li>&#8216;linebar&#8217;: both line and bar</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Examples:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>% plot effects of filtering on a difference
% between two regressors
spm_hplength = SPM.xX.K.HParam;
d = SPM.xX.X * SPM.xCon(mycon).c(:, 1);
create_figure(&#39;Contrast&#39;); plot(d) % contrast we care about
px = pinv(SPM.xX.K.X0);           % pinv of the filtering matrix
y = d;
y = y - SPM.xX.K.X0 * px * y;     % residuals after filtering

[myfft, freq, handle] = fft_plot_scnlab(d, 2);
hold on;
[myfft2, freq2, handle] = fft_plot_scnlab(y, 2); set(handle,&#39;Color&#39;,&#39;r&#39;)
plot_vertical_line(1/spm_hplength)
set(ans, &#39;Color&#39;, &#39;b&#39;, &#39;LineWidth&#39;, 3)
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="Data_processing_tools.filterAdjust">
<code class="descclassname">Data_processing_tools.</code><code class="descname">filterAdjust</code><span class="sig-paren">(</span><em>O</em><span class="sig-paren">)</span><a class="headerlink" href="#Data_processing_tools.filterAdjust" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="p">[</span><span class="n">y</span><span class="p">,</span><span class="n">O</span><span class="p">,</span><span class="n">X</span><span class="p">,</span><span class="n">S</span><span class="p">]</span> <span class="o">=</span> <span class="n">filterAdjust</span><span class="p">(</span><span class="n">OPTIONS</span><span class="p">)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">O:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>O.y:</strong></dt>
<dd><p class="first last">signal</p>
</dd>
<dt><strong>O.HP:</strong></dt>
<dd><p class="first last">high pass freq. cutoff</p>
</dd>
<dt><strong>O.TR:</strong></dt>
<dd><p class="first last">sampling rate in s</p>
</dd>
<dt><strong>O.doHP:</strong></dt>
<dd><p class="first last">[0 or 1] - do HP filter (spm), default is 0</p>
</dd>
<dt><strong>O.doLP:</strong></dt>
<dd><dl class="first last docutils">
<dt>[0, 1, 2] - do LP filter (spm), default is 0</dt>
<dd><p class="first last">2 = Gaussian filter with TR*2 s length</p>
</dd>
</dl>
</dd>
<dt><strong>O.firstimg:</strong></dt>
<dd><p class="first last">sets values for first image in each run to mean of the
remaining values.  Good for removing first-image artifacts present in
some scanner sequences.  Default is 1.</p>
</dd>
<dt><strong>O.cyclecorrection:</strong></dt>
<dd><p class="first last">checks for unimodal (normally distributed) data
within each session, because some bimodal data that cycles between two
mean scanner values has been observed in some data.  if a high proportion
of outliers are found in non-normal data, subtracts mean of higher mode
to adjust data. Sorry-not clear.  Check the code. Default is 0</p>
</dd>
<dt><strong>O.cyclecorrection2:</strong></dt>
<dd><p class="first">removes large transitions from data, as in
detransition.m.  Default is 0.  Artifacts may be acquisition or
motion-correction/resampling related.</p>
<p class="last">We do this after filtering, but if there&#8217;s trouble, we re-do the
scanadjust and filtering, because &#8216;cycling&#8217; can affect these.</p>
</dd>
<dt><strong>O.scanadjust:</strong></dt>
<dd><dl class="first last docutils">
<dt>[0 or 1] - adjust to scan means, default is 0</dt>
<dd><ul class="first simple">
<li>If O.X is entered, assumes this is the session mean matrix,</li>
</ul>
<p class="last">instead of recomputing.</p>
</dd>
</dl>
</dd>
<dt><strong>O.percent:</strong></dt>
<dd><p class="first last">[0 or 1] - adjust to percent change from baseline, default is 0</p>
</dd>
<dt><strong>O.filtertype:</strong></dt>
<dd><dl class="first last docutils">
<dt>filter style, default is &#8216;none&#8217;</dt>
<dd><ul class="first last simple">
<li>&#8216;spm&#8217;, use spm&#8217;s filtering</li>
<li>if O.S is entered, uses this instead of recomputing</li>
<li>&#8216;fourier&#8217;, Doug&#8217;s fourier filter</li>
<li>&#8216;fouriernotch&#8217;, Omit frequencies between HP(1) and HP(2)</li>
<li>&#8216;cheby&#8217;, chebyshev</li>
<li>&#8216;Luis&#8217;, Luis&#8217; custom filter</li>
<li>&#8216;none&#8217;, no filtering (or leave field out).</li>
</ul>
</dd>
</dl>
</dd>
<dt><strong>O.HP:</strong></dt>
<dd><p class="first last">for SPM, the filter cutoff in s
for fourier, the HP value or the [HP LP] values
notches out everything slower than HP and faster than LP, in s
(1/s = Hz).</p>
</dd>
<dt><strong>O.nruns:</strong></dt>
<dd><p class="first last">number of runs (scanadjust), default is 1</p>
</dd>
<dt><strong>O.adjustmatrix:</strong></dt>
<dd><p class="first last">custom adjustment matrix to regress out (e.g., movement params)</p>
</dd>
<dt><strong>O.plot [0 or 1]:</strong></dt>
<dd><p class="first last">plots intermediate products, default is 0</p>
</dd>
<dt><strong>O.verbose [0 or 1]:</strong></dt>
<dd><p class="first last">verbose output</p>
</dd>
<dt><strong>O.trimts [0 or std]:</strong></dt>
<dd><p class="first last">trim overall timseries values to std, 0 for no trimming</p>
</dd>
<dt><strong>O.lindetrend:</strong></dt>
<dd><p class="first">specify linear detrending of timeseries.
occurs after adjustment and filtering and windsorizing</p>
<blockquote class="last">
<div><ul class="simple">
<li>detrending option -&gt; what to enter in this field:</li>
<li>no detrending  -&gt; empty, missing field, or 0</li>
<li>detrending every n elements -&gt; single number (n)</li>
<li>piecewise linear detrend -&gt; ROW vector of breakpoints
(do not specify 1 as the start of the 1st segment.)</li>
</ul>
</div></blockquote>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Data_processing_tools.fir2htw2">
<code class="descclassname">Data_processing_tools.</code><code class="descname">fir2htw2</code><span class="sig-paren">(</span><em>b</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#Data_processing_tools.fir2htw2" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimates height, time to peak, and width of FIR response</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>[h,t,w,w_times,halfh, auc] = fir2htw2(b,[hconstraint],[doplot],[colors cell])
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Inputs:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>b:</strong></dt>
<dd><p class="first last">beta/estimate series for hemodynamic response curve</p>
</dd>
<dt>hconstraint:**</dt>
<dd><p class="first last">max time in samples that can be considered the peak
(default = last sample)</p>
</dd>
<dt>doplot:**</dt>
<dd><p class="first last">flag for plot, 1/0</p>
</dd>
<dt>colors:**</dt>
<dd><p class="first last">cell vector of colors for plot</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p>minh = min height</p>
<p>This version uses turning points (zero gradient) to find the largest
&#8220;hump&#8221; in the data and the time it occurs.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>hrf = spm_hrf(.5); hrf = hrf ./ max(hrf); hrf = hrf + .1 * randn(length(hrf), 1);
create_figure(&#39;hrf&#39;); plot(hrf);
[h,t,w,w_times,halfh, auc] = fir2htw2(hrf, [], 1);
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="Data_processing_tools.get_snr">
<code class="descclassname">Data_processing_tools.</code><code class="descname">get_snr</code><span class="sig-paren">(</span><em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#Data_processing_tools.get_snr" title="Permalink to this definition">¶</a></dt>
<dd><p>Data is a matrix whos columns index voxels, and rows index subjects (or trials, etc.)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="n">snr</span> <span class="o">=</span> <span class="n">get_snr</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="Data_processing_tools.htw_from_fit">
<code class="descclassname">Data_processing_tools.</code><code class="descname">htw_from_fit</code><span class="sig-paren">(</span><em>hrf</em>, <em>b</em>, <em>dt</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#Data_processing_tools.htw_from_fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimates height, time to peak,  width, and area under the curve of a fitted response</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>h, t, w, auc, w_times, halfh] = htw_from_fit(hrf, b, dt, [optional arguments])
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Inputs:</th><td class="field-body"><dl class="first docutils">
<dt><strong>hrf:</strong></dt>
<dd><dl class="first last docutils">
<dt>a matrix of columns that form a linear basis set for an</dt>
<dd><p class="first last">event type in an fMRI design, t time points x k basis
functions</p>
</dd>
</dl>
</dd>
<dt><strong>b:</strong></dt>
<dd><p class="first last">betas associated with the columns of hrf, k x 1</p>
</dd>
<dt><strong>dt:</strong></dt>
<dd><p class="first last">the sampling resolution of hrf (in seconds)</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Optional Inputs:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body"><dl class="first last docutils">
<dt><strong>plot:</strong></dt>
<dd><p class="first last">make plot</p>
</dd>
<dt><strong>verbose:</strong></dt>
<dd><p class="first last">verbose output</p>
</dd>
<dt><strong>startval:</strong></dt>
<dd><p class="first last">followed by the starting value in sec within which to calculate peak</p>
</dd>
<dt><strong>endval:</strong></dt>
<dd><p class="first last">followed by the ending value in sec within which to calculate peak</p>
</dd>
<dt><strong>colors:</strong></dt>
<dd><p class="first last">followed by a cell array, for example, {&#8216;r&#8217;} or {[1 0 0]}</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p>This function is essentially the same as fir2htw2.m, but the main
differences are:</p>
<blockquote>
<div><ol class="arabic simple">
<li>It imposes a time constraint on the peak amplitude automatically,
which is constrained to be between 4 seconds and 12 seconds
(endval, which was hconstraint) by default. YOU MAY WANT TO CHANGE hconstraint
depending on whether you&#8217;re expecting delayed hemodynamic responses.
This requires input of the sampling resolution (e.g., dt)</li>
<li>This function will automatically create fitted responses, given a
basis set and betas (parameters).  This is different from fir2htw2.m,
which takes the fitted response as input.</li>
<li>The method for getting width (w) has been changed to work better
for multi-modal (multi-peak) responses.</li>
</ol>
</div></blockquote>
<p>Otherwise, the algorithm is the same.
See Lindquist and Wager, 2007, for simulations that use a version of
this method to estimate HRFs using different kinds of models.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name" colspan="2">Notes on scaling:</th></tr>
<tr class="field-odd field"><td>&nbsp;</td><td class="field-body"></td>
</tr>
</tbody>
</table>
<p>The scaling of the amplitude depends on the scaling of the hrf basis
set, which (in SPM) depends on the time resolution.  You should at
least use an hrf basis set with the same scaling for all subjects in
a group analysis.  The amplitude of the fitted response is
interpreted as the amplitude of the unit &#8220;impulse response,&#8221; assuming
that the hrf you enter here is the same as the impulse response
function you used to create the design matrix.  In SPM5, higher-res
impulse response functions are normalized by their positive sum, and
the higher the time resolution, the lower the amplitude of the unit
HRF.  (The scaling of regressors in the SPM design matrix isn&#8217;t
affected, because the hrf basis functions are convolved with a boxcar
that also depends on the time resolution.  The bottom line is that if
all your subjects have the same scaling, you should be fine.  And,
secondly, the amplitudes that come out of this function reflect the
scaling of the HRF you put in and are for an impulse response, NOT
for an &#8220;event,&#8221; and so the scaling here would not be expected to
match up with the amplitudes on a plot that you&#8217;d get from a
selective average time-course plot, unless you adjust by multiplying
by the number of elements in SPMs &#8220;hi-res&#8221; onset boxcar to adjust.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">For example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<p>With &#8220;zero-duration&#8221; events, an hrf input scaled to reflect &#8220;event response&#8221; amplitudes
might look something like this: (<a href="#id13"><span class="problematic" id="id14">**</span></a><em>may not be exactly right because
i think dt is in sec)
figure; plot(conv(SPM.xBF.bf(:, 1), my_ons))
my_ons = ones(1, TR ./ SPM.xBF.dt .</em> SPM.Sess.U(1).dur(1));</p>
<p>If you have epochs and want &#8220;epoch response&#8221; amplitude, you have to consider that as well.
If your durations are specified in TRs, and all durations are the
same:
TR = SPM.xY.RT;
my_ons = ones(1, TR ./ SPM.xBF.dt .* SPM.Sess.U(1).dur(1));</p>
<p>minh = min height</p>
<p>This version uses turning points (zero gradient) to find the largest
&#8220;hump&#8221; in the data and the time it occurs.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Examples:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>% Load and SPM mat file and use the basis set stored in that, and use
% that as the hrf.  Generate some arbitrary combos to test different shapes:
% cd(&#39;my spm directory&#39;)
% load SPM
[h, t, w, auc] = htw_from_fit(SPM.xBF.bf, [1 .4 .4]&#39;, SPM.xBF.dt, &#39;plot&#39;, &#39;verbose&#39;);

for i = 1:20
    [h, t, w, auc] = htw_from_fit(SPM.xBF.bf, randn(3, 1), SPM.xBF.dt, &#39;plot&#39;); pause(1.5);
end

% Generate an SPM basis set at a lower resolution, and try that:
bf = spm_get_bf(struct(&#39;name&#39;, &#39;hrf (with time and dispersion derivatives)&#39;, &#39;length&#39;, 30, &#39;dt&#39;, 1));
for i = 1:20
   [h, t, w, auc] = htw_from_fit(bf.bf, randn(3, 1), bf.dt, &#39;plot&#39;); h, t, w, auc, pause(1.5)
end
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="Data_processing_tools.luisFilter">
<code class="descclassname">Data_processing_tools.</code><code class="descname">luisFilter</code><span class="sig-paren">(</span><em>data</em>, <em>TR</em>, <em>cutoff</em>, <em>verbose</em><span class="sig-paren">)</span><a class="headerlink" href="#Data_processing_tools.luisFilter" title="Permalink to this definition">¶</a></dt>
<dd><p>This is a low pass FIR filter using the Parks Mclellan design algorithm
The phase introduced by the filter is linear and is un-done by 
filtering the data again, backwards
if you want to see what it does to the data, use verbose=1
if just want to filter the data, don&#8217;t use the argument at all.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>function outdata = luisFilter(data,  TR, cutoff [, verbose])
</pre></div>
</div>
<p>close all</p>
<blockquote>
<div>These are the important lines of the code   %%%%%%%%%%%%%</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="Data_processing_tools.nuisance_cov_estimates">
<code class="descclassname">Data_processing_tools.</code><code class="descname">nuisance_cov_estimates</code><span class="sig-paren">(</span><em>X</em>, <em>images</em>, <em>SETUP</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#Data_processing_tools.nuisance_cov_estimates" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimates F-map for model parameters of interest
Writes to disk:
&#8216;F_cols_of_interest.img&#8217; &#8216;p_cols_of_interest.img&#8217; (3-D images)
&#8216;resid_full_model.img&#8217; (a 4-D image)</p>
<p>Locates voxels whose activity is unrelated to the model</p>
<p>Extracts principal components from these voxels for use as covariates
in subsequent models</p>
<p>Note: invalidates statistical inference in subsequent models based on
these data, but may improve predictive accuracy and single-trial model.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="n">nuisance_cov_estimates</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">images</span><span class="p">,</span> <span class="n">SETUP</span><span class="p">,</span> <span class="n">varargin</span><span class="p">)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name" colspan="2">Defining the SETUP structure with inputs:</th></tr>
<tr class="field-odd field"><td>&nbsp;</td><td class="field-body"></td>
</tr>
</tbody>
</table>
<p>SETUP.(fields)</p>
<blockquote>
<div><dl class="docutils">
<dt><strong>.wh_of_interest:</strong></dt>
<dd><dl class="first last docutils">
<dt>vector of which columns of X matrix are of interest</dt>
<dd>% columns of interest in X matrix; tests var explained by these with F-test</dd>
</dl>
</dd>
<dt><strong>.mask:</strong></dt>
<dd>name of mask image</dd>
<dt><strong>.TR:</strong></dt>
<dd>repetition time of volume (image) acquisition</dd>
<dt><strong>.HPlength:</strong></dt>
<dd>high-pass filter length, in s</dd>
<dt><strong>.scans_per_session:</strong></dt>
<dd>vector of # volumes in each run, e.g., [128 128 128 128 128]</dd>
<dt><strong>.dummyscans:</strong></dt>
<dd>indices of images in each run that will be modeled
with separate dummy variables</dd>
<dt><strong>.startslice:</strong></dt>
<dd>start at slice #...</dd>
</dl>
</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name" colspan="2">SETUP Optional Inputs:</th></tr>
<tr class="field-odd field"><td>&nbsp;</td><td class="field-body"><dl class="first last docutils">
<dt><strong>nopreproc:</strong></dt>
<dd><p class="first last">to skip preprocessing (i.e., for trial-level inputs)</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Data_processing_tools.resample_scnlab">
<code class="descclassname">Data_processing_tools.</code><code class="descname">resample_scnlab</code><span class="sig-paren">(</span><em>data</em>, <em>p</em>, <em>q</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#Data_processing_tools.resample_scnlab" title="Permalink to this definition">¶</a></dt>
<dd><p>Resample : Uses matlab&#8217;s resample.m, but pads ends to avoid edge
artifacts</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>[y, x] = resample_scnlab(data, p, q)
% OR
[y, x] = resample_scnlab(data, p, q, origHz, targetHz)
</pre></div>
</div>
<dl class="docutils">
<dt>Y = RESAMPLE(X,P,Q) resamples the sequence in vector X at P/Q times</dt>
<dd>the original sample rate using a polyphase implementation.  Y is P/Q 
times the length of X (or the ceiling of this if P/Q is not an integer).  
P and Q must be positive integers.</dd>
</dl>
<p>Other features:</p>
<p>Returns x values for resampled data in original index scale</p>
<p>IF two additional args are entered (origHz and targetHz), 
p and q are determined automatically, based on your desired sampling rate
(targetHz)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>create_figure(&#39;test&#39;); plot(y);
[y2, x] = resample_scnlab(y, 1, 5);
plot(x, y2, &#39;r&#39;);

%Use target Hz...take 100 Hz vector and resample at 20 Hz
create_figure(&#39;test&#39;);
plot(y); [y2, x] = resample_scnlab(y, [], [], 100, 20);
plot(x, y2, &#39;r&#39;);
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="Data_processing_tools.scale">
<code class="descclassname">Data_processing_tools.</code><code class="descname">scale</code><span class="sig-paren">(</span><em>x</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#Data_processing_tools.scale" title="Permalink to this definition">¶</a></dt>
<dd><p>Centers and scales column vectors to mean 0 and st. deviation 1</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>x = scale(x,[just center])
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="Data_processing_tools.scnlab_filter_fmri_data">
<code class="descclassname">Data_processing_tools.</code><code class="descname">scnlab_filter_fmri_data</code><span class="sig-paren">(</span><em>imgs</em>, <em>mvmt</em>, <em>mask</em>, <em>tr</em>, <em>spersess</em>, <em>hp</em><span class="sig-paren">)</span><a class="headerlink" href="#Data_processing_tools.scnlab_filter_fmri_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Outlier and artifact removal for one subject
Writes new output images for timeseries</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="n">names</span> <span class="o">=</span> <span class="n">scnlab_filter_fmri_data</span><span class="p">(</span><span class="n">imgs</span><span class="p">,</span> <span class="n">mvmt</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">tr</span><span class="p">,</span> <span class="n">spersess</span><span class="p">,</span> <span class="n">hp</span><span class="p">)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Examples:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="n">OUT</span> <span class="o">=</span> <span class="n">mean_image</span><span class="p">(</span><span class="n">imgs</span><span class="p">,</span> <span class="s">&#39;mean_ravol.img&#39;</span><span class="p">,</span><span class="n">ones</span><span class="p">(</span><span class="n">size</span><span class="p">(</span><span class="n">imgs</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span><span class="mi">1</span><span class="p">));</span>
<span class="n">spm_imcalc_ui</span><span class="p">(</span><span class="s">&#39;mean_ravol.img&#39;</span><span class="p">,</span> <span class="s">&#39;graymatter.img&#39;</span><span class="p">,</span> <span class="s">&#39;i1 &gt; 0&#39;</span><span class="p">);</span>
<span class="n">spm_image</span><span class="p">(</span><span class="s">&#39;init&#39;</span><span class="p">,</span> <span class="s">&#39;graymatter.img&#39;</span><span class="p">);</span>
<span class="n">names</span> <span class="o">=</span> <span class="n">scnlab_filter_fmri_data</span><span class="p">(</span><span class="n">imgs</span><span class="p">,</span> <span class="n">mvmt</span><span class="p">,</span> <span class="s">&#39;graymatter.img&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">repmat</span><span class="p">(</span><span class="mi">184</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span> <span class="mi">80</span><span class="p">);</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="Data_processing_tools.scnlab_outlier_id">
<code class="descclassname">Data_processing_tools.</code><code class="descname">scnlab_outlier_id</code><span class="sig-paren">(</span><em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#Data_processing_tools.scnlab_outlier_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Methods (modes of operation)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Setup:</th><td class="field-body">Run this method first to generate an options structure OPT
that can be passed in along with any data vector for speedy
processing</td>
</tr>
<tr class="field-even field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>OPT = scnlab_outlier_id(&#39;setup&#39;, &#39;tr&#39;, 2, &#39;spersess&#39;,
                        [184 184 184 184 184 184], &#39;dummy&#39;, 1:3,
                        &#39;hp&#39;, 100, &#39;mad&#39;, 4, &#39;niter&#39;, 3, &#39;mvmt&#39;, mvmt);
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Data:</th><td class="field-body">Run this method second with an already-created OPT
and a data vector from one time series</td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="p">[</span><span class="n">y2</span><span class="p">,</span> <span class="n">outliers</span><span class="p">,</span> <span class="n">num_outliers</span><span class="p">,</span> <span class="n">mvmt_rsquare</span><span class="p">]</span> <span class="o">=</span> <span class="n">scnlab_outlier_id</span><span class="p">(</span><span class="s">&#39;data&#39;</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="s">&#39;options&#39;</span><span class="p">,</span> <span class="n">OPT</span><span class="p">);</span>
</pre></div>
</div>
<p>all outputs:</p>
<div class="highlight-python"><div class="highlight"><pre>[y2, out, nout, mvmtrsq, mvmt_baseline_rsquare, yperc, rawvarp, rawvarF, percvarp, percvarF, ...
ybase] = scnlab_outlier_id(&#39;data&#39;, y, &#39;options&#39;, OPT);
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>[dat, volInfo] = iimg_get_data(&#39;graymask.img&#39;, imgs);
y = dat(:,1);
% SETUP:
OPT = scnlab_outlier_id(&#39;setup&#39;, &#39;tr&#39;, 2, &#39;spersess&#39;, [184 184 184 184 184 184], &#39;dummy&#39;, 1:3, &#39;hp&#39;, 100, &#39;mad&#39;, 4, &#39;niter&#39;, 3, &#39;mvmt&#39;, mvmt);
% RUN:
[y2, outliers, num_outliers] = scnlab_outlier_id(&#39;data&#39;, y, &#39;options&#39;, OPT);

% run on whole brain
[dat, volInfo] = iimg_get_data(&#39;graymask.img&#39;, imgs);
OPT = scnlab_outlier_id(&#39;setup&#39;, &#39;tr&#39;, 2, &#39;spersess&#39;, [184 184 184 184 184 184], &#39;dummy&#39;, 1:2, &#39;hp&#39;, 100, &#39;mad&#39;, 4, &#39;niter&#39;, 5, &#39;mvmt&#39;, mvmt);
OPT.doplot = 0;
OPT.verbose = 0;
fhandle = @(y) scnlab_outlier_id(&#39;data&#39;, y, &#39;options&#39;, OPT);
y2 = matrix_eval_function(dat, fhandle)&#39;;
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="Data_processing_tools.selective_average">
<code class="descclassname">Data_processing_tools.</code><code class="descname">selective_average</code><span class="sig-paren">(</span><em>y</em>, <em>onsets</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#Data_processing_tools.selective_average" title="Permalink to this definition">¶</a></dt>
<dd><p>Purpose: Get a selective average of values of data vector y, given
onsets specified in onsets.  Onsets can be fractional; in this case,
linear interpolation is used.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="p">[</span><span class="n">averages</span><span class="p">,</span> <span class="n">stderrs</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">indices</span><span class="p">]</span> <span class="o">=</span> <span class="n">selective_average</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">onsets</span><span class="p">,</span> <span class="n">varargin</span><span class="p">)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Inputs:</th><td class="field-body"><dl class="first docutils">
<dt><strong>y:</strong></dt>
<dd><p class="first last">is a data vector to get selective averages from.
It should be a column vector.</p>
</dd>
<dt><strong>onsets:</strong></dt>
<dd><p class="first last">should be a cell array, with one cell per condition
each cell should contain a column vector of onset times in SAMPLES (same
resolution as y; e.g., in TRs, if y is an fMRI time series.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Optional Inputs:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body"><dl class="first docutils">
<dt><strong>t:</strong></dt>
<dd><p class="first last">followed by number of time points following onset to use;
default is 20</p>
</dd>
<dt><strong>plot:</strong></dt>
<dd><p class="first last">plot results.</p>
</dd>
<dt><strong>baseline:</strong></dt>
<dd><p class="first last">followed by vector of which time points are baseline
values; will subtract from each</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Outputs:</th><td class="field-body"><dl class="first docutils">
<dt><strong>data:</strong></dt>
<dd><p class="first last">indices, averages, stderrs:  Cell vectors, one cell per condition</p>
</dd>
<dt><strong>data, indices:</strong></dt>
<dd><p class="first last">time points (observations) x trials (onsets)</p>
</dd>
<dt><strong>indices:</strong></dt>
<dd><p class="first last">Cell vector, one cell per condition; time points (observations) x trials (onsets)</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Examples:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>onsets = {[1 10 30 80]&#39;  [20 60 90]&#39;}; y = (1:120)&#39;;
[averages, stderrs, data, indices] = selective_average(y, onsets, &#39;t&#39;, 20)

V = spm_vol(EXPT.FILES.im_files{1});
y = spm_get_data(V, [10 10 10 1]&#39;);
[averages, stderrs, data, indices] = selective_average(y, onsets2(1), &#39;t&#39;, 20, &#39;plot&#39;);
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="Data_processing_tools.selective_average_group">
<code class="descclassname">Data_processing_tools.</code><code class="descname">selective_average_group</code><span class="sig-paren">(</span><em>V</em>, <em>onsets</em>, <em>xyz_mm_pos</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#Data_processing_tools.selective_average_group" title="Permalink to this definition">¶</a></dt>
<dd><p>uses selective_average.m
used in selective_average_interactive_view_init.m</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Examples:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>[group_avgs, group_stes, subject_avgs, subject_stes] = selective_average_group(V, onsets, vox, &#39;basepts&#39;, 1:2, &#39;plotstes&#39;, 0);

% Format onsets from onsets2 (NSF study format) into correct format for this function
N = length(imgs); n_conditions = size(eventdesign{1}, 2);
onsets = cell(1, N);
for i = 1:N
   for j = 1:n_conditions
       onsets{i}{j} = onsets2{i}(find(eventdesign{i}(:, j)));
   end
end
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="Data_processing_tools.smooth_timeseries">
<code class="descclassname">Data_processing_tools.</code><code class="descname">smooth_timeseries</code><span class="sig-paren">(</span><em>x</em>, <em>perc</em><span class="sig-paren">)</span><a class="headerlink" href="#Data_processing_tools.smooth_timeseries" title="Permalink to this definition">¶</a></dt>
<dd><p>Make exponential smoothing function with perc proportion of data points
(0 &lt; perc &lt; 1)
OR specify length directly, as % of points to 0 weight</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">V</span><span class="p">]</span> <span class="o">=</span> <span class="n">smooth_timeseries</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">perc</span><span class="p">)</span>
</pre></div>
</div>
<p>apply smoothing filter V to data (x), V * x
(works just as well for a matrix of column vectors)
You could also apply it to a model matrix X</p>
</dd></dl>

<dl class="function">
<dt id="Data_processing_tools.splineDetrend">
<code class="descclassname">Data_processing_tools.</code><code class="descname">splineDetrend</code><span class="sig-paren">(</span><em>v</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#Data_processing_tools.splineDetrend" title="Permalink to this definition">¶</a></dt>
<dd><p>What it does:
A spline detrend with knot points every 2 s (hard coded number)
I made this up too - it&#8217;s not the FDA approved method.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="p">[</span><span class="n">fv</span><span class="p">,</span><span class="n">bp</span><span class="p">,</span><span class="n">yy</span><span class="p">,</span><span class="n">myfft</span><span class="p">]</span> <span class="o">=</span> <span class="n">splineDetrend</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="s">&#39;p&#39;</span> <span class="p">[</span><span class="n">opt</span><span class="p">])</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Input:</th><td class="field-body"><dl class="first docutils">
<dt><strong>v:</strong></dt>
<dd><p class="first last">a vector to be detrended</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Optional Inputs:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body"><dl class="first docutils">
<dt><strong>p:</strong></dt>
<dd><p class="first last">means plot</p>
</dd>
</dl>
<p>any other opt argument sets the knots and is treated as an integer, with detrending every n
elements.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Outputs:</th><td class="field-body"><dl class="first docutils">
<dt><strong>fv:</strong></dt>
<dd><p class="first last">the detrended vector, bp, the knot points, and myfft, the
abs(fft) of the detrended vector.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Examples:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>tmp = cl(1).raw_data(:,1,6); tmp2 = trimts(tmp,3,[],1); [fv,bp,yy]=splineDetrend(tmp2);
[fv,bp] = splineDetrend(tmp2,&#39;p&#39;);
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="Data_processing_tools.splinetrim">
<code class="descclassname">Data_processing_tools.</code><code class="descname">splinetrim</code><span class="sig-paren">(</span><em>y</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#Data_processing_tools.splinetrim" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="n">function</span> <span class="p">[</span><span class="n">y</span><span class="p">,</span><span class="n">ntrimmed</span><span class="p">,</span><span class="n">spikes</span><span class="p">,</span> <span class="n">yfit</span><span class="p">]</span> <span class="o">=</span> <span class="n">splinetrim</span><span class="p">(</span><span class="n">y</span><span class="p">,[</span><span class="n">iqrmult</span><span class="p">],[</span><span class="n">knotrate</span><span class="p">],[</span><span class="n">X</span><span class="p">],[</span><span class="s">&#39;p&#39;</span><span class="p">])</span>
</pre></div>
</div>
<p>Uses a robust measure of deviations in a timeseries gradient
to find high-velocity &#8216;spikes&#8217;, presumed to be artifacts</p>
<p>Uses spline interpolation to replace spikes with reasonable values.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Input:</th><td class="field-body"><dl class="first docutils">
<dt><strong>y:</strong></dt>
<dd><p class="first last">a timeseries</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Optional Inputs:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body"><dl class="first docutils">
<dt><strong>iqrmult:</strong></dt>
<dd><dl class="first last docutils">
<dt>how many times the interquartile range above which velocities are</dt>
<dd><p class="first last">outliers, default is 1.5</p>
</dd>
</dl>
</dd>
<dt><strong>knotrate:</strong></dt>
<dd><p class="first last">sets knot points every k observations, default is 3</p>
</dd>
<dt><strong>X:</strong></dt>
<dd><p class="first last">matrix of session means or other linear regressors to remove</p>
</dd>
<dt><strong>p:</strong></dt>
<dd><p class="first last">plot the results</p>
</dd>
</dl>
<p>X and &#8216;p&#8217; can be entered in any order, but after iqrmult and knotrate</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Examples:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="p">[</span><span class="n">y2</span><span class="p">,</span><span class="n">nt</span><span class="p">]</span> <span class="o">=</span> <span class="n">splinetrim</span><span class="p">(</span><span class="n">trialdat</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="s">&#39;p&#39;</span><span class="p">);</span> <span class="n">nt</span>
</pre></div>
</div>
<ul class="simple">
<li>setup</li>
</ul>
</dd></dl>

<dl class="function">
<dt id="Data_processing_tools.trimts">
<code class="descclassname">Data_processing_tools.</code><code class="descname">trimts</code><span class="sig-paren">(</span><em>y</em>, <em>sd</em>, <em>X</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#Data_processing_tools.trimts" title="Permalink to this definition">¶</a></dt>
<dd><ol class="arabic">
<li><p class="first">Adjusts for scan effects (unless X is empty)</p>
</li>
<li><dl class="first docutils">
<dt>Windsorizes timeseries to sd standard deviations</dt>
<dd><ul class="first last simple">
<li>Recursive: 3 steps</li>
</ul>
</dd>
</dl>
</li>
<li><p class="first">Adds scan effects back into timeseries</p>
</li>
</ol>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>function [y,ntrimmed,allw] = trimts(y,sd,X,[do spike correct],[trimming iterations],[MADs])
</pre></div>
</div>
<p>Spike correct: Some attempt at automatic adjustment for abrupt level
shifts in data; default is 0, enter 1 to do this
&#8220;Spikes&#8221; are IDd as values more than 10 MADs (by default) from moving average with 20 image FWHM
Replaces &#8220;spike&#8221; data values with moving average</p>
<p>iterations: number of cycles through trimming; default is 3</p>
<p>MADs: allows you to change the number of MADs above which values are IDd
as &#8220;spikes&#8221;</p>
<p>filter y using X matrix; yf is residuals</p>
</dd></dl>

<dl class="function">
<dt id="Data_processing_tools.use_spm_filter">
<code class="descclassname">Data_processing_tools.</code><code class="descname">use_spm_filter</code><span class="sig-paren">(</span><em>TR</em>, <em>dims</em>, <em>LChoice</em>, <em>HChoice</em>, <em>HParam</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#Data_processing_tools.use_spm_filter" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>function [S,KL,KH] = use_spm_filter(TR,dim of filter,LChoice,HChoice,HP filter in s,[LP Gauss len in s])
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Inputs:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>K{s}.LChoice:</strong></dt>
<dd><p class="first last">Low-pass  filtering {&#8216;hrf&#8217; &#8216;Gaussian&#8217; &#8216;none&#8217;}</p>
</dd>
<dt><strong>K{s}.LParam:</strong></dt>
<dd><p class="first last">Gaussian parameter in seconds</p>
</dd>
<dt><strong>K{s}.HChoice:</strong></dt>
<dd><p class="first last">High-pass filtering {&#8216;specify&#8217; &#8216;none&#8217;}</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-diagnostics">
<span id="diagnostics"></span><h1>diagnostics<a class="headerlink" href="#module-diagnostics" title="Permalink to this headline">¶</a></h1>
<dl class="function">
<dt id="diagnostics.BiasPowerloss">
<code class="descclassname">diagnostics.</code><code class="descname">BiasPowerloss</code><span class="sig-paren">(</span><em>tc</em>, <em>X</em>, <em>c</em>, <em>beta</em>, <em>df</em>, <em>z</em>, <em>pval</em><span class="sig-paren">)</span><a class="headerlink" href="#diagnostics.BiasPowerloss" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the approximate bias and power loss due to mis-modeling</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>function [b pl] = BiasPowerloss(z, X, V)
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Inputs:</th><td class="field-body"><dl class="first docutils">
<dt><strong>tc:</strong></dt>
<dd><p class="first last">fMRI time course</p>
</dd>
<dt><strong>X:</strong></dt>
<dd><p class="first last">design matrix</p>
</dd>
<dt><strong>c:</strong></dt>
<dd><p class="first last">contrast of interest</p>
</dd>
<dt><strong>beta:</strong></dt>
<dd><p class="first last">(mismodeled) beta value</p>
</dd>
<dt><strong>df:</strong></dt>
<dd><p class="first last">degrees of freedom</p>
</dd>
<dt><strong>z:</strong></dt>
<dd><p class="first last">p-value calculated from ResidScan</p>
</dd>
<dt><strong>pval:</strong></dt>
<dd><p class="first last">cut-off p-value</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Outputs:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>b:</strong></dt>
<dd><p class="first last">updated (correct) beta value</p>
</dd>
<dt><strong>bias:</strong></dt>
<dd><p class="first last">bias</p>
</dd>
<dt><strong>pl:</strong></dt>
<dd><p class="first last">power loss</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p>Update design matrix using correct model</p>
</dd></dl>

<dl class="function">
<dt id="diagnostics.ResidScan">
<code class="descclassname">diagnostics.</code><code class="descname">ResidScan</code><span class="sig-paren">(</span><em>res</em>, <em>FWHM</em><span class="sig-paren">)</span><a class="headerlink" href="#diagnostics.ResidScan" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates P(M&gt;=t) where M is the max value of the smoothed residuals.
In this implementation the residuals are smoothed using a Gaussian
kernel.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>function [z sres] = ResidScan(res, FWHM)
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Inputs:</th><td class="field-body"><dl class="first docutils">
<dt><strong>res:</strong></dt>
<dd><p class="first last">residual time course</p>
</dd>
<dt><strong>FWHM:</strong></dt>
<dd><p class="first last">Full Width Half Maximum (in time units)</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Outputs:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>z:</strong></dt>
<dd><p class="first last">pvalues</p>
</dd>
<dt><strong>sres:</strong></dt>
<dd><p class="first last">smoothed residuals</p>
</dd>
<dt><strong>sres_ns:</strong></dt>
<dd><p class="first last">smoothed residuals (non standardized)</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="diagnostics.add_nuisance_to_SPMcfg">
<code class="descclassname">diagnostics.</code><code class="descname">add_nuisance_to_SPMcfg</code><span class="sig-paren">(</span><em>Xn</em><span class="sig-paren">)</span><a class="headerlink" href="#diagnostics.add_nuisance_to_SPMcfg" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Adds a matrix Xn to the end of covariates of interest in</dt>
<dd><p class="first">xX structure in SPMcfg.mat</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>function add_nuisance_to_SPMcfg(Xn)
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Inputs:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>oXn:</strong></dt>
<dd><p class="first last">should contain ALL nuisance covariates and intercepts
as in output of tor_get_physio.m</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="last">This function is automatically run by tor_get_physio.m</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="diagnostics.batch_efficiency">
<code class="descclassname">diagnostics.</code><code class="descname">batch_efficiency</code><span class="sig-paren">(</span><em>dwcard</em><span class="sig-paren">)</span><a class="headerlink" href="#diagnostics.batch_efficiency" title="Permalink to this definition">¶</a></dt>
<dd><p>Start in directory above individual model/results directories</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>function batch_efficiency(dwcard)
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Inputs:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>dwcard:</strong></dt>
<dd><p class="first last">is a wildcard for directories to probe, e.g., &#8216;subject*&#8217;</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="diagnostics.batch_t_histograms">
<code class="descclassname">diagnostics.</code><code class="descname">batch_t_histograms</code><span class="sig-paren">(</span><em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#diagnostics.batch_t_histograms" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates page(s) of t stat histograms for each subject level contrast in
set of subject level analyses using image_intensity_histograms.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="n">batch_t_histograms</span><span class="p">([</span><span class="n">options</span><span class="p">])</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name" colspan="2">Optional Inputs:</th></tr>
<tr class="field-odd field"><td>&nbsp;</td><td class="field-body"><dl class="first last docutils">
<dt><strong>{analysis_dirs}:</strong></dt>
<dd><blockquote class="first">
<div><p>run on all contrasts in directories of cell array {analysis_dirs}</p>
</div></blockquote>
<p class="last">(DEFAULT: use all directories in working directory containing spmT_*.img files)</p>
</dd>
<dt>&#8216;o&#8217;, &#8216;output_directory&#8217;:**</dt>
<dd><p class="first last">specify output directory to contain saved .png files</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="diagnostics.canlab_qc_metrics1">
<code class="descclassname">diagnostics.</code><code class="descname">canlab_qc_metrics1</code><span class="sig-paren">(</span><em>epi_names</em>, <em>mask_name</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#diagnostics.canlab_qc_metrics1" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate quality control metrics on a 4-D EPI Analyze or Nifti file</p>
<p>Standard CANlab usage is to enter a single 4-D ravol* for one run, and
the brain mask implicit_mask.img created in canlab_preproc.m</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Inputs:</th><td class="field-body"><dl class="first docutils">
<dt><strong>epi_names:</strong></dt>
<dd><p class="first last">Names of (usually one) 4-D EPI file, in cell or string, full path</p>
</dd>
<dt><strong>mask_name:</strong></dt>
<dd><dl class="first last docutils">
<dt>Name of brain mask image, string, full path</dt>
<dd><p class="first last">IF EMPTY: Uses implict masking (better) and calculates
ghost/signal outside mask</p>
</dd>
</dl>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Optional Inputs:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body"><dl class="first docutils">
<dt><strong>noplot:</strong></dt>
<dd><p class="first last">skip plots</p>
</dd>
<dt><strong>noverbose:</strong></dt>
<dd><p class="first last">skip output printout to screen</p>
</dd>
<dt><strong>printfile:</strong></dt>
<dd><p class="first last">followed by name of file to print output to, full path</p>
</dd>
<dt><strong>noheader:</strong></dt>
<dd><p class="first last">suppress printing of header (var names) in output</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-odd field"><th class="field-name" colspan="2">Missing values and basic info:</th></tr>
<tr class="field-odd field"><td>&nbsp;</td><td class="field-body"><dl class="first last docutils">
<dt><strong>num_images:</strong></dt>
<dd><p class="first last">number of images</p>
</dd>
<dt><strong>missing_vox:</strong></dt>
<dd><p class="first last">Voxels in mask with NaN values or zero values at every time point</p>
</dd>
<dt><strong>missing_images:</strong></dt>
<dd><p class="first last">Images with NaN values or zero values at every voxel</p>
</dd>
<dt><strong>missing_values:</strong></dt>
<dd><p class="first last">NaN or zero values in valid images / voxels. Zeros could
be interpreted as values of zero in analysis, causing artifacts in results
if these are actually invalid values.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p>Missing voxels will often be ignored in analyses in most software, but
Missing images/values could cause problems</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name" colspan="2">Basic signal to noise:</th></tr>
<tr class="field-odd field"><td>&nbsp;</td><td class="field-body"><dl class="first docutils">
<dt><strong>perc-mean-ghost:</strong></dt>
<dd><p class="first last">mean signal outside the mask / mean total signal</p>
</dd>
<dt><strong>mean_snr:</strong></dt>
<dd><blockquote class="first">
<div><p>mean Cohen&#8217;s d (signal/noise, SNR) across time (temporal SNR) within the mask.</p>
</div></blockquote>
<p class="last">Mean divided by standard deviation across time at each voxel, averaged.  Higher is better.</p>
</dd>
<dt><strong>snr_inhomogeneity:</strong></dt>
<dd><p class="first last">standard deviation of SNR within the mask. Lower is better.</p>
</dd>
<dt><strong>snr_inhomogeneity95:</strong></dt>
<dd><p class="first last">95% confidence range for SNR within the mask. Lower is better.</p>
</dd>
<dt><strong>rms_successive_diffs:</strong></dt>
<dd><p class="first last">Essentially a high-pass filtered version of SNR,
expressed as a fraction of the overall mean and averaged across voxels. Lower is better.</p>
</dd>
<dt><strong>rms_successive_diffs_inhomogeneity:</strong></dt>
<dd><p class="first last">standard deviation of the above across voxels. Lower is better.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Left-right asymmetry:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body"><dl class="first docutils">
<dt><strong>signal_rms_asymmetry:</strong></dt>
<dd><p class="first last">Voxel-wise left/right root mean square asymmetry in mean signal across time, expressed as
a fraction of the mean SNR.  Reflects both gross inhomogeneity and noise.  Lower is better.</p>
</dd>
<dt><strong>signal_hemispheric_asymmetry:</strong></dt>
<dd><p class="first last">Root mean square difference between left and
right hemispheres, expressed as a fraction of the grand mean signal across time.  Reflects
gross inhomogeneity.  Lower is better.</p>
</dd>
<dt><strong>snr_rms_asymmetry:</strong></dt>
<dd><p class="first last">Voxel-wise left/right root mean square asymmetry in SNR, expressed as
a fraction of the mean SNR.  Reflects both gross inhomogeneity and noise.  Lower is better.</p>
</dd>
<dt><strong>snr_hemispheric_asymmetry:</strong></dt>
<dd><p class="first last">Root mean square difference between left and
right hemispheres, expressed as a fraction of the mean SNR.  Reflects
gross inhomogeneity.  Lower is better.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Examples:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>%SETUP
mydir{1} = &#39;/Users/tor/Documents/Tor_Documents/Coursework_and_Teaching/psyc7215/Data/UM_Face_House/060518mw/Functional/Preprocessed/run_01&#39;;
wcard = &#39;rarun*img&#39;;
epi_names = filenames(fullfile(mydir{1}, wcard), &#39;absolute&#39;);

maskdir = &#39;/Users/tor/Documents/Tor_Documents/Coursework_and_Teaching/psyc7215/Data/UM_Face_House/060518mw&#39;;
mask = &#39;implicit_mask.img&#39;;
mask_name = fullfile(maskdir, maskname);

%RUN
QC = canlab_qc_metrics1(epi_names, mask_name);

QC = canlab_qc_metrics1(epi_names, mask_name, &#39;noplot&#39;, &#39;printfile&#39;, &#39;test_qc.txt&#39;);
QC = canlab_qc_metrics1(epi_names, mask_name, &#39;noplot&#39;, &#39;printfile&#39;, &#39;test_qc.txt&#39;, &#39;noheader&#39;);
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="diagnostics.check_cluster_data">
<code class="descclassname">diagnostics.</code><code class="descname">check_cluster_data</code><span class="sig-paren">(</span><em>cl</em><span class="sig-paren">)</span><a class="headerlink" href="#diagnostics.check_cluster_data" title="Permalink to this definition">¶</a></dt>
<dd><p>loads the first 5 images from the first voxel</p>
<blockquote>
<div><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="n">check_cluster_data</span><span class="p">(</span><span class="n">cl</span><span class="p">)</span>
</pre></div>
</div>
</div></blockquote>
<p>cl(1).imnames(1:5,:)</p>
</dd></dl>

<dl class="function">
<dt id="diagnostics.compare_subjects">
<code class="descclassname">diagnostics.</code><code class="descname">compare_subjects</code><span class="sig-paren">(</span><em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#diagnostics.compare_subjects" title="Permalink to this definition">¶</a></dt>
<dd><p>This function compares the GLOBAL signal
after standardizing each image, in case 1
or the REGIONAL values in each cluster, in case 2
...and does some diagnostics on the similarity
between images.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>function [ds, g, mystd, d, d2, c, c2, mi, b, eigv, eigval] = compare_subjects([img files or clusters], [mask], ...
                                   [plot flag], [title on figure], [standardize flag], [text labels], [ref image])
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Inputs:</th><td class="field-body"><p class="first">a list of image names to compare</p>
<p>OR</p>
<p class="last">a clusters structure, with data to compare
in timeseries field</p>
</td>
</tr>
</tbody>
</table>
<p>If a mask is entered, only voxels in the mask (e.g., with value of 1) will be used.
You can use this option to specify brain-only or gray-matter only voxels</p>
<p>textlab: optional text labels for each image, can be empty []</p>
<p>If a ref image is entered, each image will be correlated with the ref,
and values will be saved for the correlation (plot 2 will show these values)
Useful for comparing anatomical imgs with template, etc.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Outputs:</th><td class="field-body"><p class="first">from correls with ref image are in variable &#8220;c&#8221;</p>
<dl class="docutils">
<dt><strong>ds:</strong></dt>
<dd><p class="first last">multivariate distance (sim. to Mahalanobis) for each image
ds is a matrix of squared distances, case numbers, and
expected chi2 values (in columns in this order) rows are cases</p>
</dd>
<dt><strong>g:</strong></dt>
<dd><p class="first last">global value for each image</p>
</dd>
<dt><strong>d:</strong></dt>
<dd><p class="first last">global distance from mean image
distance, or dissimilarity, is the average absolute deviation between images</p>
</dd>
<dt><strong>d2:</strong></dt>
<dd><p class="first last">matrix of distances among all images</p>
</dd>
<dt><strong>c:</strong></dt>
<dd><p class="first last">correlation between real valued voxels and mean image</p>
</dd>
<dt><strong>c2:</strong></dt>
<dd><p class="first last">correlations among all images (treating voxels as cases)</p>
</dd>
<dt><strong>mi:</strong></dt>
<dd><p class="first last">mutual information between images, with hist2.m</p>
</dd>
<dt><strong>b:</strong></dt>
<dd><p class="first last">principal component scores on correlation matrix for eigenvalues &gt; 1</p>
</dd>
<dt><strong>eigv:</strong></dt>
<dd><p class="first last">eigenvectors</p>
</dd>
<dt><strong>eigval:</strong></dt>
<dd><p class="first last">eigenvalues</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Examples:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>% Compare normalized anatomcals with standard brain
P = get_filename2([&#39;sub*\Anatomy\nscalped_ft1.img&#39;]);
[ds, g, mystd, d, d2, c, c2, mi] = compare_subjects(P, which(&#39;brain_avg152T1.img&#39;), 1, &#39;intext_countloc&#39;, 1, [], which(&#39;avg152T1.img&#39;));
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="diagnostics.compare_subjects256">
<code class="descclassname">diagnostics.</code><code class="descname">compare_subjects256</code><span class="sig-paren">(</span><em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#diagnostics.compare_subjects256" title="Permalink to this definition">¶</a></dt>
<dd><p>This function compares the GLOBAL signal
after standardizing each image, in case 1
or the REGIONAL values in each cluster, in case 2
...and does some diagnostics on the similarity 
between images.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>function [ds,g,mystd,d,d2,c,c2,mi,b,eigv,eigval] = compare_subjects256([img files or clusters],[mask], ...
                               [plot flag],[title on figure],[standardize flag],[text labels],[ref image])
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Inputs:</th><td class="field-body"><p class="first">a list of image names to compare</p>
<p>OR</p>
<p class="last">a clusters structure, with data to compare
in timeseries field</p>
</td>
</tr>
</tbody>
</table>
<p>If a mask is entered, only voxels in the mask (e.g., with value of 1) will be used.
You can use this option to specify brain-only or gray-matter only voxels</p>
<p>textlab: optional text labels for each image, can be empty []</p>
<p>If a ref image is entered, each image will be correlated with the ref,
and values will be saved for the correlation (plot 2 will show these values)
Useful for comparing anatomical imgs with template, etc.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Outputs:</th><td class="field-body"><p class="first">from correls with ref image are in variable &#8220;c&#8221;</p>
<dl class="docutils">
<dt><strong>ds:</strong></dt>
<dd><p class="first last">multivariate distance (sim. to Mahalanobis) for each image
ds is a matrix of squared distances, case numbers, and
expected chi2 values (in columns in this order) rows are cases</p>
</dd>
<dt><strong>g:</strong></dt>
<dd><p class="first last">global value for each image</p>
</dd>
<dt><strong>d:</strong></dt>
<dd><p class="first last">global distance from mean image
distance, or dissimilarity, is the average absolute deviation between images</p>
</dd>
<dt><strong>d2:</strong></dt>
<dd><p class="first last">matrix of distances among all images</p>
</dd>
<dt><strong>c:</strong></dt>
<dd><p class="first last">correlation between real valued voxels and mean image</p>
</dd>
<dt><strong>c2:</strong></dt>
<dd><p class="first last">correlations among all images (treating voxels as cases)</p>
</dd>
<dt><strong>mi:</strong></dt>
<dd><p class="first last">mutual information between images, with hist2.m</p>
</dd>
<dt><strong>b:</strong></dt>
<dd><p class="first last">principal component scores on correlation matrix for eigenvalues &gt; 1</p>
</dd>
<dt><strong>eigv:</strong></dt>
<dd><p class="first last">eigenvectors</p>
</dd>
<dt><strong>eigval:</strong></dt>
<dd><p class="first last">eigenvalues</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Examples:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>% Compare normalized anatomcals with standard brain
P = get_filename2([&#39;sub*\Anatomy\nscalped_ft1.img&#39;]);
[ds,g,mystd,d,d2,c,c2,mi] = compare_subjects256(P,which(&#39;brain_avg152T1.img&#39;),1,&#39;intext_countloc&#39;,1,[],which(&#39;avg152T1.img&#39;));
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="diagnostics.displayme">
<code class="descclassname">diagnostics.</code><code class="descname">displayme</code><span class="sig-paren">(</span><em>mm</em>, <em>txtlab</em>, <em>tlab2</em><span class="sig-paren">)</span><a class="headerlink" href="#diagnostics.displayme" title="Permalink to this definition">¶</a></dt>
<dd><p>Used in img_hist2 - included as internal function there.
this function is for indepenent re-display after img_hist2 is finished.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="n">function</span> <span class="p">[</span><span class="n">subjM</span><span class="p">,</span><span class="n">Mtotalv</span><span class="p">]</span> <span class="o">=</span> <span class="n">displayme</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span><span class="n">txtlab</span><span class="p">,</span><span class="n">tlab2</span><span class="p">)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>% TO run:
[O.subjM,O.Mtotalv] = displayme(O.m,txtlab,&#39;MEANS&#39;);
[O.subjS,O.Stotalv] = displayme(O.s,txtlab,&#39;STD&#39;);
[O.subjW,O.Wtotalv] = displayme(O.w,txtlab,&#39;SKEWNESS&#39;);
[O.subjK,O.Ktotalv] = displayme(O.k,txtlab,&#39;KURTOSIS&#39;);
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="diagnostics.ellipse">
<code class="descclassname">diagnostics.</code><code class="descname">ellipse</code><span class="sig-paren">(</span><em>x</em>, <em>v1</em>, <em>v2</em>, <em>c</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#diagnostics.ellipse" title="Permalink to this definition">¶</a></dt>
<dd><p>Gives x and y coordinates for an ellipse, given x coordinates,
at a distance of c</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>[x,y] = ellipse(x,v1,v2,c,[sorting method])
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Inputs:</th><td class="field-body"><p class="first">Based on the formula for an ellipse, x^2/v1^2 + y^2/v2^2 = c</p>
<dl class="docutils">
<dt><strong>c:</strong></dt>
<dd><p class="first last">is the distance from the origin</p>
</dd>
<dt><strong>v1:</strong></dt>
<dd><p class="first last">is the x half-length</p>
</dd>
<dt><strong>v2:</strong></dt>
<dd><p class="first last">is the y half-length</p>
</dd>
<dt><strong>x:</strong></dt>
<dd><p class="first last">is a vector of points covering the x coordinates in the ellipse</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Sorting methods:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body"><ul class="first simple">
<li>sort by x, produces elliptical line in plot</li>
<li>sort by y, produces horizontal lines in plot</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Examples:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>[x,y]=ellipse((randn(1000,1)),1.5,2.5,1); figure; hh = plot(x(2:end-1),y(2:end-1),&#39;r-&#39;)
rotate(hh,[0 90],45)  % rotate around z-axis by 45 degrees
x2 = get(hh,&#39;XData&#39;); y2 = get(hh,&#39;YData&#39;); hold on; plot(x2,y2,&#39;bx&#39;);
rotate(hh,[0 90],-45)  % rotate original ellipse back

% fill
fill(x,y,&#39;r&#39;,&#39;FaceAlpha&#39;,.2)
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="diagnostics.fft_calc">
<code class="descclassname">diagnostics.</code><code class="descname">fft_calc</code><span class="sig-paren">(</span><em>dat</em>, <em>TR</em><span class="sig-paren">)</span><a class="headerlink" href="#diagnostics.fft_calc" title="Permalink to this definition">¶</a></dt>
<dd><p>Simple function to calculate the FFT power of a 
data vector (dat) as a function of frequency,
given a sample-to-sample repetition time (TR)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="p">[</span><span class="n">myfft</span><span class="p">,</span> <span class="n">freq</span><span class="p">]</span> <span class="o">=</span> <span class="n">fft_calc</span><span class="p">(</span><span class="n">dat</span><span class="p">,</span> <span class="n">TR</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="diagnostics.fmri_mask_thresh_canlab">
<code class="descclassname">diagnostics.</code><code class="descname">fmri_mask_thresh_canlab</code><span class="sig-paren">(</span><em>fmri_file</em>, <em>outputname</em>, <em>implicit_masking_method</em>, <em>plotfigs</em><span class="sig-paren">)</span><a class="headerlink" href="#diagnostics.fmri_mask_thresh_canlab" title="Permalink to this definition">¶</a></dt>
<dd><p>Implicit determination of which voxels are in-brain, based on the intensities of
functional images.  Assumes much (most) of the image has near-zero
background noise values, and the in-brain values are substantially
higher.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="p">[</span><span class="n">mask_thresh</span><span class="p">,</span> <span class="n">cl</span><span class="p">,</span> <span class="n">inmaskvox</span><span class="p">,</span> <span class="n">in_mask_logical_vector</span><span class="p">,</span> <span class="n">maskfilename</span><span class="p">]</span> <span class="o">=</span> <span class="n">fmri_mask_thresh_canlab</span><span class="p">(</span><span class="n">fmri_file</span><span class="p">,</span> <span class="n">outputname</span><span class="p">)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Inputs:</th><td class="field-body"><dl class="first docutils">
<dt><strong>fmri_file:</strong></dt>
<dd><p class="first last">is either a list of file names or an fmri_data object</p>
</dd>
<dt><strong>File names:</strong></dt>
<dd><p class="first last">a (preferably) 4-D file of imaging data, Analyze .img or .nii</p>
</dd>
<dt><strong>fmri_data object:</strong></dt>
<dd><p class="first last">With multiple images loaded with <em>no</em> mask</p>
</dd>
<dt><strong>outputname:</strong></dt>
<dd><p class="first last">is a mask file output name, e.g., &#8216;mask.img&#8217;, with .img
extension. Empty [] means do not write output image.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Implicit_masking_method:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body"><dl class="first docutils">
<dt><strong>mean:</strong></dt>
<dd><blockquote class="first">
<div><p>take the top 95% of voxels above the mean value.  used by</p>
</div></blockquote>
<p class="last">default if no value is entered</p>
</dd>
<dt><strong>dip:</strong></dt>
<dd><blockquote class="first">
<div><p>smooth the histogram and take the top 95% of values above the</p>
</div></blockquote>
<p class="last">first positive gradient</p>
</dd>
<dt><a href="#id15"><span class="problematic" id="id16">**</span></a>plotfigs</dt>
<dd><p class="first last">[1/0]: enable or suppress mask display and orthviews</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Outputs:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>mask_thresh:</strong></dt>
<dd><p class="first last">signal-value above which voxels are considered in brain</p>
</dd>
<dt><strong>c1:</strong></dt>
<dd><p class="first last">clusters, from iimg_indx2clusters</p>
</dd>
<dt><strong>inmaskvox:</strong></dt>
<dd><p class="first last">number of inmask voxels</p>
</dd>
<dt><strong>dat:</strong></dt>
<dd><p class="first last">binary matrix of voxels that are in (1) or out (0) of mask</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p>Note: we want to be more inclusive than not at this stage.</p>
<p>last edited Oct 2011 - add support for fmri_data/image_vector objects
added figure suppression, SG 12/14/15
defaults</p>
</dd></dl>

<dl class="function">
<dt id="diagnostics.get_filename">
<code class="descclassname">diagnostics.</code><code class="descname">get_filename</code><span class="sig-paren">(</span><em>dwcard</em>, <em>wcard</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#diagnostics.get_filename" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>function P = get_filename(dir_wcard,file_wcard,[verbose])
</pre></div>
</div>
<p>Start in directory above individual subject directories</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Inputs:</th><td class="field-body"><dl class="first docutils">
<dt><strong>dwcard:</strong></dt>
<dd><p class="first last">Enter dwcard for wildcard of directories to look in; e.g. &#8216;02*&#8217;</p>
</dd>
<dt><strong>wcard:</strong></dt>
<dd><p class="first last">Enter wcard for image or file to get - e.g., &#8216;beta_0001.img&#8217;
This can also include subdirectories (no <a href="#id17"><span class="problematic" id="id18">*</span></a>&#8216;s) &#8216;anatomy/beta*img&#8217;</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Output:</th><td class="field-body"><p class="first last">Returns list of all files in individual directories  in string matrix</p>
</td>
</tr>
</tbody>
</table>
<p>Missing files, or entries in directory that do not contain files, are 
removed from the list.</p>
<p>NOT entering a * in dwcard seems to produce an error.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Examples:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="n">P</span> <span class="o">=</span> <span class="n">get_filename</span><span class="p">(</span><span class="s">&#39;02*&#39;</span><span class="p">,</span><span class="s">&#39;beta_0001*&#39;</span><span class="p">)</span>
<span class="n">P</span> <span class="o">=</span> <span class="n">get_filename</span><span class="p">(</span><span class="s">&#39;02*&#39;</span><span class="p">,</span><span class="s">&#39;beta_0001.img&#39;</span><span class="p">)</span>
<span class="n">P</span> <span class="o">=</span> <span class="n">get_filename</span><span class="p">(</span><span class="s">&#39;02*&#39;</span><span class="p">,</span><span class="s">&#39;anatomy/nnhe*_seg1.img&#39;</span><span class="p">)</span>
<span class="n">P</span> <span class="o">=</span> <span class="n">get_filename</span><span class="p">(</span><span class="s">&#39;020515sp*&#39;</span><span class="p">,</span><span class="s">&#39;anatomy/nnhe*_seg1.img&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>one * is allowed in first string, multiple <a href="#id19"><span class="problematic" id="id20">*</span></a>&#8216;s in second,
as long as they are in the filename, not directory names!</p>
</dd></dl>

<dl class="function">
<dt id="diagnostics.get_filename2">
<code class="descclassname">diagnostics.</code><code class="descname">get_filename2</code><span class="sig-paren">(</span><em>dwcard</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#diagnostics.get_filename2" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>function [P,P2,d] = get_filename2(search string (as with ls command),[verbose])
</pre></div>
</div>
<p>Start in directory above individual subject directories</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Inputs:</th><td class="field-body"><dl class="first docutils">
<dt><strong>dwcard:</strong></dt>
<dd><p class="first last">Enter dwcard for wildcard of directories to look in; e.g. &#8216;02*&#8217;</p>
</dd>
<dt><strong>wcard:</strong></dt>
<dd><p class="first last">Enter wcard for image or file to get - e.g., &#8216;beta_0001.img&#8217;
This can also include subdirectories (no <a href="#id21"><span class="problematic" id="id22">*</span></a>&#8216;s) &#8216;anatomy/beta*img&#8217;</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Outputs:</th><td class="field-body"><blockquote class="first">
<div><p>Returns list of all files in individual directories  in string matrix</p>
</div></blockquote>
<dl class="last docutils">
<dt><strong>P:</strong></dt>
<dd><p class="first last">file names with full paths</p>
</dd>
<dt><strong>P2:</strong></dt>
<dd><p class="first last">file names only</p>
</dd>
<dt><strong>d:</strong></dt>
<dd><p class="first last">list of directories searched for files</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p>Missing files, or entries in directory that do not contain files, are 
removed from the list.
NOT entering a * in dwcard seems to produce an error.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Examples:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="n">P</span> <span class="o">=</span> <span class="n">get_filename2</span><span class="p">(</span><span class="s">&#39;02*/beta_0001*&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>one * is allowed in the directory structure right now, 
multiple <a href="#id23"><span class="problematic" id="id24">*</span></a>&#8216;s in the filename.</p>
</dd></dl>

<dl class="function">
<dt id="diagnostics.hist2">
<code class="descclassname">diagnostics.</code><code class="descname">hist2</code><span class="sig-paren">(</span><em>A</em>, <em>B</em>, <em>res</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#diagnostics.hist2" title="Permalink to this definition">¶</a></dt>
<dd><p>2-D histogram with res bins</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="p">[</span><span class="n">H</span><span class="p">,</span><span class="n">mi</span><span class="p">,</span><span class="n">H2</span><span class="p">]</span> <span class="o">=</span> <span class="n">hist2</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">B</span><span class="p">,</span><span class="n">res</span><span class="p">,[</span><span class="n">plot</span><span class="p">])</span>
</pre></div>
</div>
<p>A and B can be 3D, as in image volumes
mi is mutual information, a la spm_mireg.m</p>
</dd></dl>

<dl class="function">
<dt id="diagnostics.image_intensity_histograms">
<code class="descclassname">diagnostics.</code><code class="descname">image_intensity_histograms</code><span class="sig-paren">(</span><em>fout</em>, <em>imgs</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#diagnostics.image_intensity_histograms" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Makes a sheet (fout.png) of intensity distribution histograms of imgs.</dt>
<dd>Will put an even number of rows of subplots on each page saved.
If more than one page is needed, will title outputs fout_1.png, etc.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="n">image_intensity_histograms</span><span class="p">(</span><span class="n">fout</span><span class="p">,</span> <span class="n">imgs</span><span class="p">,</span> <span class="p">[</span><span class="n">options</span><span class="p">])</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Inputs:</th><td class="field-body"><dl class="first docutils">
<dt><strong>fout:</strong></dt>
<dd><p class="first last">imfilename to be saved (&#8216;.png&#8217; will be appended)</p>
</dd>
<dt><strong>imgs:</strong></dt>
<dd><p class="first last">ima cell array of filenames of images to make histograms of</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Optional Inputs:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body"><dl class="first last docutils">
<dt><strong>obj:</strong></dt>
<dd><p class="first last">im</p>
</dd>
<dt><strong>&#8216;titles&#8217;, cellarray:</strong></dt>
<dd><p class="first last">use strings in cellarray as plot titles (DEFAULT: use file names from imgs)</p>
</dd>
<dt><strong>&#8216;bins&#8217;, n:</strong></dt>
<dd><p class="first last">use n bins in histograms (DEFAULT: 100)</p>
</dd>
<dt><strong>&#8216;ymax&#8217;, y:</strong></dt>
<dd><p class="first last">use y-axis from 0 to y (DEFAULT: 10,000)</p>
</dd>
<dt><strong>&#8216;xmax&#8217;, x:</strong></dt>
<dd><p class="first last">use x-axis from -x to x (DEFAULT: 10)</p>
</dd>
<dt><strong>&#8216;cols&#8217;, c:</strong></dt>
<dd><p class="first last">use c columns of subplots (DEFAULT: 5)</p>
</dd>
<dt><strong>&#8216;maxrows&#8217;, r:</strong></dt>
<dd><p class="first last">use no more than r columns of subplots per page (DEFAULT: 7)</p>
</dd>
<dt><strong>&#8216;includezeros&#8217;:</strong></dt>
<dd><p class="first last">include zero intensities in histograms (DEFAULT: exclude zeros)</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p>Tor Wager
..
add path if necessary</p>
</dd></dl>

<dl class="function">
<dt id="diagnostics.img_hist">
<code class="descclassname">diagnostics.</code><code class="descname">img_hist</code><span class="sig-paren">(</span><em>imgname</em>, <em>subdir</em><span class="sig-paren">)</span><a class="headerlink" href="#diagnostics.img_hist" title="Permalink to this definition">¶</a></dt>
<dd><p>A general function for plotting histograms of any image
For each subject, comparing across subjects</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Inputs:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>imgname:</strong></dt>
<dd><p class="first last">name of image file to make intensity histograms from</p>
</dd>
<dt><strong>subdir:</strong></dt>
<dd><p class="first last">cell array of text strings containing names of individual subject
directories (wherein are contained the file specified in imgname 
or each subject)</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p>Performs the histogram plot twice, once for CSF space
and once for gray matter</p>
<p>Locations of gray and CSF masks for each subject must
be defined in the defaults section of the script.
(hard-coded)</p>
<p>Start in directory above individual subject results</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Examples:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>img_hist(&#39;beta_0010.img&#39;,subdir)
img_hist(&#39;con_0002.img&#39;,{&#39;020827mk&#39; &#39;020829jh&#39; &#39;020903lb&#39;}

% for batch
d = dir(&#39;020726ag/beta*img&#39;); d = str2mat(d.name);
for i = 1:10:size(d,1)
    img_hist(deblank(d(i,:)),EXPT.subjects)
end

for i = 2:19, 
   if i &lt; 10, myz = &#39;000&#39;;, else, myz = &#39;00&#39;;, end, 
   img_hist([&#39;con_&#39; myz num2str(i) &#39;.img&#39;],EXPT.subjects);, 
end
</pre></div>
</div>
<p>Tor Wager
..
..</p>
<blockquote>
<div>defaults</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="diagnostics.img_hist2">
<code class="descclassname">diagnostics.</code><code class="descname">img_hist2</code><span class="sig-paren">(</span><em>subdir</em><span class="sig-paren">)</span><a class="headerlink" href="#diagnostics.img_hist2" title="Permalink to this definition">¶</a></dt>
<dd><p>A general function for plotting histograms of any image
For each subject, comparing across subjects</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Inputs:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>imgname:</strong></dt>
<dd><p class="first last">name of image file to make intensity histograms from</p>
</dd>
<dt><strong>subdir:</strong></dt>
<dd><p class="first last">cell array of text strings containing names of individual subject
directories (wherein are contained the file specified in imgname 
or each subject)</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p>Performs the histogram plot a number of times, without plotting
and reports the variance in pdf moments as a function of subject, 
run, and condition (beta img within run).</p>
<p>Start in directory above individual subject results</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Examples:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="n">img_hist2</span><span class="p">(</span><span class="n">EXPT</span><span class="o">.</span><span class="n">subjects</span><span class="p">)</span>
<span class="n">img_hist2</span><span class="p">({</span><span class="s">&#39;020827mk&#39;</span> <span class="s">&#39;020829jh&#39;</span> <span class="s">&#39;020903lb&#39;</span><span class="p">})</span>
</pre></div>
</div>
<p>Tor Wager
..
..</p>
<blockquote>
<div>defaults</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="diagnostics.joint_hist">
<code class="descclassname">diagnostics.</code><code class="descname">joint_hist</code><span class="sig-paren">(</span><em>x</em>, <em>y</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#diagnostics.joint_hist" title="Permalink to this definition">¶</a></dt>
<dd><p>Create 2-D joint histogram from vectors x and y</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="p">[</span><span class="n">z</span><span class="p">,</span> <span class="n">xbins</span><span class="p">,</span> <span class="n">ybins</span><span class="p">]</span> <span class="o">=</span> <span class="n">joint_hist</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,[</span><span class="n">nbins</span><span class="p">],[</span><span class="n">noplot</span><span class="p">])</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Inputs:</th><td class="field-body"><dl class="first docutils">
<dt>x and y:**</dt>
<dd><p class="first last">are vectors of paired observations on two variables</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Outputs:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>z:</strong></dt>
<dd><p class="first last">is the matrix representing the joint histogram
cols of z are bins of x, rows are bins of y
in plot, X axis is y, Y axis is x</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p>Optional: number of bins, suppress plotting</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Examples:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>z = joint_hist(nnmfscores{i}{j}(:, 1),nnmfscores{i}{j}(:, 2), 50, &#39;noplot&#39;);
h = plot_joint_hist_contour(z, [0 0 1]);
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="diagnostics.make_conv_mtx">
<code class="descclassname">diagnostics.</code><code class="descname">make_conv_mtx</code><span class="sig-paren">(</span><em>sz</em>, <em>sampres</em><span class="sig-paren">)</span><a class="headerlink" href="#diagnostics.make_conv_mtx" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructs the matrix (H) for a linear convolution
With the canonical SPM hrf
such that Hx = conv(x,hrf)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>function H = make_conv_mtx(sz,sampres)
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Inputs:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>sz:</strong></dt>
<dd><p class="first last">size of output matrix (elements)</p>
</dd>
<dt><strong>sampres:</strong></dt>
<dd><p class="first">spm_hrf sampling resolution (~ TR), OR</p>
<p class="last">if a vector, a custom HRF
sampled at the appropriate frequency.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p>Tor Wager
..</p>
</dd></dl>

<dl class="function">
<dt id="diagnostics.multivar_dist">
<code class="descclassname">diagnostics.</code><code class="descname">multivar_dist</code><span class="sig-paren">(</span><em>X</em><span class="sig-paren">)</span><a class="headerlink" href="#diagnostics.multivar_dist" title="Permalink to this definition">¶</a></dt>
<dd><p>multivariate normality checking and diagnostic plots</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="p">[</span><span class="n">ds</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="n">multivar_dist</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Input:</th><td class="field-body"><p class="first">given matrix X with cases = rows, cols = variables</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Outputs:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>ds:</strong></dt>
<dd><p class="first">is matrix of squared distances, case numbers, and
expected chi2 values (in columns in this order)
rows are cases</p>
<p class="last">NOTE: Sorted in order of ascending distance!</p>
</dd>
<dt><strong>S:</strong></dt>
<dd><p class="first last">estimated covariance matrix</p>
</dd>
<dt><strong>mv_distance:</strong></dt>
<dd><p class="first last">squared distances in original order of rows</p>
</dd>
<dt><strong>p:</strong></dt>
<dd><p class="first last">p-values in original order of rows</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p>center</p>
</dd></dl>

<dl class="function">
<dt id="diagnostics.orthogonalize">
<code class="descclassname">diagnostics.</code><code class="descname">orthogonalize</code><span class="sig-paren">(</span><em>mX</em>, <em>X</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#diagnostics.orthogonalize" title="Permalink to this definition">¶</a></dt>
<dd><p>orthogonalizes X with respect to mX, optionally scaling predictors of X
For each nuisance covariate (column of X)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>function X = orthogonalize(mX,X,[scale])
</pre></div>
</div>
<p>Regresses out model fits and saves residuals in X</p>
</dd></dl>

<dl class="function">
<dt id="diagnostics.power_from_variance">
<code class="descclassname">diagnostics.</code><code class="descname">power_from_variance</code><span class="sig-paren">(</span><em>con</em>, <em>N</em>, <em>sig2b</em>, <em>sig2wi</em>, <em>pthresh</em><span class="sig-paren">)</span><a class="headerlink" href="#diagnostics.power_from_variance" title="Permalink to this definition">¶</a></dt>
<dd><p>Power and effect size measures, given contrast, N, and variance component
estimates</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Inputs:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>con:</strong></dt>
<dd><p class="first last">contrast/effect magnitude estimate; &#8220;mean difference&#8221;</p>
</dd>
<dt><strong>N:</strong></dt>
<dd><p class="first last">sample size</p>
</dd>
<dt><strong>sig2b:</strong></dt>
<dd><p class="first last">between-subjects variance estimate</p>
</dd>
<dt><strong>sig2wi:</strong></dt>
<dd><dl class="first last docutils">
<dt>within-subjects variance estimate</dt>
<dd><p class="first last"><em>note</em> this is not the &#8220;raw&#8221; within-subjects variance; it is
the contribution to the group (2nd-level) variance, which is
sig2within / number of images within-subjects</p>
</dd>
</dl>
</dd>
<dt><strong>pthresh:</strong></dt>
<dd><dl class="first last docutils">
<dt>alpha (Type I error) rate; p-value threshold for power</dt>
<dd><p class="first last">calculation</p>
</dd>
</dl>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p>con, sig2b, and sig2wi can all be vectors, so you can run this function
voxel-wise for a whole map at once</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Outputs:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>power:</strong></dt>
<dd><p class="first last">Power from 0 to 1</p>
</dd>
<dt><strong>t:</strong></dt>
<dd><p class="first last">effect size : expected t-value</p>
</dd>
<dt><strong>d:</strong></dt>
<dd><p class="first last">effect size : Cohen&#8217;s d</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p>see effect_size_map.m for a whole-brain, image-based power mapping
function</p>
<p>t-value threshold for significance at alpha level pthresh</p>
</dd></dl>

<dl class="function">
<dt id="diagnostics.power_loss">
<code class="descclassname">diagnostics.</code><code class="descname">power_loss</code><span class="sig-paren">(</span><em>y</em>, <em>ons</em>, <em>X</em><span class="sig-paren">)</span><a class="headerlink" href="#diagnostics.power_loss" title="Permalink to this definition">¶</a></dt>
<dd><p>&#8216;true&#8217; model fit
assume &#8216;true&#8217; is FIR estimate</p>
</dd></dl>

<dl class="function">
<dt id="diagnostics.publish_scn_session_spike_id">
<code class="descclassname">diagnostics.</code><code class="descname">publish_scn_session_spike_id</code><span class="sig-paren">(</span><em>inputimgs</em>, <em>SUBJDATA</em><span class="sig-paren">)</span><a class="headerlink" href="#diagnostics.publish_scn_session_spike_id" title="Permalink to this definition">¶</a></dt>
<dd><p>This function is a wrapper function to call scn_session_spike_id in
&#8216;multi-session&#8217; mode, using input data across the runs for a single
subject.  It runs the program, and generates both a yaml-format text file
for uploading into the CANlab database, and an html file with all the
results and images for that subject embedded.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Inputs:</th><td class="field-body"><dl class="first docutils">
<dt><strong>inputimgs:</strong></dt>
<dd><p class="first last">is a cell array of images (4-D) for each run in a separate cell.</p>
</dd>
<dt><strong>SUBJDATA:</strong></dt>
<dd><p class="first last">Input fields of SUBJDATA define the experiment name, subject name,
and directories for saving both QC images + yaml and HTML</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Examples:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>SUBJDATA.study = &#39;NSF&#39;;
SUBJDATA.subject = subjects{i};
SUBJDATA.html_save_dir = fullfile(output_basedir, &#39;html_output&#39;);
SUBJDATA.subject_dir = fullfile(output_basedir, &#39;SubjectData&#39;, &#39;denoised_canlab&#39;, SUBJDATA.subject);
</pre></div>
</div>
<p>Initialize yaml file for database integration</p>
</dd></dl>

<dl class="function">
<dt id="diagnostics.qchist">
<code class="descclassname">diagnostics.</code><code class="descname">qchist</code><span class="sig-paren">(</span><em>images</em>, <em>Nbins</em>, <em>sparse</em>, <em>XLim</em>, <em>titles</em><span class="sig-paren">)</span><a class="headerlink" href="#diagnostics.qchist" title="Permalink to this definition">¶</a></dt>
<dd><p>This function generates a histogram of activations from a set of
statistic images.  Generally, you want the images to have a normal
distribution.  Highly skewed distributions may be indicative of bad
data.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>function: h = qchist(dat,Nbins,sparse,XLim)

  This function may generate multiple figuresa with 30 histograms
  each
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Inputs:</th><td class="field-body"><dl class="first docutils">
<dt><strong>images:</strong></dt>
<dd><p class="first last">List of image file names OR fmri_data object.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Optional Inputs:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body"><dl class="first last docutils">
<dt><strong>Nbins:</strong></dt>
<dd><p class="first last">Number of bins in each histogram (default = 100)</p>
</dd>
<dt><strong>sparse:</strong></dt>
<dd><p class="first last">flag for generating ONLY histograms (default = 0)</p>
</dd>
<dt><strong>XLim:</strong></dt>
<dd><p class="first last">Xlim (default = [-1 1])</p>
</dd>
<dt><strong>titles:</strong></dt>
<dd><p class="first last">a cell array of subplot titles.  If omitted, titles
are inferred from assuming images come from a
directory structure that looks like the following:
/.../subjname/contrastimage.nii</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="diagnostics.reset_SPMcfg">
<code class="descclassname">diagnostics.</code><code class="descname">reset_SPMcfg</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#diagnostics.reset_SPMcfg" title="Permalink to this definition">¶</a></dt>
<dd><p>resets columns in SPMcfg by removing all non-intercept nuisance covariates.
runs on the SPMcfg.mat file in the current directory</p>
</dd></dl>

<dl class="function">
<dt id="diagnostics.scale_imgs_by_csf">
<code class="descclassname">diagnostics.</code><code class="descname">scale_imgs_by_csf</code><span class="sig-paren">(</span><em>hP</em><span class="sig-paren">)</span><a class="headerlink" href="#diagnostics.scale_imgs_by_csf" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes a string matrix of image file names
finds the mean and std of the CSF space
specified in a mask (hard-coded)
and standardizes images by these values</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Pout</span> <span class="o">=</span> <span class="n">scale_imgs_by_csf</span><span class="p">(</span><span class="n">hP</span><span class="p">)</span>
</pre></div>
</div>
<p>Writes SC* images (SCaled)</p>
<p>assumes images are spatially normalized.
uses a canonical CSF mask!</p>
</dd></dl>

<dl class="function">
<dt id="diagnostics.scn_component_rsquare">
<code class="descclassname">diagnostics.</code><code class="descname">scn_component_rsquare</code><span class="sig-paren">(</span><em>V</em>, <em>nuisanceX</em>, <em>designX</em><span class="sig-paren">)</span><a class="headerlink" href="#diagnostics.scn_component_rsquare" title="Permalink to this definition">¶</a></dt>
<dd><p>Print a table of r-square values (variance explained) for each of V data
vectors by nuisance (mvmt, physio) and task-related predictors</p>
<p>Designed to work with components</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Examples:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>% Typical operation
scn_component_rsquare(compscore, movement_params(1:157, :), X(1:157, :));

% No design
scn_component_rsquare(compscore, movement_params(1:157, :));

% Neither design nor nuisance, uses linear drift
scn_component_rsquare(compscore, []);
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="diagnostics.scn_session_spike_id">
<code class="descclassname">diagnostics.</code><code class="descname">scn_session_spike_id</code><span class="sig-paren">(</span><em>imgs</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#diagnostics.scn_session_spike_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets global image values for a session, and uses trimts.m to find
outliers. The optional input MADs allows one to lower or raise the
threshold for identifying scans as spikes (default = 10).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>[g, spikes, gtrim, nuisance_covs, spikesperimg, snr] = scn_session_spike_id(imgs,&#39;mask&#39;,[mask name],&#39;MADs&#39;,[MADs],&#39;doplot&#39;,[0/1])
</pre></div>
</div>
<p>Multi-session mode returns much more output and more images, and
takes in a cell array with images (preferably 4-D) for each session
(run).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Inputs:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>&#8216;mask&#8217;,[pathtomaskfile]:</strong></dt>
<dd><p class="first last">mask images using the mask in pathtomaskfile, default: implicit mask</p>
</dd>
<dt><strong>&#8216;MADs&#8217;,[scalar]:</strong></dt>
<dd><p class="first last">change Mahalanobis distance, default: 10</p>
</dd>
<dt><strong>&#8216;doplot&#8217;,[0 / 1]:</strong></dt>
<dd><p class="first last">plot result figures, default: true</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p>Returns:</p>
<blockquote>
<div><dl class="docutils">
<dt><strong>g:</strong></dt>
<dd>global values</dd>
<dt><strong>spikes:</strong></dt>
<dd>identified spikes</dd>
<dt><strong>gtrim:</strong></dt>
<dd>trimmed/adjusted global values, can be used as covariate in GLM</dd>
<dt><strong>nuisance_covs:</strong></dt>
<dd>a matrix of 1)gtrim and 2) dummy regressors that can be used to minimize
spike influence in GLM</dd>
</dl>
</div></blockquote>
<p>We may want to save norms on the number of outliers found.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Examples:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>% Get image names
for i = 1:6, sess_images{i} = filenames(sprintf(&#39;run%02d/vol0*img&#39;, i), &#39;char&#39;, &#39;absolute&#39;); end

% Run
[g, spikes, gtrim, nuisance_covs, snr] = scn_session_spike_id(sess_images);
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="diagnostics.scn_spm_choose_hpfilter">
<code class="descclassname">diagnostics.</code><code class="descname">scn_spm_choose_hpfilter</code><span class="sig-paren">(</span><em>spm_results_dir</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#diagnostics.scn_spm_choose_hpfilter" title="Permalink to this definition">¶</a></dt>
<dd><p>Plots and choice of optimal high-pass filter from an SPM first-level
model directory (with statistics and contrasts estimated.)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="n">scn_spm_choose_hpfilter</span><span class="p">(</span><span class="n">spm_results_dir</span><span class="p">,</span> <span class="p">[</span><span class="s">&#39;events_only&#39;</span><span class="p">])</span>
</pre></div>
</div>
<p>SPM5 compatible and SPM8.</p>
<p>Called by: scn_spm_design_check.m
For all regressors or events only: see scn_spm_choose_hpfilter.m</p>
</dd></dl>

<dl class="function">
<dt id="diagnostics.scn_spm_design_check">
<code class="descclassname">diagnostics.</code><code class="descname">scn_spm_design_check</code><span class="sig-paren">(</span><em>spm_results_dir</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#diagnostics.scn_spm_design_check" title="Permalink to this definition">¶</a></dt>
<dd><p>Run in a single-subject (first-level) SPM directory to check 
design matrix variance inflation factors and high-pass filtering.
Prints out table of regressors and their above-threshold VIFs (see options).
Saves .png images of the key figures.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="n">scn_spm_design_check</span><span class="p">(</span><span class="n">spm_results_dir</span><span class="p">,</span> <span class="n">varargin</span><span class="p">)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name" colspan="2">Optional Inputs:</th></tr>
<tr class="field-odd field"><td>&nbsp;</td><td class="field-body"><dl class="first last docutils">
<dt><strong>&#8216;events_only&#8217;:</strong></dt>
<dd><p class="first last">Show plots and diagnostics for ONLY events, not nuisance covariates or
other user-specified regressors.  Useful when you have many nuisance
covs.</p>
</dd>
<dt><strong>&#8216;vif_thresh&#8217;, t&#8217;:</strong></dt>
<dd><p class="first last">Only regressors with a VIF &gt; t will be printed in VIF table.</p>
</dd>
<dt><strong>&#8216;sort_by_vif&#8217;&#8216;:</strong></dt>
<dd><p class="first last">Sort regressors in VIF table by VIF (DEFAULT: order regressors as in model).</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p>Calls: scn_spm_choose_hpfilter.m, scn_spm_get_events_of_interest.m</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Examples:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="n">scn_spm_design_check</span><span class="p">(</span><span class="n">pwd</span><span class="p">,</span> <span class="s">&#39;events_only&#39;</span><span class="p">);</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="diagnostics.scn_spm_get_events_of_interest">
<code class="descclassname">diagnostics.</code><code class="descname">scn_spm_get_events_of_interest</code><span class="sig-paren">(</span><em>SPM</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#diagnostics.scn_spm_get_events_of_interest" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets events of interest.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="n">wh_cols</span> <span class="o">=</span> <span class="n">scn_spm_get_events_of_interest</span><span class="p">(</span><span class="n">SPM</span><span class="p">,</span> <span class="n">varargin</span><span class="p">)</span>
</pre></div>
</div>
<p>All regressors, or events only if &#8216;events_only&#8217; is input as keyword
&#8216;from_multireg&#8217;:  followed by an integer, to include first n columns from
the multireg R matrix as &#8220;of interest&#8221;.  only works with &#8216;events_only&#8217;
flag, of course.</p>
</dd></dl>

<dl class="function">
<dt id="diagnostics.scnlab_norm_check">
<code class="descclassname">diagnostics.</code><code class="descname">scnlab_norm_check</code><span class="sig-paren">(</span><em>template</em>, <em>wanat_files</em>, <em>mean_func_files</em>, <em>subjects</em><span class="sig-paren">)</span><a class="headerlink" href="#diagnostics.scnlab_norm_check" title="Permalink to this definition">¶</a></dt>
<dd><p>Compares the similarity of one or two sets of images (wanat_files,
mean_func_files) to a template image and to one another (via Malanobis
distance) to determine whether some images are potential outliers.
This is used to check the quality of spatial warping/normalization for a
group of subjects, though it could be used for other purposes as well.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="n">NORM_CHECK</span> <span class="o">=</span> <span class="n">scnlab_norm_check</span><span class="p">(</span><span class="n">template</span><span class="p">,</span> <span class="n">wanat_files</span><span class="p">,</span> <span class="n">mean_func_files</span><span class="p">,</span> <span class="n">subjs</span><span class="p">)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Inputs:</th><td class="field-body"><dl class="first docutils">
<dt><strong>template:</strong></dt>
<dd><p class="first last">Char array with name of image of normalization template</p>
</dd>
<dt><strong>wanat_files:</strong></dt>
<dd><p class="first last">Warped (to template) anatomical file names</p>
</dd>
<dt><strong>mean_func_files:</strong></dt>
<dd><p class="first last">Names of mean functional images
These images should all be in the same space/in register.</p>
</dd>
<dt><strong>Subjs:</strong></dt>
<dd><p class="first last">Optional cell array of names for each subject, for display
purposes</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Outputs:</th><td class="field-body"><p class="first">A structure with metrics (NORM_CHECK)</p>
<dl class="last docutils">
<dt><strong>NORM_CHECK.global_t1:</strong></dt>
<dd><p class="first last">global values of first image series (wanat_files)</p>
</dd>
<dt><strong>NORM_CHECK.std_t1:</strong></dt>
<dd><p class="first last">spatial standard deviation of first image series (wanat_files)</p>
</dd>
<dt><strong>NORM_CHECK.names_t1:</strong></dt>
<dd><p class="first last">Names for columns of NORM_CHECK.norm_vs_template</p>
</dd>
<dt><strong>NORM_CHECK.subjects:</strong></dt>
<dd><p class="first last">Cell array of names for each subject</p>
</dd>
<dt><strong>NORM_CHECK.norm_vs_template:</strong></dt>
<dd><dl class="first last docutils">
<dt>Similarity data for subjects (rows) x metrics (cols)</dt>
<dd><p class="first last">{&#8216;Dist. from group, actual chi2&#8217;, &#8216;Mutual info with template&#8217;, &#8216;Correlation with template&#8217;};</p>
</dd>
</dl>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p>NB: Leave mean_func_files empty (e.g., []) to only check structural images</p>
<p>Computes metrics on the goodness of normalization based on multivariate distance,
mutual information, and correlation with template. Automatically saves a .mat file
of the results into the current directory.</p>
<p>the template file (i.e., avg152T1.nii) must be in the CURRENT working
directory and have read/write permissions</p>
<p>USES the subfunction compare_subjects, which may be useful as a
stand-alone function.</p>
<p>USED in canlab_preproc_norm_check.m</p>
</dd></dl>

<dl class="function">
<dt id="diagnostics.scnlab_norm_check3">
<code class="descclassname">diagnostics.</code><code class="descname">scnlab_norm_check3</code><span class="sig-paren">(</span><em>wt1</em>, <em>subjlabels</em>, <em>template</em>, <em>mask</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#diagnostics.scnlab_norm_check3" title="Permalink to this definition">¶</a></dt>
<dd><p>WARNING:  scnlab_norm_check3 is deprecated! All improvements are being placed in scnlab_norm_check.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>EXPT = scnlab_norm_check3(wt1,subjlabels,template,mask,[print out MI])
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Inputs:</th><td class="field-body"><dl class="first docutils">
<dt><strong>wt1:</strong></dt>
<dd><p class="first last">char array of wT1.img files, one per line</p>
</dd>
<dt><strong>subjlabels:</strong></dt>
<dd><p class="first last">cell array of subject labels</p>
</dd>
<dt><strong>template:</strong></dt>
<dd><p class="first last">template img that everything has been normalized to (usually the avg152T1.img file)</p>
</dd>
<dt><strong>mask:</strong></dt>
<dd><p class="first last">image to mask with</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Optional Input:</th><td class="field-body"><p class="first">print out mutual information table - flag for whether or not to print out the MI table; defaults to 0</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Examples:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>cd(studyroot); % wherever your study root is
wt1s = filenames(&#39;hr*/structural/wT1.img&#39;, &#39;char&#39;, &#39;absolute&#39;); % assuming that hr is your study code
subjlabels = filenames(&#39;hr*&#39;);
template = which(&#39;avg152T1.nii&#39;);
mask = filenames(&#39;scalped_avg152T1_graymatter.img&#39;, &#39;char&#39;, &#39;absolute&#39;); % set to wherever your mask is...

EXPT = scnlab_norm_check3(wt1, subjlabels, template, mask);
</pre></div>
</div>
<p>THIS FUNCTION IS DEPRECATED; SCNLAB_NORM_CHECK IS PREFERRED</p>
</dd></dl>

<dl class="function">
<dt id="diagnostics.scnlab_pca_check1">
<code class="descclassname">diagnostics.</code><code class="descname">scnlab_pca_check1</code><span class="sig-paren">(</span><em>imgs</em>, <em>realign_files</em>, <em>X</em>, <em>spersess</em><span class="sig-paren">)</span><a class="headerlink" href="#diagnostics.scnlab_pca_check1" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>function scnlab_pca_check1(imgs, realign_files or params (t x 6) across all runs, X, spersess)
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Inputs:</th><td class="field-body"><dl class="first docutils">
<dt><strong>imgs:</strong></dt>
<dd><p class="first last">list of all image names in order</p>
</dd>
<dt><strong>realign_files:</strong></dt>
<dd><p class="first">movement param file for each session, names in a cell array, OR</p>
<p class="last">a t x 6 matrix of realignment parameters across all sessions</p>
</dd>
<dt><strong>X:</strong></dt>
<dd><p class="first last">design matrix; no intercept is needed</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Examples:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>% setup code for auditory oddball data
cd(&#39;/Users/tor/Documents/Tor_Documents/Coursework_and_Teaching/Mind_Res_Net_fMRI_Course_2008/data/auditory_oddball/2subjects-processed/s01/&#39;)

imgs = filenames(&#39;*/sw*img&#39;,&#39;absolute&#39;,&#39;char&#39;)
realign_files = filenames(&#39;*/rp*txt&#39;)

% LOAD TASK ONSETS and CREATE DESIGN MATRIX
onsets{1} = load(&#39;novel_stimuli_run1.asc&#39;);
onsets{2} = load(&#39;target_stimuli_run1.asc&#39;);
onsets{3} = load(&#39;standard_stimuli_run1.asc&#39;);
onsets{4} = load(&#39;novel_stimuli_run2.asc&#39;);
onsets{5} = load(&#39;target_stimuli_run2.asc&#39;);
onsets{6} = load(&#39;standard_stimuli_run2.asc&#39;);

regs_per_sess = 3;
nsess = 2;
for i = 1:length(onsets), onsets{i} = onsets{i}&#39;; end
X = cell(1, nsess);
X{1} = onsets2delta(onsets(1:3), 1, 249);
X{1} = X{1}(:, 1:end-1);
X{2} = onsets2delta(onsets(4:6), 1, 249);
X{2} = X{2}(:, 1:end-1);
X = blkdiag(X{:});
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="diagnostics.spm_general_hist">
<code class="descclassname">diagnostics.</code><code class="descname">spm_general_hist</code><span class="sig-paren">(</span><em>hP</em>, <em>mP</em>, <em>textlab</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#diagnostics.spm_general_hist" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>function M = spm_general_hist(hP,mP,textlab,[suppress plot - enter anything])
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Inputs:</th><td class="field-body"><dl class="first docutils">
<dt><strong>hP:</strong></dt>
<dd><p class="first last">list of file names to compute histograms from</p>
</dd>
<dt><strong>mP:</strong></dt>
<dd><p class="first last">list of file names to compute masks from</p>
</dd>
<dt><strong>textlab:</strong></dt>
<dd><p class="first last">text string, e.g. &#8216;ventricles&#8217; to label output tiffs</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Output:</th><td class="field-body"><p class="first last">histograms for all input images (usually contrast images from individual
subjects) plotted against a normal curve.</p>
</td>
</tr>
</tbody>
</table>
<p>The expected output is that each image will have roughly mean 0, with
bumps or tails in the distribution of there are real activations in some
parts of the brain.</p>
<p>Looking at these histograms may be helpful for detecting outliers or 
subjects with strange contrast values.  These may be caused by
bad scaling, multicolinearity in the design matrix, acquisition artifacts,
task-correlated head movement, or ???</p>
<p>Histograms (blue) are overlaid on a Gaussian distribution (red)
with a mean of 0 and a standard deviation equal to that of the observed data.</p>
</dd></dl>

<dl class="function">
<dt id="diagnostics.spm_rfx_hist">
<code class="descclassname">diagnostics.</code><code class="descname">spm_rfx_hist</code><span class="sig-paren">(</span><em>cwd</em><span class="sig-paren">)</span><a class="headerlink" href="#diagnostics.spm_rfx_hist" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>function spm_rfx_hist(cwd)
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Input:</th><td class="field-body">a directory name where an spm or SnPM random effects analysis lives</td>
</tr>
<tr class="field-even field"><th class="field-name">Outputs:</th><td class="field-body">histograms for all input images (usually contrast images from individual
subjects) plotted against a normal curve.</td>
</tr>
</tbody>
</table>
<p>The expected output is that each image will have roughly mean 0, with
bumps or tails in the distribution of there are real activations in some
parts of the brain.</p>
<p>Looking at these histograms may be helpful for detecting outliers or 
subjects with strange contrast values.  These may be caused by
bad scaling, multicolinearity in the design matrix, acquisition artifacts,
task-correlated head movement, or ???</p>
<p>Histograms (blue) are overlaid on a Gaussian distribution (red)
with a mean of 0 and a standard deviation equal to that of the observed data.</p>
</dd></dl>

<dl class="function">
<dt id="diagnostics.struct2yaml">
<code class="descclassname">diagnostics.</code><code class="descname">struct2yaml</code><span class="sig-paren">(</span><em>yamlfilename</em>, <em>DB</em>, <em>yamlfilemethod</em>, <em>dbmethod</em><span class="sig-paren">)</span><a class="headerlink" href="#diagnostics.struct2yaml" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="n">struct2yaml</span><span class="p">(</span><span class="n">yamlfilename</span><span class="p">,</span> <span class="n">DB</span><span class="p">,</span> <span class="n">yamlfilemethod</span><span class="p">,</span> <span class="n">dbmethod</span><span class="p">)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Inputs:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>yamlfilemethod:</strong></dt>
<dd><p class="first last">&#8216;new&#8217; or &#8216;add&#8217; (append)</p>
</dd>
<dt><strong>dbmethod:</strong></dt>
<dd><p class="first last">how the canlab database will handle the record.
&#8216;add&#8217;, &#8216;replace&#8217;, or &#8216;keep_existing&#8217;</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p>translate structure into YAML format text file
this will be interpretable by the canlab database</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Examples:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>yamlfilename = &#39;YAML_tmp.yaml&#39;;

DB.study = &#39;NSF&#39;;     % string; study code letters
DB.subject = &#39;001&#39;;   % string; subject ID number
DB.occasion = &#39;21&#39;;   % string; occasion ID; unique to subj*session
DB.unique_id = [DB.study &#39;_&#39; DB.subject &#39;_&#39; DB.occasion];
DB.mean_spikes_per_image = mean(cat(2, spikesperimg{:}));

struct2yaml(yamlfilename, DB, &#39;add&#39;, &#39;replace&#39;);
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="diagnostics.tor_get_physio">
<code class="descclassname">diagnostics.</code><code class="descname">tor_get_physio</code><span class="sig-paren">(</span><em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#diagnostics.tor_get_physio" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="p">[</span><span class="n">X</span><span class="p">,</span><span class="n">mP</span><span class="p">,</span><span class="n">spmP</span><span class="p">]</span> <span class="o">=</span> <span class="n">tor_get_physio</span><span class="p">([</span><span class="n">mP</span><span class="p">],[</span><span class="n">spmP</span><span class="p">],[</span><span class="n">nvoxels</span><span class="p">],[</span><span class="n">doortho</span><span class="p">])</span>
</pre></div>
</div>
<p>arguments are optional, but you must enter them in this order.</p>
<p>Tor Wager 10/21/02</p>
<p>Get nuisance covariates likely to be related to physiological noise and head motion
The algorithm:</p>
<p>The program extracts raw/preprocessed image data from the ventricles (CSF space), as
defined by a mask denoting which voxels are CSF for that subject.  
Either all voxels or a randomly selected subset [nvoxels] is subjected to
principal components analysis, to determine regular patters of drift over time
and across voxels.  Those patterns are expected to be related to global signal drift,
head movement, and physiological noise, and are assumed to be UNrelated to the task
of interest, by virtue of the fact that they occur in the ventricles.</p>
<p>PCA is done twice on the timeseries&#8217; of CSF voxels.  The first time, PCA is done
on the sums of squared values (not the correlations) of voxel timeserieses across
the entire experiment, mean-centered based on the whole experiment.  Most of the
coherent variation in this case is expected to be due to head movement and changes
in shims/gradients/etc. from run to run.  The SS values are used because we want to
weight the voxels with the highest variation most heavily, as they are presumably
picking up most of this signal.  The first 3 eigenvariates (canonical timeseries)
are saved.</p>
<p>Following, a separate, second PCA is done on the correlation matrix of data
within each session.  Session data for each voxel are mean-centered and scaled
relative to the session (variance of each voxel = 1).  We do this because 
physiological noise-related signals may produce periodic signals of different
magnitudes in different voxels, and we want to extract the most coherent signals
we can within each session.  So these eigenvariates are expected to reflect
primarily noise related to physiology (heart rate, respiration).  Up to 5 eigenvariates
for each session are saved (nothing with eigenvalue &lt; 1 is saved).</p>
<p>Next, the CSF-related nuisance covariates (eigenvariates from PCA) are combined
with existing nuisance covariates and intercept columns from the existing 
design matrix (SPMcfg xX).  The proportion of variance in each predictor of interest
explained by this nuisance basis set is calculated using regression, and the
nuisance covariates are orthogonalized with respect to each predictor of interest.
There are good and bad results of this step.  The bad is that any signal that 
tracks the predictors is attributed to the task, not to noise, even if it&#8217;s actually
caused by physiological artifact.  So the orthogonalized basis set does not
protect you from physiology or movement-related false positives.  However,
the nuisance covariates are also unlikely to reduce power in estimating you effects
of interest.  More importantly, it avoids false positives created when one 
predictor (A) is more highly correlated with the nuisance covariates than another
(B).  In practice, betas for A will tend to be smaller than B, given the same
actual response to both, and a random effects analysis on A-B will produce
false positive activations.  Orthogonalization of the nuisance set precludes this.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Inputs:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>mP:</strong></dt>
<dd><p class="first last">CSF mask image file.  <a href="#id25"><span class="problematic" id="id26">*</span></a>_seg3.img output from SPM is appropriate
should be in same space and have same dims as functionals
but automatic reslicing is done if necessary.</p>
</dd>
<dt><strong>spmP:</strong></dt>
<dd><p class="first last">name (full path name preferred) of SPMcfg.mat file to use
This contains the design matrix and raw/preproc image file names to use.</p>
</dd>
<dt><strong>nvoxels:</strong></dt>
<dd><p class="first last">Number of CSF voxels to use in PCA analysis
More than 100 can be very slow and memory intensive.
Fewer than 100 voxels loads a different way, and may be slower.
Best is probably between 100 - 1000.  800 runs pretty fast.</p>
</dd>
<dt><strong>doortho:</strong></dt>
<dd><p class="first last">Orthogonalize nuisance covariates with respect to regs of interest
This assumes that any signal that covaries with the task is, in fact,
due to the task, so it gives you some bias towards finding positive results.
However, the alternative is that nuisance covariates may soak up variance
related to the task, and you&#8217;ll miss activations.
In addition, if some regressors are more colinear with the nuisance set,
you can create false &#8220;activations&#8221; when comparing these regressors to other
ones.  This problem exists whether or not we choose to model nuisance 
covariates.  One solution is to use the ortho when doing random effects analyses,
as the sign and magnitude of nuisance-related activations would not be expected to be
the same across subjects unless the variance was really task-related.
Default is 1, or &#8220;yes, do orthogonalization.&#8221;</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p>for functions called, see this .m file.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Examples:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>% get filenames for SPMcfg files and CSF mask for each subject
cd C:\Tor_Documents\CurrentExperiments\intext2\RESULTS\model1
spmP = get_filename(&#39;sub*&#39;,&#39;SPMcfg.mat&#39;);
cd C:\Tor_Documents\CurrentExperiments\intext2\
mP = get_filename(&#39;sub*&#39;,&#39;anatomy/nscalped_f*seg3.img&#39;);
% Now run:
for i = 1:size(mP,1)  
    tor_get_physio(mP(i,:),spmP(i,:),300);  % 300 voxels
    pause(10); close all
end
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name" colspan="2">Functions called:</th></tr>
<tr class="field-odd field"><td>&nbsp;</td><td class="field-body"><ul class="first last simple">
<li>spm functions: spm_get, etc.</li>
<li>timeseries2.m      (for &lt; 100 voxels)</li>
<li>read_hdr.m (big-little endian dependent; validate for your data)</li>
<li>timeseries3.m      (for &gt; 100 voxels; uses SPM&#8217;s image reading)</li>
<li>reslice_imgs.m</li>
<li>mask2voxel.m       (only if ind2sub.m from Matlab is not found)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">canlab_dataset</a></li>
<li><a class="reference internal" href="#module-&#64;fmri_data">fmri_data</a></li>
<li><a class="reference internal" href="#module-&#64;fmri_mask_image">fmri_mask_image</a></li>
<li><a class="reference internal" href="#module-&#64;fmri_model">fmri_model</a></li>
<li><a class="reference internal" href="#module-&#64;image_vector">image_vector</a></li>
<li><a class="reference internal" href="#module-&#64;region">region</a></li>
<li><a class="reference internal" href="#module-&#64;statistic_image">statistic_image</a></li>
<li><a class="reference internal" href="#cluster-contig-region-tools">Cluster_contig_region_tools</a></li>
<li><a class="reference internal" href="#module-Data_extraction">Data_extraction</a></li>
<li><a class="reference internal" href="#data-processing-tools">Data_processing_tools</a></li>
<li><a class="reference internal" href="#module-diagnostics">diagnostics</a></li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="index.html"
                        title="previous chapter">CanlabCore documentation home</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/moduleslist.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="mat-modindex.html" title="MATLAB Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="index.html" title="CanlabCore documentation home"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">CanlabCore 1.0 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &copy; Copyright 2015, Tor Wager.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.3.1.
    </div>
  </body>
</html>