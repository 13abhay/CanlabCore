<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>fmri_data &mdash; CanlabCore 1.0 documentation</title>
    
    <link rel="stylesheet" href="_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="CanlabCore 1.0 documentation" href="index.html" />
    <link rel="prev" title="CanlabCore documentation home" href="index.html" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="mat-modindex.html" title="MATLAB Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="index.html" title="CanlabCore documentation home"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">CanlabCore 1.0 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="toctree-wrapper compound">
<ul class="simple">
</ul>
</div>
<div class="section" id="module-&#64;fmri_data">
<span id="fmri-data"></span><h1>fmri_data<a class="headerlink" href="#module-@fmri_data" title="Permalink to this headline">¶</a></h1>
<dl class="function">
<dt id="&#64;fmri_data.canlab_connectivity_preproc">
<code class="descclassname">&#64;fmri_data.</code><code class="descname">canlab_connectivity_preproc</code><span class="sig-paren">(</span><em>dat</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@fmri_data.canlab_connectivity_preproc" title="Permalink to this definition">¶</a></dt>
<dd><p>This function prepares data for connectivity analysis by removing nuisance
variables and temporal filtering (high, low, or bandpass filter). This also
can extract values from given masks and return averaged activity or pattern
expression values.</p>
<p>[preprocessed_dat, roi_val] = canlab_connectivity_preproc(dat, varargin)</p>
<p>Features:
- can regress out nuisance variables with any additional nuisance matrix
- can remove signal from ventricle and white matter</p>
<blockquote>
<div><dl class="docutils">
<dt>(calls canlab_extract_ventricle_wm_timeseries.m and</dt>
<dd>canlab_create_wm_ventricle_masks.m)</dd>
</dl>
</div></blockquote>
<ul>
<li><dl class="first docutils">
<dt>can do temporal filtering, including high-pass, low-pass, or bandpass</dt>
<dd><p class="first last">filtering (it uses conn_filter.m from conn toolbox; see subfunction below)</p>
</dd>
</dl>
</li>
<li><p class="first">can extract data from given ROIs, and return averaged value or pattern
expression value (dot-product).</p>
</li>
</ul>
<p>Steps in order [with defaults]:
1. Remove nuisance covariates (and linear trend if requested)
2. Remove ventricle and white matter - needs structural images
3. Windsorize based on distribution of full data matrix
4. High/low/bandpass filter
5. Extract region-by-region average ROI or pattern expression data</p>
<blockquote>
<div><p>Copyright (C) 2014  Wani Woo</p>
<p>This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.</p>
<p>This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.</p>
<p>You should have received a copy of the GNU General Public License
along with this program.  If not, see &lt;<a class="reference external" href="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</a>&gt;.</p>
</div></blockquote>
<p>dat            fmri_data object with data
dat.covariate  basic nuisance matrix</p>
<dl class="docutils">
<dt>&#8216;additional_nuisance&#8217;</dt>
<dd>When you have additional nuisance variables that you want
regress out from the data, you can use this option. This
option should be followed by a nuisance matrix (or values).
The matrix should have the same number of rows with the
number of images.</dd>
<dt>&#8216;vw&#8217;          When you want to regress out signals from ventricle and</dt>
<dd><p class="first">white matter, you can use this option. To use this option,
You should provide the directory where the subjects&#8217; data
are saved using the &#8216;datdir&#8217; (for example, see below).
Requires specific subdirectory structure (CANlab) - see code.</p>
<p>You can also choose what to use to remove ventricle and
white matter signal between raw data or top 5 PCA
components (default). You can just put &#8216;raw&#8217; if you want to
use raw signal than PCA compoenents.</p>
<blockquote>
<div><dl class="docutils">
<dt>also see: canlab_extract_ventricle_wm_timeseries.m</dt>
<dd>canlab_create_wm_ventricle_masks.m)</dd>
</dl>
</div></blockquote>
<p class="last">example: &#8216;vw&#8217;, &#8216;datdir&#8217;, subject_dir, &#8216;raw&#8217;</p>
</dd>
<dt>&#8216;windsorize&#8217;  Windsorizing entire data matrix to k x STD.</dt>
<dd>example: &#8216;windsorize&#8217;, 5 (windsorize to 5 STD)</dd>
<dt>&#8216;linear_trend&#8217; This option will include the linear trend to nuisance</dt>
<dd>variables.</dd>
<dt>&#8216;hpf&#8217;, &#8216;lpf&#8217;, or &#8216;bpf&#8217;</dt>
<dd><p class="first">This option will do temporal filtering.
&#8216;hpf&#8217;: high pass filter. This option should be followed by</p>
<blockquote>
<div>the lower bound of the frequency (e.g., .01 Hz [= 100 sec]).</div></blockquote>
<dl class="docutils">
<dt>&#8216;lpf&#8217;: low pass filter. This option should be followed by</dt>
<dd>the upper bound of the frequency (e.g., .25 Hz [= 4 sec]).</dd>
<dt>&#8216;bpf&#8217;: bandpass filter. This should be followed by lower</dt>
<dd>and upper bounds of the frequency (e.g., [.01 .25]).</dd>
</dl>
<p>After the frequency value, you need to provide TR.
example: &#8216;hpf&#8217;, .01, TR</p>
<blockquote class="last">
<div>&#8216;bpf&#8217;, [.01 .25], TR</div></blockquote>
</dd>
<dt>&#8216;extract_roi&#8217; This option will extract data from ROIs specified. This</dt>
<dd><p class="first">option should be followed by one or more masks.
For one mask (potentially multiple ROIs, enter a char array with the mask name.
For multiple masks (1 or more), enter in a cell array of mask names.
You can specify methods with &#8216;roi_methods&#8217; option.
&#8216;average_over&#8217; (default): calculate averaged value across</p>
<blockquote>
<div>the ROIs.</div></blockquote>
<dl class="last docutils">
<dt>&#8216;pattern_expression&#8217;: calculate dot-products between</dt>
<dd>pattern mask and data</dd>
<dt>&#8216;unique_mask_values&#8217; (default): will divide a mask into</dt>
<dd>multiple regions that have different discrete values.</dd>
<dt>&#8216;contiguous_regions&#8217;: will divide a mask into multiple</dt>
<dd>contiguous regions.</dd>
<dt>&#8216;whole&#8217;: will do average_over or pattern_expression across</dt>
<dd>all the voxels within the mask.</dd>
<dt>example: &#8216;extract_roi&#8217;, mask, &#8216;contiguous_regions&#8217;</dt>
<dd>&#8216;extract_roi&#8217;, mask, &#8216;pattern_expression&#8217;</dd>
</dl>
</dd>
<dt>&#8216;no_preproc&#8217;  If you want to skip the preprocessing part, and want to</dt>
<dd>extract ROI values only, you can use this option.</dd>
</dl>
<dl class="docutils">
<dt>preprocessed_dat: fmri_data object after removing nuisance variables and</dt>
<dd>filtering temporal confounds.</dd>
<dt>roi_val:          returns values extracted from ROIs in cell arrays</dt>
<dd>(if there are many different ROIs). Each cell will have
roi_val.dat, roi_val.mask_name, and roi_val.methods.</dd>
</dl>
<p>roi_masks = which(&#8216;weights_NSF_grouppred_cvpcr.img&#8217;);
[preprocessed_dat, roi_val] = canlab_connectivity_preproc(dat, &#8216;vw&#8217;, &#8216;datdir&#8217;,</p>
<blockquote>
<div>subject_dir, &#8216;bpf&#8217;, [.008 .25], TR, &#8216;extract_roi&#8217;, roi_masks,
&#8216;pattern_expression&#8217;);</div></blockquote>
<p>PROGRAMMER&#8217;S NOTE
05/19/15 fixed a bug related to conn_filter</p>
</dd></dl>

<dl class="function">
<dt id="&#64;fmri_data.create">
<code class="descclassname">&#64;fmri_data.</code><code class="descname">create</code><span class="sig-paren">(</span><em>obj</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@fmri_data.create" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an object from an empty obj structure, assigning fieldname/value
pairs as optional arguments.</p>
<p>obj = create(obj, varargin)</p>
<p>Used in fmri_data.m class constructor.
if &#8216;noverbose&#8217; is entered, suppress output</p>
</dd></dl>

<dl class="function">
<dt id="&#64;fmri_data.extract_roi_averages">
<code class="descclassname">&#64;fmri_data.</code><code class="descname">extract_roi_averages</code><span class="sig-paren">(</span><em>obj</em>, <em>mask_image</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@fmri_data.extract_roi_averages" title="Permalink to this definition">¶</a></dt>
<dd><p>[cl, clroimean, clpattern] = extract_roi_averages(fmri_data obj, [mask_image], [average_over])</p>
<p>This fmri_data method a extracts and averages data stored in an fmri_data object 
from a set of ROIs defined in a mask.</p>
<p>If no mask_image is entered, it uses the mask defined with the fmri_data object as a default.</p>
<dl class="docutils">
<dt>If mask_image is a new image file name, this method:</dt>
<dd><ol class="first last arabic simple">
<li>Defines an fmri_mask_image object using create_fmri_mask</li>
<li>Maps to the space in fmri_data object using resample_to_image_space</li>
</ol>
</dd>
</dl>
<p>Regions to average over can be either regions of contiguous voxels
bounded by voxels with values of 0 or NaN, which are considered non-data
values, or regions defined by unique integer codes in the mask image
(i.e., for atlas images with unique codes for each defined region.)</p>
<p>Mask/Atlas image does NOT have to be in the same space as the images to
extract from.  It will be remapped/resliced.
NOTE: Mask is <em>reloaded</em> from original data if space is remapped, and you
cannot use manual thresholding of the mask. This is a feature of the
map_to_image_space method and scn_map_image</p>
<p>extracted data is returned in single data format.</p>
<p>Inputs:
1 - char array of strings containing 4D image file names (data extracted from these)
2 - mask_image to extract from.</p>
<p>Optional inputs:
how to average:</p>
<blockquote>
<div>Default = &#8216;unique_mask_values&#8217; to average over unique integer codes in the mask image
bounded by voxels of 0 or NaN (non-data values)
(i.e., for atlas images with unique codes for each defined region)
Alt. option = &#8216;contiguous_regions&#8217; to average over contiguous voxels</div></blockquote>
<dl class="docutils">
<dt>&#8216;pattern_expression&#8217;:</dt>
<dd><p class="first">Use values in mask images to get weighted average within each
region, rather than simple average.  See also apply_mask with
&#8216;pattern_expression&#8217; option.</p>
<p class="last">Optional outputs (varargout): 
[cl, cl_roimean, cl_roipattern] = ...
roimean: pattern expression is average over ROI (unit vector)
roipattern: pattern expression is dot product of activity and mean-centered pattern weights</p>
</dd>
<dt>&#8216;nonorm&#8217;</dt>
<dd>Turn off L1 norm in pattern expression.</dd>
</dl>
<p>Example:
imgs_to_extract_from = filenames(&#8216;w*.nii&#8217;,&#8217;char&#8217;);
mask_image = which(&#8216;anat_lbpa_thal.img&#8217;);
[cl, clroimean, clpattern] = extract_image_data(imgs_to_extract_from, mask_image);</p>
<p>region_obj = extract_roi_averages(data_obj, mask_char_name, &#8216;pattern_expression&#8217;, &#8216;contiguous_regions&#8217;);</p>
<p>Notes:
cl(i).dat gives you the pattern expression values for cluster i.</p>
<p>This function LOSES removed image data - you must re-remove if you have
removed images!</p>
<p>Related functions:
For an non-object-oriented alternative, see extract_image_data.m
Modified June 11, 2013 by Tor</p>
<blockquote>
<div><ul class="simple">
<li>use resample_space instead of resample_to_image_space</li>
</ul>
</div></blockquote>
<dl class="docutils">
<dt>Modified Dec 1, 2014 by Wani</dt>
<dd><ul class="first last simple">
<li>moved up the part of parsing optional inputs because resample_space 
causes a problem for the unique_mask_values option</li>
<li>For resample_space, the &#8216;nearest&#8217; option should be used when the 
&#8220;unique_mask_values&#8221; option is used.</li>
</ul>
</dd>
<dt>Modified Oct 2015 by Tor]</dt>
<dd><ul class="first last simple">
<li>Clarified options, empty cl error check, changed varargout behavior</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="&#64;fmri_data.horzcat">
<code class="descclassname">&#64;fmri_data.</code><code class="descname">horzcat</code><span class="sig-paren">(</span><em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@fmri_data.horzcat" title="Permalink to this definition">¶</a></dt>
<dd><p>function s = horzcat(varargin)</p>
<p>Implements the horzcat ([a b]) operator on image_vector objects across voxels.
Requires that each object has an equal number of columns and voxels</p>
<p>Examples:
c = [dat1 dat2];</p>
<p>Programmer Notes
Created 3/14/14 by Luke Chang for image_vector; updated for fmri_data 8/2015 Yoni Ashar
check whether ALL inputs have X, Y values</p>
</dd></dl>

<dl class="function">
<dt id="&#64;fmri_data.hrf_fit">
<code class="descclassname">&#64;fmri_data.</code><code class="descname">hrf_fit</code><span class="sig-paren">(</span><em>obj</em>, <em>TR</em>, <em>Runc</em>, <em>T</em>, <em>method</em>, <em>mode</em><span class="sig-paren">)</span><a class="headerlink" href="#@fmri_data.hrf_fit" title="Permalink to this definition">¶</a></dt>
<dd><p>HRF estimation on fmri_data class object</p>
<p>HRF estimation function for a single voxel;</p>
<p>Implemented methods include: IL-model (Deterministic/Stochastic), FIR
(Regular/Smooth), and HRF (Canonical/+ temporal/+ temporal &amp; dispersion)</p>
<p>INPUTS:</p>
<p>obj   - fMRI object 
TR    - time resolution
Runs  - expermental design
T     - length of estimated HRF ij seconds
type  - Model type: &#8216;FIR&#8217;, &#8216;IL&#8217;, or &#8216;CHRF&#8217;
mode  - Mode</p>
<p>MODEL TYPES:</p>
<ol class="upperalpha simple">
<li>Fit HRF using IL-function</li>
</ol>
<p>Choose mode (deterministic/stochastic)</p>
<p>0 - deterministic aproach 
1 - simulated annealing approach</p>
<p>Please note that when using simulated annealing approach you
may need to perform some tuning before use.</p>
<ol class="upperalpha simple" start="2">
<li>Fit HRF using FIR-model</li>
</ol>
<p>Choose mode (FIR/sFIR)</p>
<p>0 - FIR 
1 - smooth FIR</p>
<ol class="upperalpha simple" start="3">
<li>Fit HRF using FIR-model</li>
</ol>
<p>Choose mode (FIR/sFIR)</p>
<p>0 - FIR 
1 - smooth FIR</p>
<p>Created by Martin Lindquist on 04/11/14</p>
<blockquote>
<div><p>% params for sim and fitting
% &#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;-  
TR = 2;   % repetition time (sec)
n = 200;  % time points measured (for simulation) must be multiple of 10
T = 30;   % duration of HRF to estimate (seconds)
nconds = 2; % num conditions
nevents = 8; % events per condition</p>
<p>% Create fake data
% &#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;-
h = spm_hrf(TR);
y = zeros(n, 1);</p>
<p>% onsets - indicator
Condition = {};
for i = 1:nconds</p>
<blockquote>
<div><p>Condition{i} = zeros(n,1);
wh = randperm(n);
Condition{i}(wh(1:nevents)) = 1;</p>
<p>ytmp{i} =  conv(Condition{i}, h);
ytmp{i} = ytmp{i}(1:n);</p>
</div></blockquote>
<p>end</p>
<p>y = sum(cat(2, ytmp{:}), 2);</p>
<p>dat = fmri_data(&#8216;VMPFC_mask_neurosynth.img&#8217;);  % AVAILABLE ON WIKI IN MASK GALLERY
dat = threshold(dat, [5 Inf], &#8216;raw-between&#8217;);</p>
<p>v = size(dat.dat, 1); % voxels in mask
dat.dat = repmat(y&#8217;,v, 1) + .1 * randn(v, n);</p>
<p>% Fit data - estimate HRFs across the brain mask
% &#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;-
[params_obj hrf_obj] = hrf_fit(dat,TR, Condition, T,&#8217;FIR&#8217;, 1);</p>
<p>hrf = fmri_data(&#8216;HRF_timecourse_cond0001.img&#8217;);
hrf = remove_empty(hrf);
create_figure(&#8216;hrfs&#8217;, 1, 2); 
plot(hrf.dat&#8217;);
title(&#8216;Condition 1&#8217;)
hrf = fmri_data(&#8216;HRF_timecourse_cond0002.img&#8217;);
hrf = remove_empty(hrf);
subplot(1, 2, 2);
plot(hrf.dat&#8217;);
title(&#8216;Condition 2&#8217;)</p>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="&#64;fmri_data.plot">
<code class="descclassname">&#64;fmri_data.</code><code class="descname">plot</code><span class="sig-paren">(</span><em>fmridat</em><span class="optional">[</span>, <em>plotmethod</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#@fmri_data.plot" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot data matrix
plot(fmri_data_object)</p>
<p>Plot means by condition
plot(fmri_data_object, &#8216;means_for_unique_Y&#8217;)</p>
<p>5 plots and an SPM orthviews presentation of the data.  In the below and elsewhere, &#8220;image&#8221; connotes a 3D brain volume
captured every TR.</p>
<blockquote>
<div><p>subplot 1:  the fMRI data itself.  Color is intensity of signal
subplot 2:  presented as a histogram of values for every voxel collected.
The low values are typically out-of-brain voxels, as there is no signal
there
subplot 3:  each point is an image.  The point&#8217;s X value is the mean
intensity of every voxel in that image, and the Y value is the stdev of
intensities for all voxels in that image
subplot 4:  covariance between images
subplot 5:  each point is an image (case = image).  X value is image
number in the run, Y is image mean intensity, and the size of the
circular marker represents stdev for that image</p>
<p>Orthviews: mean and STD for a given voxel averaged over time.  Note that the values for mean and STD here are higher than in
the plots above.  That is because mean and STD are calculated here by
voxel, but in the plots above they are calculated by image.  Images also include out-of-brain areas.</p>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="&#64;fmri_data.predict">
<code class="descclassname">&#64;fmri_data.</code><code class="descname">predict</code><span class="sig-paren">(</span><em>obj</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@fmri_data.predict" title="Permalink to this definition">¶</a></dt>
<dd><p>Predict outcome (Y) from brain data and test cross-validated error rate for an fmri_data object</p>
<p>[cverr, stats, optional_outputs] = predict(obj, varargin)</p>
<ul class="simple">
<li>flexible specification of algorithm by function name</li>
<li>k-fold cross-validation, default = 5-fold, can enter custom fold membership</li>
<li>folds are stratified on outcome</li>
<li>choice of multiple error metrics (class loss, mse, etc.)</li>
<li>by default, chooses error metric based on outcome type (classes vs. continuous-valued)</li>
<li>returns all outputs for each fold returned by the algorithm in optout cell array variable</li>
<li>bootstrapping of weights built in [optional keyword]</li>
<li>select variable number of components (for pcr-based techniques)</li>
</ul>
<p>obj = fmri_data or image_vector object, with fields .dat (data used to predict) and .Y (outcome)</p>
<p>Optional inputs with their default values:
:&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8211;
&#8216;nfolds&#8217; = 5;                       % number of folds
&#8216;nfolds&#8217; = [vector of integers]     % can also input vector of integers for holdout set IDs
&#8216;error_type&#8217; = &#8216;mcr&#8217;;               % mcr, mse: misclassification rate or mean sq. error
&#8216;algorithm_name&#8217; = &#8216;cv_regress&#8217;;    % name of m-file defining training/test function
&#8216;useparallel&#8217; = 1                   % Use parallel processing, if available; follow by 1 for yes, 0 for no
&#8216;bootweights&#8217; = 0;                  % bootstrap voxel weights; enter
&#8216;bootweights&#8217;                       % do bootstrapping of weight maps (based on all observations)
&#8216;savebootweights&#8217;                   % save bootstraped weights (useful for combining across multiple iterations of predict())
&#8216;bootsamples&#8217; = 100;                % number of bootstrap samples to use
&#8216;numcomponents&#8217; = xxx               % save first xxx components (for pca-based methods)
&#8216;nopcr&#8217;                             % for cv_lassopcr and cv_lassopcrmatlab: do not do pcr, use original variables
&#8216;lasso_num&#8217; = xxx                   % followed by number of components/vars to retain after shrinkage
&#8216;hvblock&#8217; = [h,v]                   % use hvblock cross-validation with a block size of &#8216;h&#8217; (0 reduces to v-fold xval) and</p>
<blockquote>
<div>number of test observations &#8216;v&#8217; (0 reduces to h-block xval)</div></blockquote>
<dl class="docutils">
<dt>&#8216;rolling&#8217; = [h,v,g]                 % use rolling cross-validation with a block size of &#8216;h&#8217; (0 reduces to v-fold xval) and</dt>
<dd>number of test observations &#8216;v&#8217; (0
reduces to h-block xval), and a training size of g * 2 surrounding hv</dd>
</dl>
<p>&#8216;verbose&#8217; = 1                       % Set to 0 to suppress output to command window
&#8216;platt_scaling&#8217;                     % calculate cross-validated platt scaling if using SVM.</p>
<blockquote>
<div>Softmax parameters [A,B] are in other_output{3}</div></blockquote>
<p>You can input the name (as a string array) of any algorithm with the
appropriate inputs and outputs. i.e., this can either be one of the
built-in choices below, or the name of another m-file.
The format for algorithm functions is :
[yfit, other_outputs] = predfun(xtrain, ytrain, xtest, optional_inputs)
Each algorithm can take/interpret its own optional inputs.
For bootstrapping of weights, algorithms MUST RETURN 3 OUTPUTS
(programming &#8216;feature&#8217;)</p>
<p>To choose an algorithm, enter &#8216;algorithm_name&#8217; followed by a text string
with a built-in algorithm name, or a function handle for a custom algorithm
Built-in algorithm choices include:
cv_multregress    : [default] multiple regression
cv_univregress    : Average predictions from separate univariate regression of outcome on each feature
cv_svr            : Support vector regression with Spider package; requires spider
cv_pcr            : Cross-validated principal components regression
cv_lassopcr       : Cross-val LASSO-PCR; can enter &#8216;lasso_num&#8217; followed by components to retain by shrinkage</p>
<blockquote>
<div>NOTE: can enter &#8216;EstimateParams&#8217; to use shrankage
lasso method based on the estimated optimal lambda
that minimizes the mean squared error (MSE) of nested
cross-validation models. Output of nested cv model is
saved in stats.other_output_cv{:,3}. Output includes
&#8216;Lambda&#8217; parameter and min MSE value.</div></blockquote>
<dl class="docutils">
<dt>cv_lassopcrmatlab <span class="classifier-delimiter">:</span> <span class="classifier">Cross-val LASSO-PCR; can enter &#8216;lasso_num&#8217; followed by components to retain by shrinkage</span></dt>
<dd>NOTE: this uses the matlab implementation of LASSO,
but can also run ridge or elastic net. Reduces to PCR
when no lasso_num is entered by default.  Use MSE for
predicting continuous data and MCR for classifying
binary data.
NOTE: You can input any optional inputs that lassoglm
takes.
Enter &#8216;Alpha&#8217;, (0,1] as optional inputs to
run ridge (Alpha approaches 0, but excluding 0), lasso (Alpha = 1), or elastic
net (Alpha between 0 and 1)
NOTE: Requires Matlab R2012a and higher.
NOTE: Optional input: &#8216;EstimateParams&#8217; - this will
use grid search and nested cross validation to
estimate Lambda and Alpha.  Output is saved in
stats.other_output_cv{:,3}.  Output includes &#8216;Alpha&#8217;
parameter which is the elastic net mixture value
between l1 and l2 regularization, &#8216;Lambda&#8217; parameter,
which is amount of LASSO regularization/shrinkage, and
&#8216;errorMatrix&#8217;, which is the amount of error for each
parameter combination.  Use
imagesc(obj.stats_other_output_cv{:,3}.errorMatrix)
to view matrix.  Min of this matrix is the best
fitting parameters.</dd>
<dt>cv_svm <span class="classifier-delimiter">:</span> <span class="classifier">Cross-val support vector machine using Spider package</span></dt>
<dd>NOTE: This is sensitive to scale of outputs! Use -1 , 1
NOTE: Optional inputs: Slack var parameter: &#8216;C&#8217;, 1 [default], &#8216;C&#8217;, 3 etc.
Distance from hyperplane saved in
stats.other_output_cv{:,2}.  Recommend using the reordered
cross-validated distance from hyperplane saved in stats.other_output{3}
stats.dist_from_hyperplane_xval =  cross-validated distance from hyperplane
stats.weight_obj = voxel (variable) weight object
e.g., orthviews(stats.weight_obj)
Intercept for calculating dist from hy is in stats.other_output_cv{:,3}
e.g., dist_hy = stats.weight_obj.dat&#8217; * obj.dat, where obj is a new set of test images
NOTE: To run nonlinear SVM using radial basis
function.  Add &#8216;rbf&#8217; followed by size of sigma (e.g., 2).
NOTE: To estimate some of the parameters using
nested cross validation add &#8216;EstimateParams&#8217; as optional input.
NOTE: To run multiclass SVM (i.e., one vs rest) add
&#8216;MultiClass&#8217; as optional input.  Important - Obj.Y must be a matrix (data x
class) with a column of 1 and -1 indicating each
class.  For example, if using 3 classes, then obj.Y
must have 3 columns.
NOTE: To run a balanced SVM where the number of cases for each class are unequal (i.e., one vs rest) add
&#8216;Balanced&#8217; as optional input, followed by a numerical value indicating the ridge amount (e.g., 0.01).</dd>
<dt>cv_multilevel_glm <span class="classifier-delimiter">:</span> <span class="classifier">Runs glmfit_multilevel. Must pass in &#8216;&#8217;subjIDs&#8217;&#8217; followed by an array specifying which subject each trial belongs to</span></dt>
<dd>Subjects&#8217; trials must all be &#8220;adjacent&#8221;, i.e., don&#8217;t
put some of subject 1&#8217;s trials at the beginning and
other trials at the end &#8211; subjIDs does not handle
this case correctly. Also, 2ND LEVEL PREDICTORS NOT
CURRENTLY SUPPORTED.  code can be expanded to support this.
mean-centering X and/or Y will NOT impact the
predictor betas.  Note that it WILL impact the intercept
esimate as well as how much variance is explained
(pred_outcome_r).  Stratified CV partition not
supported either, pass in custom holdout set.</dd>
</dl>
<p>Y              : Copy of outcome data to be predicted
algorithm_name : Name of algorithm; see options above
function_call  : String of the command evaluated to call the prediction function
function_handle: Handle for the command evaluated to call the prediction function
yfit           : Predicted outcome data (cross-validated)
err            : Residuals/misclassification vector (cross-validated)
error_type     : Name of error metric used for cverr
cverr          : Cross-validated error
nfolds         : Number of folds in stratified cross-validation, or</p>
<blockquote>
<div>vector of integers for membership in custom holdout set of each fold
-if k = 1, will estimate weights for full data object
and not crossvalidate (useful for bootstrapping)</div></blockquote>
<p>cvpartition    : Cross-val partition object or structure with fold info
teIdx          : Cell array of logical vectors with test samples in each fold
trIdx          : Cell array of logical vectors with training samples in each fold
other_output   : Other outputs returned by the algorithm; number and nature depend on algo choice; e.g., beta weights, svr weights, etc.</p>
<blockquote>
<div>For many algorithms, other_output{1} is a vector of
weights on variables (e.g., voxels)</div></blockquote>
<p>other_output_descrip : String description of other outputs
other_output_cv      : Other outputs for each cross-validation fold
other_output_cv_descrip: &#8216;Other output from algorithm - for each CV fold&#8217;
mse            : For regression only; mean squared error
rmse           : For regression only; root mean squared error
meanabserr     : For regression only; mean absolute error
pred_outcome_r : For regression only; prediction-outcome correlation
WTS            : bootstrapped weights on voxels
weight_obj     : for some algorithms, an fmri_data object with the predictive weights (from full sample)</p>
<p>obj = fmri_data;
obj.dat = randn(30, 50); % 30 voxels, 50 images (observations)
obj.Y = obj.dat&#8217; * rand(30, 1) + randn(50, 1); % toy Y, linear combo of X plus noise
[cverr, stats, regression_outputs] = predict(obj);</p>
<p>Simulated example with 100 observations, 1000 voxels, with bootstrapping
dat = fmri_data;
dat.Y = rand(100, 1);
dat.dat = repmat(dat.Y&#8217;, 1000, 1) + 10*rand(1000, 100);
[err,stats] = predict(dat, &#8216;bootweights&#8217;, &#8216;algorithm_name&#8217;, &#8216;cv_lassopcr&#8217;);</p>
<p>[cverr, stats, regression_outputs] = predict(obj, &#8216;nfolds&#8217;, 3, &#8216;error_type&#8217;, &#8216;meanabserr&#8217;);
[cverr, stats, regression_outputs] = predict(obj, &#8216;algorithm_name&#8217;, &#8216;cv_univregress&#8217;, &#8216;error_type&#8217;, &#8216;meanabserr&#8217;);
[cverr, stats, optout] = predict(obj, &#8216;algorithm_name&#8217;, &#8216;cv_lassopcr&#8217;, &#8216;lasso_num&#8217;, 5, &#8216;nfolds&#8217;, 5, &#8216;error_type&#8217;, &#8216;mse&#8217;, &#8216;bootweights&#8217;);
[cverr, stats, optout] = predict(dat, &#8216;algorithm_name&#8217;, &#8216;cv_svm&#8217;, &#8216;nfolds&#8217;, 5, &#8216;error_type&#8217;, &#8216;mse&#8217;);
[cverr, stats, optout] = predict(dat, &#8216;algorithm_name&#8217;, &#8216;cv_svm&#8217;, &#8216;rbf&#8217;, 2, &#8216;nfolds&#8217;, 5, &#8216;error_type&#8217;, &#8216;mse&#8217;); %SVM w/ radial basis function
[cverr, stats, optout] = predict(dat, &#8216;algorithm_name&#8217;, &#8216;cv_svm&#8217;, &#8216;rbf&#8217;, 2, &#8216;EstimateParams&#8217;, &#8216;nfolds&#8217;, 5, &#8216;error_type&#8217;, &#8216;mse&#8217;); %SVM w/ radial basis function w/ parameters estimated using nested cross-valdiation
[cverr, stats, optout] = predict(dat, &#8216;algorithm_name&#8217;, &#8216;cv_svm&#8217;, &#8216;nfolds&#8217;, 5, &#8216;MultiClass&#8217;, &#8216;error_type&#8217;, &#8216;mse&#8217;);</p>
<p>Elastic net with first 10 components:
[cverr, stats, optout] = predict(dat_masked, &#8216;algorithm_name&#8217;, &#8216;cv_lassopcrmatlab&#8217;, &#8216;nfolds&#8217;, 5, &#8216;error_type&#8217;, &#8216;mse&#8217;, &#8216;numcomponents&#8217;, 10, &#8216;Alpha&#8217;, .5); stats.pred_outcome_r</p>
<p>Ridge with first 10 components:
[cverr, stats, optout] = predict(dat_masked, &#8216;algorithm_name&#8217;, &#8216;cv_lassopcrmatlab&#8217;, &#8216;nfolds&#8217;, 5, &#8216;error_type&#8217;, &#8216;mse&#8217;, &#8216;numcomponents&#8217;, 10, &#8216;Alpha&#8217;, 0.00001); stats.pred_outcome_r</p>
<p>Lasso with all components, but shrink to retain 2 components only:
[cverr, stats, optout] = predict(dat, &#8216;algorithm_name&#8217;, &#8216;cv_lassopcrmatlab&#8217;, &#8216;nfolds&#8217;, whfolds, &#8216;nopcr&#8217;, &#8216;lasso_num&#8217;, 2, &#8216;Alpha&#8217;, 1);
[cverr, stats, optout] = predict(dat, &#8216;algorithm_name&#8217;, &#8216;cv_lassopcr&#8217;, &#8216;nfolds&#8217;, whfolds, &#8216;lasso_num&#8217;, 2);</p>
<p>Lasso with the shrinkage methods based on the estimated optimal lambda that minimizes MSE of nested cross-validation models.
[cverr, stats, optout] = predict(dat, &#8216;algorithm_name&#8217;, &#8216;cv_lassopcr&#8217;, &#8216;nfolds&#8217;, whfolds, &#8216;estimateparam&#8217;);
[cverr, stats, optout] = predict(dat, &#8216;algorithm_name&#8217;, &#8216;cv_lassopcr&#8217;, &#8216;nfolds&#8217;, 5, &#8216;estimateparam&#8217;);</p>
<p>Lasso without doing PCR:
[cverr, stats, optout] = predict(dat, &#8216;algorithm_name&#8217;, &#8216;cv_lassopcrmatlab&#8217;, &#8216;nfolds&#8217;, whfolds, &#8216;nopcr&#8217;, &#8216;lasso_num&#8217;, 2, &#8216;Alpha&#8217;, 1);
[cverr, stats, optout] = predict(dat, &#8216;algorithm_name&#8217;, &#8216;cv_lassopcr&#8217;, &#8216;nfolds&#8217;, whfolds, &#8216;lasso_num&#8217;, 2, &#8216;nopcr&#8217;);
[cverr, stats, optout] = predict(dat, &#8216;algorithm_name&#8217;, &#8216;cv_lassopcr&#8217;, &#8216;nfolds&#8217;, 5, &#8216;estimateparam&#8217;, &#8216;nopcr&#8217;);</p>
<p>Lasso pcr using hvblock cross-validation on time-series, h = 3, v = 5;
[cverr, stats, optout] = predict(dat, &#8216;algorithm_name&#8217;, &#8216;cv_lassopcr&#8217;, &#8216;hvblock&#8217;,[3,5]);</p>
<p>Output display:
orthviews(stats.weight_obj)
line_plot_multisubject(stats.yfit, stats.Y, &#8216;subjid&#8217;, id_numbers);</p>
<p>predict_test_suite method for fmri_data, which runs predict with multiple
options and summarizes output.</p>
<p>xval_regression_multisubject, xval_lasso_brain</p>
<p>Original version: Copyright Tor Wager, Dec 2010
Programmers&#8217; notes:
Dec 2011: Changed to input double format to algorithms; some have
problems with single format</p>
<p>March 2012: Changed default method to cv_pcr, and updated input option
parsing to avoid silly mistakes in specifying algorithm.
Changed line 377 to if rank(X) &lt; size(sc, 1). Tested: pinv and normal inv
give same results up to machine precision.</p>
<p>10/16/12: Luke Chang: Changed input to bootstrp to double because of problems with
single format (see Tor&#8217;s edits on 11/10/12)</p>
<p>11/2/2012: tor wager: cv_svm output added to return distance from hyperplane in stats.other_output_cv{:,2}</p>
<p>11/7/12: Luke Chang: added cv_lassopcrmatlab to use new matlab lasso.
This uses coordinate descent methods compared to Least Angle Regression
in the Rocha Lasso algorithm.  This function can be used for prediction of continuous data or classification
of binary data.  For binary classification compare cverr to, Phi, or MSE in stats output. Still
working on a good way to quantify accuracy using the predicted
probabilities from logistic regression.  Also working on methods to
select optimal lambda for regularization.  Make sure you change the Rocha
lasso function name to &#8216;lasso_rocha&#8217; to retain old functionality and prevent conflicts.</p>
<p>11/7/12: Luke Chang: added functionality to display xval iteration number
and elapsed time</p>
<p>11/8/12: Luke Chang: fixed calculation of mse. Previous version calculated sum of squared error</p>
<dl class="docutils">
<dt>11/10/12: Tor Wager:</dt>
<dd><ul class="first last simple">
<li>forced double format at input processing stage</li>
<li>added optional inputs to lassoglm in cv_lassopcrmatlab</li>
<li>added functionality to use variable number of components</li>
<li>forced remove_empty on object to avoid potential problems with empty variables</li>
<li>added/improved documentation, cleaned up code structure for cv_lassopcrmatlab</li>
</ul>
</dd>
<dt>11/28/12: Luke Chang:</dt>
<dd>-fixed bug with optional inputs in cv_lassopcrmatlab - lassoglm
didn&#8217;t like empty cells in varargin
-fixed bug with replace_empty(obj) that was returning brain
weights that were a different size from the input***
-cleaned code structure for cv_lassopcrmatlab
-added functionality to estimate lambda and alpha for
lasspcrmatlab using grid search and nested cross validation</dd>
<dt>1/14/13: Tor Wager: SVM algorithm use updates</dt>
<dd><ul class="first simple">
<li>fixed bug getting distance from hyperplane with svm</li>
<li>fixed bug with input of slack var params (&#8216;C=x&#8217;) in svm</li>
<li>return cross-validated distance from hyperplane in special</li>
</ul>
<p class="last">output
- added stats.weight_obj; ...and intercept values in stats.other_output_cv{:,3}</p>
</dd>
<dt>2/21/13: Luke Chang:</dt>
<dd><ul class="first simple">
<li>fixed bug with cv_lassopcr - now restimates betas selected</li>
</ul>
<p class="last">with lasso using OLS (see hastie, friedman, tibrishani pg 92)
- added new functionality to SVM, rbf kernel
- added new functionality to SVM can estimate slack parameter
(or sigma if using rbf) using nested xVal.  For some reason
this isn&#8217;t working super well yet, could have something to do
with loss function.  Someone should look into this.</p>
</dd>
<dt>2/26/13: Luke Chang:</dt>
<dd><ul class="first simple">
<li>added new functionality to cv_svm - can now perform</li>
</ul>
<p class="last">classification of multiple classes using one vs rest</p>
</dd>
<dt>3/5/13: Tor Wager:</dt>
<dd><ul class="first simple">
<li>lassopcr : fixed bug in lasso_num to return correct num components</li>
<li>added nopcr option to cv_lassopcr and cv_lassopcrmatlab</li>
<li>cv_lassopcrmatlab: fixed bug: lasso_num not selecting correctly</li>
</ul>
<p class="last">was not re-fitting OLS solution after selecting components with lasso</p>
</dd>
<dt>3/6/13:  Tor Wager</dt>
<dd><ul class="first last simple">
<li>fixed minor bug introduced in last version with lassopcr/full rank</li>
<li>added stats.weight_obj, an fmri_data object with the predictive weights (from full sample)</li>
</ul>
</dd>
<dt>3/8/13: Tor Wager</dt>
<dd><ul class="first simple">
<li>working on bootstrapping, not a full solution yet</li>
<li>rocha lasso seems to be ok, but others not (cv_pcr, matlab</li>
</ul>
<p class="last">lasso) returning stable weights
- added code to use only non-redundant components in pcr, to
avoid warnings/instability during bootstrapping.</p>
</dd>
<dt>3/23/13: Wani Woo</dt>
<dd><ul class="first last simple">
<li>implemented &#8216;EstimateParams&#8217; option in rocha lasso. With this
option, you can use the subset of coefficients that are non-zero
predictors based on the optimal lambda estimation. The optimal
lambda will be chosen based on the minimization of mean square
error (MSE) of netsed cross-validation.</li>
<li>For this, cv_lassopcr now calls &#8220;lasso_cv.m&#8221; instead of &#8220;lasso_rocha.m&#8221;
, but lasso_cv calls lasso_rocha. lasso_cv gives the results of nested
cross-validation, which is using to select the optimal lambda,
in addition to all the outputs that lasso_rocha gives. For this
reason, I think it is beneficial to use lasso_cv instead of
lasso_rocha.</li>
<li>In order to make this possible, I added a variable,
cv_assignment, into funhan. However, only cv_lassopcr is
actually using the variable.</li>
</ul>
</dd>
<dt>6/10/13: Luke Chang</dt>
<dd>-Added balanced_ridge option to SVM.
-fixed some bugs with the cv_svm multiclass support</dd>
<dt>6/25/13: Luke Chang</dt>
<dd>-Added try/catch on lassopcr.  Will output nans if there is a
problem running PCA.  Should help with problems with svd
convergence when bootsrapping.
-turned off parallel by default for bootstrapping.  memory is
duplicated for each worker so will crash if not enough memory.
Also bootstrp seems to preallocate.</dd>
<dt>6/29/13: Luke Chang</dt>
<dd>-added option to save bootstrap weights &#8216;savebootweights&#8217;.
This is useful if you want to aggregate bootstrap samples from
multiple iterations of predict() run at different times or
on different computers</dd>
<dt>7/2/13: Luke Chang</dt>
<dd>-added ability to not cross-validate by setting nfolds, k=1
-made a bunch of changes to bootstrapping to reduce memory
demands and fixed bugs to output weights.
-added nancorr to ignore nans when calculating correlation
-added rng &#8216;shuffle&#8217; to ensure that bootstrapping will use
different inital seed.  VERY IMPORTANT for aggregating across
multiple boostrap sessions!</dd>
<dt>11/28/13: Luke Chang</dt>
<dd>-added ability to use hv block cross-validation, which is good
for timeseries data with stationary autocorrelation.
Use &#8216;hvblock,[h,v]</dd>
<dt>12/16/13: Luke Chang</dt>
<dd>-added ability to use rolling block cross-validation with the 
ability to deal with autocorrelation, which is good
for timeseries data with stationary autocorrelation.
Use &#8216;rolling,[h,v,g]</dd>
<dt>4/3/14: Luke Chang</dt>
<dd>-fixed bug with SVM, cross-validated distance from hyper plane
(hopefully, the distance from hyper plane is still correct)
-fixed bug with SVM &#8216;nfolds&#8217;,1</dd>
<dt>2/28/15: Luke Chang</dt>
<dd>-added platt scalling option for SVM</dd>
<dt>4/7/15: Wani Woo: SVM algorithm use updates</dt>
<dd><ul class="first last simple">
<li>fixed bug with input of slack var params (&#8216;C=x&#8217;) in svm</li>
</ul>
</dd>
<dt>5/7/15: Anjali and Wani: replaced princomp for PCA with SVD on transpose</dt>
<dd>training data for three algorithms, cv_pcr, cv_lassopcr,
cv_lassopcrmatlab. This reduces running time substantially.</dd>
</dl>
<p>9/4/2015: Tor: Created more functional statistic_image output in
weight_obj when bootstrapping.  Now p-values, etc. are included so you
can threshold.
&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;
Defaults
&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;</p>
</dd></dl>

<dl class="function">
<dt id="&#64;fmri_data.predict_test_suite">
<code class="descclassname">&#64;fmri_data.</code><code class="descname">predict_test_suite</code><span class="sig-paren">(</span><em>dat</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@fmri_data.predict_test_suite" title="Permalink to this definition">¶</a></dt>
<dd><p>Run a set of cross-validated prediction algorithms on an fmri_data object
and plot the outcome.</p>
<p>[allcverr, allyhat] = predict_test_suite(dat, [optional inputs])</p>
<p>Functionality:
- Requires matlab 2012a or later for full functionality
- Handles categorical or continuous outcomes automatically</p>
<dl class="docutils">
<dt>dat       an fMRI data object. </dt>
<dd>dat.Y must be assigned, and must have continuous or binary outcomes assigned.</dd>
</dl>
<p>Optional:
&#8216;quick&#8217;   Skip extended output
&#8216;nfolds&#8217;, Followed by number of folds or custom holdout vector (default = 5-fold balanced)</p>
<p>&lt;documentation in development&gt;</p>
<p>predict_test_suite(dat, &#8216;nfolds&#8217;, subjid);</p>
<p>Tor Wager, copyright 2012. Initial version: Nov 2012
Programmers&#8217; notes:
Here are possible extensions to the functionality:
1) Test different data scaling methods in preprocess(dat) and/or
rescale(dat)</p>
<ol class="arabic simple" start="2">
<li>Feature selection: Test effects of thresholding weight maps
(and others)</li>
<li>Test &#8220;best case&#8221; feature selection effects - circular analysis</li>
</ol>
<p>Lasso trace plots?  Optimal alpha/lambda in elastic net?</p>
</dd></dl>

<dl class="function">
<dt id="&#64;fmri_data.regress">
<code class="descclassname">&#64;fmri_data.</code><code class="descname">regress</code><span class="sig-paren">(</span><em>dat</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@fmri_data.regress" title="Permalink to this definition">¶</a></dt>
<dd><p>out = regress(dat, varargin)</p>
<blockquote>
<div><p>regression method for fmri_data object</p>
<p>Regress dat.X on dat.dat at each voxel, and return voxel-wise statistic
images. Each column of dat.X is a predictor in a multiple regression,
and the intercept is the last column. Intercept will automatically be
added if not detected unless &#8216;nointercept&#8217; is specified.</p>
<p>This function can also create a map of brain regions that predict the dat.Y
vector using the &#8216;brainony&#8217; option.  This is essentially a univariate
version of the &#8216;predict&#8217; command.  Warning: this is very slow as it loops
through all voxels.</p>
<p>Regression is OLS by default, but can be robust using &#8216;robust&#8217; flag.
Warning: Running robust option is considerably slower than OLS.</p>
<dl class="docutils">
<dt>dat:                  should be an fmri_data object with X field defined.</dt>
<dd>dat.X can be a design_matrix() object.</dd>
</dl>
<dl class="docutils">
<dt>[threshold, &#8216;unc&#8217;]:   p-value threshold string indicating threshold type</dt>
<dd>(see help statistic_image.threshold for options)</dd>
</dl>
<p>&#8216;nointercept&#8217;         Do not add intercept to model
&#8216;nodisplay&#8217;           Do not plot thresholded results using orthviews
&#8216;brainony&#8217;            univariate approach to predict obj.Y from brain data
&#8216;residual&#8217;            Output residual as fmri_data() object
&#8216;noverbose&#8217;           Suppress verbose outputs</p>
<dl class="docutils">
<dt>out:                  A structure containing stats_img and fmri_data</dt>
<dd>objects.</dd>
<dt>out.b:                stats_img object of beta values estimated from</dt>
<dd>regression</dd>
</dl>
<p>out.t:                stats_img object of t-values with input threshold
out.df:               fmri_data object of degrees of freedom
out.sigma:            fmri_data object of variance of residual
out.residual:         (optional) fmri_data object of residual data after</p>
<blockquote>
<div>model has been regressed out.</div></blockquote>
<p>% Run regression with liberal threshold
out = regress(dat, .05, &#8216;unc&#8217;);</p>
<p>% Run regression with conservative threshold and save residual
out = regress(dat, .001, &#8216;unc&#8217;, &#8216;residual);</p>
<p>% Run robust regression with fdr threshold
out = regress(dat, .05, &#8216;fdr&#8217;,&#8217;robust&#8217;);</p>
<p>%Run a regression predicting behavior from brain at liberal threshold
out  = regress(data_comb, .05, &#8216;unc&#8217;, &#8216;brainony&#8217;)</p>
<p>% Re-threshold at different values
out.t = threshold(out.t, .05, &#8216;fdr&#8217;);
out.t = threshold(out.t, .001, &#8216;unc&#8217;);</p>
<p>% Re-display results of thresholding
orthviews(out.t);</p>
<p>% Write out beta image to current directory
out.b.fullpath = fullfile(pwd,&#8217;beta.nii&#8217;);
write(out)</p>
<p>Copyright (c) 2015 Tor Wager &amp; Luke Chang</p>
<p>Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the &#8220;Software&#8221;),
to deal in the Software without restriction, including without limitation
the rights to use, copy, modify, merge, publish, distribute, sublicense,
and/or sell copies of the Software, and to permit persons to whom the
Software is furnished to do so, subject to the following conditions:</p>
<p>The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Software.</p>
<p>THE SOFTWARE IS PROVIDED &#8220;AS IS&#8221;, WITHOUT WARRANTY OF ANY KIND, EXPRESS
OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.</p>
</div></blockquote>
<dl class="docutils">
<dt>Notes:</dt>
<dd>c Tor Wager, Dec 2010
Edited by Luke Chang, 9/27/2012 to add optional input to reverse X &amp; Y (i.e., create a map of voxels that predict the behavioral variable)
Edited by Luke Chang, 9/28/2012 to add optional input to run robust regression for brainony
Edited by Luke Chang, 10/24/2012 to save residuals (i.e., out.r), which is helpful for denoising an image
Edited by Luke Chang, 3/26/2013 to add optional input to not add an intercept - allows for more flexible modeling options
Code completely refactored by Luke Chang 2/24/25
Verbose option updated by Tor, 7/2015
&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;
Defaults
&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="&#64;fmri_data.rescale">
<code class="descclassname">&#64;fmri_data.</code><code class="descname">rescale</code><span class="sig-paren">(</span><em>fmridat</em>, <em>meth</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@fmri_data.rescale" title="Permalink to this definition">¶</a></dt>
<dd><p>fmridat = rescale(fmridat, meth)</p>
<p>Rescales data in an fmri_data object
Data is observations x images, so operating on the columns operates on
images, and operating on the rows operates on voxels (or variables more
generally) across images.</p>
<p>Methods:
&#8216;centervoxels&#8217;
&#8216;zscorevoxels&#8217;
&#8216;centerimages&#8217;
&#8216;zscoreimages&#8217;
&#8216;rankvoxels&#8217;</p>
<p>&#8216;windsorizevoxels&#8217;
&#8216;percentchange&#8217;
&#8216;tanh&#8217;</p>
<p>Appropriate for multi-session (time series) only:
&#8216;session_global_percent_change&#8217;
&#8216;session_global_z&#8217;
&#8216;session_multiplicative&#8217;</p>
<p>see also fmri_data.preprocess</p>
</dd></dl>

<dl class="function">
<dt id="&#64;fmri_data.saveplots">
<code class="descclassname">&#64;fmri_data.</code><code class="descname">saveplots</code><span class="sig-paren">(</span><em>fmri_dat</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@fmri_data.saveplots" title="Permalink to this definition">¶</a></dt>
<dd><p>Output dir</p>
</dd></dl>

<dl class="function">
<dt id="&#64;fmri_data.signtest">
<code class="descclassname">&#64;fmri_data.</code><code class="descname">signtest</code><span class="sig-paren">(</span><em>dat</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@fmri_data.signtest" title="Permalink to this definition">¶</a></dt>
<dd><p>[out, statimg] = signtest(dat, [p-val threshold], [thresh_type])</p>
<p>sign test for each voxel of an fmri_data object
returns voxel-wise statistic images.</p>
<p>Inputs:
dat should be an fmri_data object with .dat field containing voxels x observations matrix
optional inputs in [  ] above are:
p-value threshold 
string indicating threshold type (see help statistic_image.threshold for options)</p>
<p>Outputs:
out is a structure of information about the sign test
statimg is a statistic_image object that can be thresholded and
plotted/imaged.  statimg.dat contains signed direction values, .p contains p-values</p>
<p>c Tor Wager, 2011
See also: fmri_data.regress</p>
<p>Examples:</p>
<p>default options for thresholding</p>
</dd></dl>

<dl class="function">
<dt id="&#64;fmri_data.ttest">
<code class="descclassname">&#64;fmri_data.</code><code class="descname">ttest</code><span class="sig-paren">(</span><em>fmridat</em>, <em>pvalthreshold</em>, <em>thresh_type</em><span class="sig-paren">)</span><a class="headerlink" href="#@fmri_data.ttest" title="Permalink to this definition">¶</a></dt>
<dd><p>T-test on fmri_data class object
statsimg = ttest(fmridat, pvalthreshold, thresh_type)</p>
<p>ttest(fmridat, p-value threshold, thresh_type)</p>
<p>p-value threshold: p-value, e.g., .05 or .001 or [.001 .01 .05]
thresh_type: &#8216;uncorrected&#8217;, &#8216;fwe&#8217;, or &#8216;fdr&#8217;</p>
<p>e.g., 
T-test, Construct a stats_image object, threshold and display:
statsimg = ttest(fmridat, .001, &#8216;unc&#8217;);
orthviews(statsimg);</p>
<p>Re-threshold and display:
statsimg = threshold(statsimg, .000001, &#8216;unc&#8217;);
orthviews(statsimg);</p>
<p>statsimg = threshold(statsimg, .01, &#8216;fdr&#8217;);
orthviews(statsimg);</p>
<p>NOTE: for two-sample T-test, use fmri_data.regress</p>
</dd></dl>

<dl class="function">
<dt id="&#64;fmri_data.windsorize">
<code class="descclassname">&#64;fmri_data.</code><code class="descname">windsorize</code><span class="sig-paren">(</span><em>obj</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@fmri_data.windsorize" title="Permalink to this definition">¶</a></dt>
<dd><p>obj = windsorize(obj, [madlimit])</p>
<p>Windsorize an fMRI data object to madlimit Median Absolute Deviations.
Default = 5 MADs.
Works across rows and columns.
Registers this step in history.
&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;
Calculate and display descriptives
&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;</p>
</dd></dl>

</div>
<div class="section" id="module-&#64;fmri_mask_image">
<span id="fmri-mask-image"></span><h1>fmri_mask_image<a class="headerlink" href="#module-@fmri_mask_image" title="Permalink to this headline">¶</a></h1>
<dl class="function">
<dt id="&#64;fmri_mask_image.resample_to_image_space">
<code class="descclassname">&#64;fmri_mask_image.</code><code class="descname">resample_to_image_space</code><span class="sig-paren">(</span><em>obj</em>, <em>sampleto</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@fmri_mask_image.resample_to_image_space" title="Permalink to this definition">¶</a></dt>
<dd><p>obj = resample_to_image_space(obj, sampleto &lt;img name or image_vector object&gt;)</p>
<p>Resamples data in an fmri_mask_image object (obj) to the space of another
image (e.g., a functional image, for data extraction)
The volInfo field will be the same as the sampleto volume info.
The mask will have zeros in obj.dat for out-of-mask voxels.
THIS FUNCTION USES SCN_MAP_IMAGE AND REQUIRES THAT THE ORIGINAL IMAGE BE
AVAILABLE ON DISK.  Multiple resamplings will break the function because
the new space will be different from the original one on disk.  Use the
more general resample_space.</p>
<p>% NOTE: Mask is <em>reloaded</em> from original data if space is remapped, and you
cannot use manual thresholding of the mask. This is a feature of the
map_to_image_space method and scn_map_image</p>
<p>obj must be an fmri_mask_image object
sampleto can be either:
1) An image name to sample to
2) Another fmri_mask_image object (but image must exist on path!)</p>
<p>SEE ALSO: resample_space, for a method that does not require images to
exist on disk on the path.</p>
<p>Optional inputs:
&#8216;mask&#8217; : Apply sampleto as mask so that only voxels in the sampleto mask
are retained in obj.dat.</p>
<p>THIS FUNCTION WORKS, BUT IS DEPRECATED BECAUSE RESAMPLE_SPACE IS MORE
GENERAL.  resample_space does not require the resampling of the original
image from disk, which this does.  resample_space is slower, though.
Programmers&#8217; notes
Tor: July 2011: Edited because old version will apply mask when resampling
space. Edited default behavior to NOT mask with voxels only in sampleto
space.  This could cause bugs in other functions that need to be worked
out.  The optional argument &#8216;mask&#8217; should produce the old default
behavior.</p>
<p>Oct 30, 2011: obj.dat field after sampling did not conform to standard,
because only in-mask voxels in volInfo were not selected.  This was
fixed.</p>
</dd></dl>

</div>
<div class="section" id="module-&#64;fmri_model">
<span id="fmri-model"></span><h1>fmri_model<a class="headerlink" href="#module-@fmri_model" title="Permalink to this headline">¶</a></h1>
<dl class="function">
<dt id="&#64;fmri_model.build">
<code class="descclassname">&#64;fmri_model.</code><code class="descname">build</code><span class="sig-paren">(</span><em>obj</em><span class="sig-paren">)</span><a class="headerlink" href="#@fmri_model.build" title="Permalink to this definition">¶</a></dt>
<dd><p>obj = build(fmri_model_obj)</p>
<p>Build the design matrix (xx) for an fmri_model object</p>
<p>We assume that the same conditions are modeled for each session
We assume that you have one basis set per condition (this is different
from SPM, which only allows a single basis set across all conditions)
Define sessions and number of conditions</p>
</dd></dl>

<dl class="function">
<dt id="&#64;fmri_model.build_single_trial">
<code class="descclassname">&#64;fmri_model.</code><code class="descname">build_single_trial</code><span class="sig-paren">(</span><em>obj</em>, <em>inputhrf</em><span class="sig-paren">)</span><a class="headerlink" href="#@fmri_model.build_single_trial" title="Permalink to this definition">¶</a></dt>
<dd><p>obj = build_single_trial(fmri_model_obj, inputhrf)</p>
<p>Build a single-trial design matrix (xx) for an fmri_model object</p>
<p>We assume that the same conditions are modeled for each session
We assume that you have one basis set per condition (this is different
from SPM, which only allows a single basis set across all conditions)</p>
<p>This is used in single_trial_estimates, which assumes that you have
estimated an initial model and saved image data.</p>
<p>The idea behind this is somewhat different from other canlab single-trial
analyses, in that it takes in a single, custom HRF for each condition,
rather than using a basis set.  In single_trial_estimates, custom HRFs
are created for each voxel by using the condition- and voxel-specific hrf
estimates stored during model fitting.
The sequence would be:
1 - robustfit(my_model), to fit average model and get HRF est for each
voxel
2 - single_trial_estimates(my_model), to use this function to build
single-trial design matrices and fit them.</p>
<p>inputhrf should be a cell array of length nconds (number of conditions).
Check assumptions and basis set
We assume that the same conditions are modeled for each session</p>
</dd></dl>

<dl class="function">
<dt id="&#64;fmri_model.get_condition_assignments">
<code class="descclassname">&#64;fmri_model.</code><code class="descname">get_condition_assignments</code><span class="sig-paren">(</span><em>obj</em><span class="sig-paren">)</span><a class="headerlink" href="#@fmri_model.get_condition_assignments" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>Indicator matrix coding for which columns in X belong to the same</li>
</ul>
<p>modeled condition, and are part of the same HRF fit
- There is one set of columns for each condition modeled, and one set of
columns for each parametric modulator of each condition
- Because parametric modulators may not exist for all conditions, we need
to build this dynamically for modulators.</p>
<p>Design matrix build (which calls method get_session_X) builds columns in
this order:
All within Session:
Regressors of interest, basis functions within conditions
Parametric modulators, basis functions within conditions
Covariates of no interest
Then:
Baselines (session/run intercepts)</p>
<p>This method is called automatically in the build method.</p>
</dd></dl>

<dl class="function">
<dt id="&#64;fmri_model.get_session_X">
<code class="descclassname">&#64;fmri_model.</code><code class="descname">get_session_X</code><span class="sig-paren">(</span><em>obj</em>, <em>s</em><span class="sig-paren">)</span><a class="headerlink" href="#@fmri_model.get_session_X" title="Permalink to this definition">¶</a></dt>
<dd><p>[Xs, delta, C, B, names] = get_session_X(obj, session number)</p>
<p>Get design matrix (predictors) for one session of fmri_model object, using
basis functions defined in the object and onsets for one session (s).</p>
</dd></dl>

<dl class="function">
<dt id="&#64;fmri_model.plot">
<code class="descclassname">&#64;fmri_model.</code><code class="descname">plot</code><span class="sig-paren">(</span><em>obj</em><span class="sig-paren">)</span><a class="headerlink" href="#@fmri_model.plot" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="&#64;fmri_model.replace_basis_set">
<code class="descclassname">&#64;fmri_model.</code><code class="descname">replace_basis_set</code><span class="sig-paren">(</span><em>obj</em>, <em>condition_num</em>, <em>xBF_hires</em><span class="sig-paren">)</span><a class="headerlink" href="#@fmri_model.replace_basis_set" title="Permalink to this definition">¶</a></dt>
<dd><p>obj = replace_basis_set(obj, condition_num, xBF_hires)</p>
<p>Replace a basis set in an fmri_model object with another one of your
choosing.</p>
<p>This allows one to use a custom basis set, and also to use different
basis sets for different trial types.</p>
<p>Each condition across all sessions must be modeled with the same basis
set. That is, there can be only one basis set per condition, e.g., one
for anticipation (used in each session) and one for pain.</p>
<p>e.g., generate a custom spline basis set and use that for Condition 1,
and the standard one for Condition 2:</p>
<p>[xBF_hires, xBF] = fmri_spline_basis(2, &#8216;length&#8217;, 12, &#8216;nbasis&#8217;, 3, &#8216;order&#8217;, 3, &#8216;plot&#8217;);
save this to get info that is not typically in basis set until after
model is built.</p>
</dd></dl>

<dl class="function">
<dt id="&#64;fmri_model.robustfit">
<code class="descclassname">&#64;fmri_model.</code><code class="descname">robustfit</code><span class="sig-paren">(</span><em>fmri_model_obj</em>, <em>fmri_data_obj</em><span class="optional">[</span>, <em>optional args</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#@fmri_model.robustfit" title="Permalink to this definition">¶</a></dt>
<dd><p>robust fit for a model object to data object</p>
<p>Features:
spatial smoothing of weights at 12 mm FWHM
ridge regression <strong>*not yet*</strong></p>
<p>Preproc scaling:
1) Remove covariates using ridge reg; ridge trace for full model
2) scale to % signal change across time (cols) OR rank time points (for
w/i ss predictions??) AND/OR rank or center rows (images; for &#8216;shape&#8217;
analysis</p>
<p>Example: %sig across time, rank across rows: relative % sig change
Different models of noise lead to different ideas about optimal preproc
If large diffs in nuisance scaling in BOLD across individuals, ranking cols may
be good idea. but then individual diffs in overall activity will be removed...</p>
<p>&#8216;tune&#8217;, tuning const for robust reg
&#8216;iter&#8217;, &#8216;maxiterations&#8217;, robust reg /WLS iterations. 1 = OLS only!
&#8216;smooth&#8217;, &#8216;spatial_smooth_fwhm&#8217;, 0 or smoothing kernel for weights</p>
<p>&#8216;nosmooth&#8217;, spatial_smooth_fwhm = 0;
&#8216;stats&#8217;, &#8216;calculate_stats&#8217;, calculate_stats = 1; IN DEVELOPMENT
&#8216;noresiduals&#8217;, write_residuals = 0;
&#8216;noplots&#8217;, save_plots = 0;
Defaults/constants
&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;</p>
</dd></dl>

<dl class="function">
<dt id="&#64;fmri_model.saveplots">
<code class="descclassname">&#64;fmri_model.</code><code class="descname">saveplots</code><span class="sig-paren">(</span><em>fmri_model</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@fmri_model.saveplots" title="Permalink to this definition">¶</a></dt>
<dd><p>Output dir</p>
</dd></dl>

<dl class="function">
<dt id="&#64;fmri_model.single_trial_estimates">
<code class="descclassname">&#64;fmri_model.</code><code class="descname">single_trial_estimates</code><span class="sig-paren">(</span><em>obj</em>, <em>fmri_data_obj</em><span class="sig-paren">)</span><a class="headerlink" href="#@fmri_model.single_trial_estimates" title="Permalink to this definition">¶</a></dt>
<dd><p>Write single trial estimates associated with an estimated fmri_model object.
must have estimated the model (robustfit(obj); see fmri_model.robustfit)
and saved hrf*.img images for each condition.</p>
<p>Also input an fmri_data object with time series data.</p>
<p>This function writes images, one 4-D image for each condition, with the
number of frames equalling the number of trials (onsets) for that
condition.</p>
<p>It does this by constructing a separate design matrix for each voxel,
which is based on the HRF estimates for that voxel for each condition.
Fits for all conditions are added to the same model, so that their
colinearity influences the single-trial parameter estimates.</p>
</dd></dl>

</div>
<div class="section" id="module-&#64;fmri_timeseries">
<span id="fmri-timeseries"></span><h1>fmri_timeseries<a class="headerlink" href="#module-@fmri_timeseries" title="Permalink to this headline">¶</a></h1>
</div>
<div class="section" id="module-&#64;image_vector">
<span id="image-vector"></span><h1>image_vector<a class="headerlink" href="#module-@image_vector" title="Permalink to this headline">¶</a></h1>
<dl class="function">
<dt id="&#64;image_vector.apply_mask">
<code class="descclassname">&#64;image_vector.</code><code class="descname">apply_mask</code><span class="sig-paren">(</span><em>dat</em>, <em>mask</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@image_vector.apply_mask" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply a mask image (image filename or fmri_mask_image object) to an image_vector object
stored in dat.</p>
<dl class="docutils">
<dt>This can be used to:</dt>
<dd><ul class="first last simple">
<li>Mask an image_vector or fmri_data object with a mask</li>
<li>Obtain &#8220;pattern expression&#8221; for a weight map (entered as the
mask, here) in a series of images stored in dat.</li>
</ul>
</dd>
</dl>
<p>The mask or weight map does not have to be in the same space as the dat;
it will be resampled to the space of the data in dat.</p>
<p>To extract pattern expression values for each ROI within a mask use extract_roi_averages()</p>
<p><em>Optional inputs:</em></p>
<p>&#8216;pattern_expression&#8217; : calculate and return the cross-product of each
image in dat and the values in the mask.  This is useful if comparing
expression values that are comprised of different datasets or differing
number of voxels.</p>
<p>&#8216;correlation&#8217; : calculate the pearson correlation coefficient of each
image in dat and the values in the mask.</p>
<p>&#8216;norm_mask&#8217;: normalize the mask weights by L2 norm, for patt expression
only.</p>
<p>&#8216;ignore_missing&#8217;: use with pattern expression only. Ignore weights on voxels
with zero values in test image. If this is not entered, the function will
check for these values and give a warning.</p>
<p>&#8216;invert&#8217;: Invert the mask so that out-of-mask voxels are now in (using
the mask as an &#8216;exclude mask&#8217; rather than an include-mask. If pattern
expression is requested, the behavior is different, and it inverts the
sign of in-mask pattern weights.</p>
<blockquote>
<div><ul class="simple">
<li>[dat, mask] = apply_mask(dat, mask)</li>
<li>[dat, mask] = apply_mask(dat, mask image name)</li>
<li>[dat, mask] = apply_mask(dat, mask image vector object)</li>
<li>[pattern_exp_values] = apply_mask(dat, weight map image, &#8216;pattern_expression&#8217;, &#8216;ignore_missing&#8217;)</li>
<li>[pattern_exp_values] = apply_mask(dat, weight map image, &#8216;pattern_expression&#8217;, &#8216;ignore_missing&#8217;,&#8217;correlation&#8217;)</li>
</ul>
</div></blockquote>
<p><em>See also:</em></p>
<p>extract_roi_averages, to get individual region averages / local pattern expression
apply_nps, which does whole-pattern and local regional expression</p>
<p><em>Notes:</em></p>
<p>Last modified: 10/30/11 to add support for masks that are weight maps</p>
<p>12/15/13:  Luke Chang - added correlation option for pattern-expression, 
set options</p>
</dd></dl>

<dl class="function">
<dt id="&#64;image_vector.check_image_filenames">
<code class="descclassname">&#64;image_vector.</code><code class="descname">check_image_filenames</code><span class="sig-paren">(</span><em>obj</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@image_vector.check_image_filenames" title="Permalink to this definition">¶</a></dt>
<dd><p>Check whether images listed in obj.fullpath actually exist</p>
<p>obj = check_image_filenames(obj, [&#8216;noverbose&#8217;])</p>
<p><em>Behavior:</em></p>
<p>If there are no file names, do nothing.
If file names are entered and full path is not, attempt to find full
path.
If full path info is entered, check to see if files exist.
Return output in obj.files_exist, and print a warning if only some exist.</p>
<p>Image names should be stored in .fullpath
abbreviated image names may be stored in image_names.</p>
<p><em>Notes:</em></p>
<p>fullpath should have full path to each volume in a string matrixm, with
trailing ,volume# for 4-D images as per SPM style expanded list.
image_names should have image name only for each volume</p>
<p><a href="#id1"><span class="problematic" id="id2">**</span></a>* May still be debugging issues with 3-D vs. 4-D files
if &#8216;noverbose&#8217; is entered, suppress output</p>
</dd></dl>

<dl class="function">
<dt id="&#64;image_vector.compare_space">
<code class="descclassname">&#64;image_vector.</code><code class="descname">compare_space</code><span class="sig-paren">(</span><em>obj</em>, <em>obj2</em><span class="sig-paren">)</span><a class="headerlink" href="#@image_vector.compare_space" title="Permalink to this definition">¶</a></dt>
<dd><p>function isdiff = compare_space(obj, obj2)</p>
<p>Compare spaces of two image_vector objects</p>
<p>Returns 0 if same, 1 if different spaces, 2 if no volInfo info for one or
more objects. 3 if same space, but different in-mask voxels in .dat or
volInfo.image_indx</p>
</dd></dl>

<dl class="function">
<dt id="&#64;image_vector.extract_gray_white_csf">
<code class="descclassname">&#64;image_vector.</code><code class="descname">extract_gray_white_csf</code><span class="sig-paren">(</span><em>obj</em><span class="sig-paren">)</span><a class="headerlink" href="#@image_vector.extract_gray_white_csf" title="Permalink to this definition">¶</a></dt>
<dd><p>[values, components] = extract_gray_white_csf(obj)</p>
<p>Extracts mean values (values) and top 5 component scores (components)
from each of gray, white, and CSF masks.
Images must be in standard MNI space for this to apply.</p>
<p>obj = an image_vector (e.g., fmri_data) object</p>
<p>Tor Wager, July 21, 2015</p>
</dd></dl>

<dl class="function">
<dt id="&#64;image_vector.extract_roi_averages">
<code class="descclassname">&#64;image_vector.</code><code class="descname">extract_roi_averages</code><span class="sig-paren">(</span><em>obj</em>, <em>mask</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@image_vector.extract_roi_averages" title="Permalink to this definition">¶</a></dt>
<dd><p>cl = extract_roi_averages(image_vector obj, mask, [average_over])</p>
<p>This image_vector method a extracts and averages data stored in an fmri_data object 
from a set of ROIs defined in a mask.
It is <em>slightly</em> different from the fmri_data method, as fmri_data has
more fields.</p>
<p>This version requires the mask_image to be in the same space as the obj.</p>
<p>Regions to average over can be either regions of contiguous voxels
bounded by voxels with values of 0 or NaN, which are considered non-data
values, or regions defined by unique integer codes in the mask image
(i.e., for atlas images with unique codes for each defined region.)</p>
<p>Mask/Atlas image does NOT have to be in the same space as the images to
extract from.  It will be remapped/resliced.</p>
<p>Extracted data is returned in single data format.</p>
<dl class="docutils">
<dt>Inputs:</dt>
<dd><ol class="first last arabic simple">
<li>char array of strings containing 4D image file names (data extracted from these)</li>
<li>mask_image to extract from.</li>
</ol>
</dd>
</dl>
<p><em>Optional inputs:</em></p>
<dl class="docutils">
<dt><strong>average_over:</strong></dt>
<dd><ul class="first last simple">
<li>Default = &#8216;contiguous_regions&#8217; to average over contiguous voxels
bounded by voxels of 0 or NaN (non-data values)</li>
<li>Alt. option = &#8216;unique_mask_values&#8217; to average over unique integer codes in the mask image
(i.e., for atlas images with unique codes for each defined region)</li>
</ul>
</dd>
</dl>
<p><em>Example:</em></p>
<blockquote>
<div><ul class="simple">
<li>imgs_to_extract_from = filenames(&#8216;w*.nii&#8217;,&#8217;char&#8217;);</li>
<li>mask_image = which(&#8216;anat_lbpa_thal.img&#8217;);</li>
<li>[cl, imgdat] = extract_image_data(imgs_to_extract_from, mask_image);</li>
</ul>
</div></blockquote>
<p><em>Related functions:</em></p>
<p>For an non-object-oriented alternative, see extract_image_data.m</p>
</dd></dl>

<dl class="function">
<dt id="&#64;image_vector.fastmontage">
<code class="descclassname">&#64;image_vector.</code><code class="descname">fastmontage</code><span class="sig-paren">(</span><em>dat</em><span class="optional">[</span>, <em>myview</em><span class="optional">]</span><span class="optional">[</span>, <em>'spacing'</em>, <em>slicespacing</em><span class="optional">]</span><span class="optional">[</span>, <em>'vertical'</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#@image_vector.fastmontage" title="Permalink to this definition">¶</a></dt>
<dd><p>fastmontage(dat);</p>
<p>Creates 3 separate montage views - ax, cor, sagg</p>
<p>In special figure window</p>
<blockquote>
<div><ul class="simple">
<li>fastmontage(dat, &#8216;coronal&#8217;);</li>
<li>fastmontage(dat, &#8216;saggital&#8217;, &#8216;spacing&#8217;, 10);</li>
<li>fastmontage(dat, &#8216;saggital&#8217;, &#8216;spacing&#8217;, 10, &#8216;vertical&#8217;);</li>
<li>fastmontage(dat, &#8216;saggital&#8217;, &#8216;slices_per_row&#8217;, 12);</li>
</ul>
</div></blockquote>
<p>Tor Wager, Aug 2012</p>
</dd></dl>

<dl class="function">
<dt id="&#64;image_vector.flip">
<code class="descclassname">&#64;image_vector.</code><code class="descname">flip</code><span class="sig-paren">(</span><em>dat</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@image_vector.flip" title="Permalink to this definition">¶</a></dt>
<dd><p>Flips an image_vector object left to right</p>
<p><em>Optional:</em></p>
<p>input &#8216;mirror&#8217; to make a symmetrical image, averaging the left
and right hemispheres</p>
<blockquote>
<div><ul class="simple">
<li>dat = flip(dat, [&#8216;mirror&#8217;])</li>
</ul>
</div></blockquote>
<p>tor. may 2012</p>
</dd></dl>

<dl class="function">
<dt id="&#64;image_vector.histogram">
<code class="descclassname">&#64;image_vector.</code><code class="descname">histogram</code><span class="sig-paren">(</span><em>obj</em><span class="sig-paren">)</span><a class="headerlink" href="#@image_vector.histogram" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="&#64;image_vector.history">
<code class="descclassname">&#64;image_vector.</code><code class="descname">history</code><span class="sig-paren">(</span><em>dat</em><span class="sig-paren">)</span><a class="headerlink" href="#@image_vector.history" title="Permalink to this definition">¶</a></dt>
<dd><p>Display history for image_vector object</p>
</dd></dl>

<dl class="function">
<dt id="&#64;image_vector.horzcat">
<code class="descclassname">&#64;image_vector.</code><code class="descname">horzcat</code><span class="sig-paren">(</span><em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@image_vector.horzcat" title="Permalink to this definition">¶</a></dt>
<dd><p>function s = horzcat(varargin)</p>
<p>Implements the horzcat ([a b]) operator on image_vector objects across voxels.
Requires that each object has an equal number of columns and voxels</p>
<dl class="docutils">
<dt><em>Examples:</em></dt>
<dd><ul class="first last simple">
<li>c = [dat1 dat2];</li>
</ul>
</dd>
</dl>
<p>Programmer Notes
Created 3/14/14 by Luke Chang</p>
</dd></dl>

<dl class="function">
<dt id="&#64;image_vector.ica">
<code class="descclassname">&#64;image_vector.</code><code class="descname">ica</code><span class="sig-paren">(</span><em>fmridat_obj</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@image_vector.ica" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Spatial ICA of an fmri_data object</dt>
<dd><ul class="first last simple">
<li>icadat = ica(fmridat_obj, [number of ICs to save])</li>
<li>icadat is also an fmri_data object, with .dat field voxels x components</li>
</ul>
</dd>
<dt><em>Notes:</em></dt>
<dd><ul class="first last simple">
<li>icasig = W * mixedsig</li>
<li>icasig = icadat.dat&#8217; = W * fmridat_obj.dat&#8217;</li>
</ul>
</dd>
</dl>
<p>A is scaled version of fmridat_obj.dat&#8217; * icadat.dat</p>
<p>A and W are stored in additional_info field of icadat</p>
</dd></dl>

<dl class="function">
<dt id="&#64;image_vector.image_math">
<code class="descclassname">&#64;image_vector.</code><code class="descname">image_math</code><span class="sig-paren">(</span><em>obj1</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@image_vector.image_math" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform simple mathematical and boolean operations on image objects</p>
<dl class="docutils">
<dt><em>Usage:</em></dt>
<dd><ul class="first last simple">
<li>obj_out = image_math(obj1, [optional inputs, e.g., a 2nd object, keywords])</li>
</ul>
</dd>
<dt>For objects: Type methods(object_name) for a list of special commands</dt>
<dd>Type help object_name.method_name for help on specific
methods.</dd>
<dt><em>Inputs:</em></dt>
<dd><ul class="first last simple">
<li>obj1           An image_vector object</li>
</ul>
</dd>
<dt><em>Optional inputs:</em></dt>
<dd><ul class="first last">
<li><p class="first">obj2                   - An additional image_vector object</p>
</li>
<li><dl class="first docutils">
<dt>{&#8216;add&#8217;, &#8216;plus&#8217;}        - Keyword to perform image-wise addition of images in obj1</dt>
<dd><p class="first last">and obj2.  Assumes these are paired/matched objects.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>{&#8216;subtract&#8217;, &#8216;minus&#8217;}  - Keyword to perform image-wise subtraction of images</dt>
<dd><p class="first last">in obj1 and obj2</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>{&#8216;cat&#8217;, &#8216;concatenate&#8217;} - Concatenate obj1 and obj2 image-wise.  Requires same</dt>
<dd><p class="first last">number of voxels in both image sets.  Returns effects
codes of 1, -1 in obj_out.Y.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>{&#8216;power&#8217;}              - Keyword to raise data to power element-wise; obj.dat = obj.dat.^b;</dt>
<dd><p class="first last">Followed by exponent to apply (b)</p>
</dd>
</dl>
</li>
</ul>
</dd>
<dt><em>Outputs:</em></dt>
<dd><ul class="first last simple">
<li>obj_out        The result - an image_vector object</li>
</ul>
</dd>
</dl>
<p><em>Examples:</em>
give examples here</p>
<p><em>See also:</em>
<em>list other functions related to this one, and alternatives</em>
<em>Programmers&#8217; notes:</em>
List dates and changes here, and author of changes</p>
<p>Author and copyright information:</p>
<blockquote>
<div><p>Copyright (C) 2015  Tor Wager</p>
<p>This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.</p>
<p>This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.</p>
<p>You should have received a copy of the GNU General Public License
along with this program.  If not, see &lt;<a class="reference external" href="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</a>&gt;.</p>
</div></blockquote>
<p>initalize optional variables to default values here.</p>
</dd></dl>

<dl class="function">
<dt id="&#64;image_vector.image_similarity_plot">
<code class="descclassname">&#64;image_vector.</code><code class="descname">image_similarity_plot</code><span class="sig-paren">(</span><em>obj</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@image_vector.image_similarity_plot" title="Permalink to this definition">¶</a></dt>
<dd><p>Point-biserial correlations between images in fmri_data obj and set of
&#8216;spatial basis function&#8217; images (e.g., &#8216;signatures&#8217; or pre-defined maps)</p>
<p>Usage:</p>
<blockquote>
<div><ul class="simple">
<li>stats = image_similarity_plot(obj, &#8216;average&#8217;);</li>
</ul>
</div></blockquote>
<p>This is a method for an image_vector object</p>
<p>Author and copyright information:</p>
<blockquote>
<div><p>Copyright (C) 2015 Tor Wager</p>
<p>This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.</p>
<p>This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.</p>
<p>You should have received a copy of the GNU General Public License
along with this program.  If not, see &lt;<a class="reference external" href="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</a>&gt;.</p>
</div></blockquote>
<p>Inputs:</p>
<p>obj           An image object with one or more images loaded</p>
<p><em>Optional inputs:</em></p>
<dl class="docutils">
<dt>&#8216;average&#8217;     Calculate average over images in obj with standard errors</dt>
<dd>Useful if obj contains one image per subject and you want
to test similarity with maps statistically.
Default behavior is to plot each individual image.</dd>
</dl>
<p><em>Outputs:</em></p>
<dl class="docutils">
<dt>stats         Structure including:</dt>
<dd>.r, Correlations in [7 networks x images in obj] matrix
.t, T-test (if &#8216;average&#8217; is specified)
.line_handles Handles to polar plot lines so you can
customize
.fill_handles Handles to polar plot fills so you can
customize</dd>
</dl>
<p><em>Examples:</em></p>
<p>corrdat is an fmri_data object with 18 images from searchlight
correlation in it.  Then:
stats = image_similarity_plot_bucknermaps(corrdat, &#8216;average&#8217;);</p>
<p>t_diff is a thresholded statistic_image object
stats = image_similarity_plot_bucknermaps(t_diff);</p>
<p><em>See also:</em></p>
<p>tor_polar_plot
<em>Programmers&#8217; notes:</em>
List dates and changes here, and author of changes
&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;-
DEFAULTS AND INPUTS
&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;-
Defaults
&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8211;
initalize optional variables to default values here.</p>
</dd></dl>

<dl class="function">
<dt id="&#64;image_vector.image_similarity_plot_bucknermaps">
<code class="descclassname">&#64;image_vector.</code><code class="descname">image_similarity_plot_bucknermaps</code><span class="sig-paren">(</span><em>obj</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@image_vector.image_similarity_plot_bucknermaps" title="Permalink to this definition">¶</a></dt>
<dd><p>Point-biserial correlations between images in fmri_data obj and Bucker
Lab 7-network maps, with polar plot</p>
<p><em>Usage:</em></p>
<p>stats = image_similarity_plot_bucknermaps(obj, &#8216;average&#8217;);</p>
<p>This is a method for an image_vector object</p>
<p>Author and copyright information:</p>
<blockquote>
<div><p>Copyright (C) 2015 Tor Wager</p>
<p>This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.</p>
<p>This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.</p>
<p>You should have received a copy of the GNU General Public License
along with this program.  If not, see &lt;<a class="reference external" href="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</a>&gt;.</p>
</div></blockquote>
<p><em>Inputs:</em></p>
<p>obj           An image object with one or more images loaded</p>
<p><em>Optional inputs:</em></p>
<dl class="docutils">
<dt>&#8216;average&#8217;     Calculate average over images in obj with standard errors</dt>
<dd>Useful if obj contains one image per subject and you want
to test similarity with maps statistically.
Default behavior is to plot each individual image.</dd>
</dl>
<p><em>Outputs:</em></p>
<dl class="docutils">
<dt>stats         Structure including:</dt>
<dd>.r, Correlations in [7 networks x images in obj] matrix
.t, T-test (if &#8216;average&#8217; is specified)
.line_handles Handles to polar plot lines so you can
customize
.fill_handles Handles to polar plot fills so you can
customize</dd>
</dl>
<p><em>Examples:</em></p>
<p>corrdat is an fmri_data object with 18 images from searchlight
correlation in it.  Then:</p>
<blockquote>
<div><ul class="simple">
<li>stats = image_similarity_plot_bucknermaps(corrdat, &#8216;average&#8217;);</li>
</ul>
</div></blockquote>
<dl class="docutils">
<dt>t_diff is a thresholded statistic_image object</dt>
<dd><ul class="first last simple">
<li>stats = image_similarity_plot_bucknermaps(t_diff);</li>
</ul>
</dd>
</dl>
<p><em>See also:</em></p>
<p>tor_polar_plot</p>
<p><em>Programmers&#8217; notes:</em>
List dates and changes here, and author of changes
&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;-
DEFAULTS AND INPUTS
&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;-
Defaults
&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8211;
initalize optional variables to default values here.</p>
</dd></dl>

<dl class="function">
<dt id="&#64;image_vector.interpolate">
<code class="descclassname">&#64;image_vector.</code><code class="descname">interpolate</code><span class="sig-paren">(</span><em>dat</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@image_vector.interpolate" title="Permalink to this definition">¶</a></dt>
<dd><p>Interpolate over missing values in image_vector object</p>
<blockquote>
<div><ul class="simple">
<li>dat = interpolate(dat, varargin)</li>
</ul>
</div></blockquote>
<p><em>Input:</em> image_vector object (dat; e.g., an fmri_data object)
Use when there are some missing values in the mask image
Performs 3-D linear interpolation to fill in all values in the original
mask.</p>
<p>e.g., For a standard brain image space that is 91 x 109 x 91, you may
have 300,000 in-mask values. Only 150,000 of these may be defined in the
image, however, and the rest are missing (0 or NaN).
This function will return a dat image with non-missing values for all
300,000 voxels (the &#8220;in-mask&#8221; space). 
It will not return values for all voxels in the 91 x 109 x 91 space,
however.</p>
<p><em>Note:</em> This function does not upsample the data now, but could be extended
to do so fairly easily.</p>
<p>values &gt; 1 would upsample the data</p>
</dd></dl>

<dl class="function">
<dt id="&#64;image_vector.mean">
<code class="descclassname">&#64;image_vector.</code><code class="descname">mean</code><span class="sig-paren">(</span><em>obj</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@image_vector.mean" title="Permalink to this definition">¶</a></dt>
<dd><p>function m = mean(obj, [optional args])</p>
<p>Create an image_vector object with mean values for each voxel (cols)
across images (rows) of an fmri_data object.</p>
<p>m is an image_vector object whose data contains the mean values.</p>
<dl class="docutils">
<dt>Options are:</dt>
<dd><ul class="first last simple">
<li>&#8216;write&#8217;, followed by file name</li>
<li>&#8216;path&#8217;, followed by location for file (default = current directory)</li>
<li>&#8216;orthviews&#8217; -&gt; show orthviews for this image, same as orthviews(m)</li>
<li>&#8216;histogram&#8217; -&gt; show histogram for this image, same as histogram(m)</li>
<li>&#8216;plot&#8217; -&gt; do both</li>
</ul>
</dd>
</dl>
<p><em>Examples:</em>
If sdat is an fmri_data object with multiple images,</p>
<blockquote>
<div><ul class="simple">
<li>m = mean(sdat, &#8216;plot&#8217;, &#8216;write&#8217;, anatmeanname, &#8216;path&#8217;, maskdir);</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="&#64;image_vector.minus">
<code class="descclassname">&#64;image_vector.</code><code class="descname">minus</code><span class="sig-paren">(</span><em>obj1</em>, <em>obj2</em><span class="sig-paren">)</span><a class="headerlink" href="#@image_vector.minus" title="Permalink to this definition">¶</a></dt>
<dd><p>function s = minus(obj1, obj2)</p>
<p>Implements the minus (-) operator on image_vector objects across voxels.
Requires that each object has an equal number of columns and voxels</p>
<dl class="docutils">
<dt><em>Examples:</em></dt>
<dd><ul class="first last simple">
<li>c = dat1 - dat2;</li>
</ul>
</dd>
</dl>
<p><em>Programmer Notes</em>
Created 3/14/14 by Luke Chang</p>
</dd></dl>

<dl class="function">
<dt id="&#64;image_vector.montage">
<code class="descclassname">&#64;image_vector.</code><code class="descname">montage</code><span class="sig-paren">(</span><em>image_obj</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@image_vector.montage" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a montage of an image_vector (or statistic_image or fmri_data) object</p>
<dl class="docutils">
<dt><em>Usage:</em></dt>
<dd><ul class="first last simple">
<li>[fig_handle or o2 fmridisp object] = montage(image_obj, [optional arguments])</li>
</ul>
</dd>
<dt><em>Optional inputs:</em></dt>
<dd><ul class="first last simple">
<li>&#8216;fmridisplay&#8217; for fmridisplay object style montage [default]</li>
<li>&#8216;scnmontage&#8217; for circa 2008-style SCN lab montage for each image vector</li>
</ul>
</dd>
<dt><em>Examples:</em></dt>
<dd><ul class="first last simple">
<li>o2 = montage(mask);</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="&#64;image_vector.orthviews">
<code class="descclassname">&#64;image_vector.</code><code class="descname">orthviews</code><span class="sig-paren">(</span><em>image_obj</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@image_vector.orthviews" title="Permalink to this definition">¶</a></dt>
<dd><p>Orthviews display (SPM) for CANlab image_vector (or fmri_data, statistic_image) object</p>
<dl class="docutils">
<dt><em>Usage:</em></dt>
<dd><ul class="first last simple">
<li>orthviews(image_obj, varargin)</li>
</ul>
</dd>
<dt><em>Options:</em></dt>
<dd><ul class="first last">
<li><p class="first">&#8216;posneg&#8217; input generates orthviews using solid colors.</p>
</li>
<li><dl class="first docutils">
<dt>&#8216;largest_region&#8217; to center the orthviews on the largest region in the</dt>
<dd><p class="first last">image</p>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
<p>Copyright Tor Wager, 2011</p>
</dd></dl>

<dl class="function">
<dt id="&#64;image_vector.plot_current_orthviews_coord">
<code class="descclassname">&#64;image_vector.</code><code class="descname">plot_current_orthviews_coord</code><span class="sig-paren">(</span><em>dat</em><span class="sig-paren">)</span><a class="headerlink" href="#@image_vector.plot_current_orthviews_coord" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieves and plots the image data series at the current crosshairs in spm_orthviews</p>
<ul class="simple">
<li>voxel_data_series = plot_current_orthviews_coord(dat)</li>
</ul>
</dd></dl>

<dl class="function">
<dt id="&#64;image_vector.plus">
<code class="descclassname">&#64;image_vector.</code><code class="descname">plus</code><span class="sig-paren">(</span><em>obj1</em>, <em>obj2</em><span class="sig-paren">)</span><a class="headerlink" href="#@image_vector.plus" title="Permalink to this definition">¶</a></dt>
<dd><p>function s = plus(obj1, obj2)</p>
<p>Implements the plus (+) operator on image_vector objects across voxels.
Requires that each object has an equal number of columns and voxels</p>
<dl class="docutils">
<dt><em>Examples:</em></dt>
<dd><ul class="first last simple">
<li>c = dat1 + dat2;</li>
</ul>
</dd>
</dl>
<p><em>Programmer Notes</em>
Created 3/14/14 by Luke Chang</p>
</dd></dl>

<dl class="function">
<dt id="&#64;image_vector.power">
<code class="descclassname">&#64;image_vector.</code><code class="descname">power</code><span class="sig-paren">(</span><em>obj</em>, <em>b</em><span class="sig-paren">)</span><a class="headerlink" href="#@image_vector.power" title="Permalink to this definition">¶</a></dt>
<dd><p>function s = power(obj1, obj2)</p>
<p>Implements the power (^) operator on image_vector objects across voxels.</p>
<dl class="docutils">
<dt><em>Examples:</em></dt>
<dd><ul class="first last simple">
<li>c = dat1^2;</li>
</ul>
</dd>
</dl>
<p><em>Programmer Notes</em>
Created 3/14/14 by Luke Chang</p>
</dd></dl>

<dl class="function">
<dt id="&#64;image_vector.preprocess">
<code class="descclassname">&#64;image_vector.</code><code class="descname">preprocess</code><span class="sig-paren">(</span><em>obj</em>, <em>meth</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@image_vector.preprocess" title="Permalink to this definition">¶</a></dt>
<dd><p>obj = preprocess(obj, meth, varargin)</p>
<p>Preprocesses data in an fmri_data object</p>
<p>Data is observations (i.e., voxels, subjects) x images, so operating on the columns operates on
images, and operating on the rows operates on voxels (or variables more
generally) across images.</p>
<p><em>meth: Options</em></p>
<dl class="docutils">
<dt>&#8216;resid&#8217;: Residualize voxels with respect to covariates</dt>
<dd>Uses obj.covariates, obj.dat.
Adds intercept automatically. You can tell it to add the mean response per voxel back in:
obj = preprocess(obj, &#8216;resid&#8217;, [add mean back in flag])</dd>
</dl>
<p>&#8216;hpfilter&#8217;: High-pass filter and remove run intercepts and first two
images per run.</p>
<blockquote>
<div>Uses obj.dat, obj.images_per_session
obj = preprocess(obj, &#8216;hpfilter&#8217;, HPlen in s, TR)</div></blockquote>
<p>&#8216;windsorize&#8217;: Windsorize entire data matrix to 3 STD</p>
<p>&#8216;windsorizevoxels&#8217;: Windsorize each time series in data matrix to 3 STD</p>
<dl class="docutils">
<dt>&#8216;session_outliers&#8217;: Identify session-wise (run-wise) outliers with significant</dt>
<dd>based on mahalanobis distance with FDR-corrected P-values in chi-square test.
Impute session grand mean outliers.</dd>
</dl>
<p>&#8216;outliers&#8217;: Identify outlier time points for each session based on
mahalanobis distance (see above) across global mean for slices and
spatial STD for slices, as in scn_session_spike_id.
Outliers at 3 SD based on timeseries added to obj.covariates.</p>
<p>&#8216;outliers_rmssd&#8217;: Identify outlier time points for each session based on
root-mean-square successive differences between images (across voxels.)
this is the std (across voxels) of the successive diffs across images.
Outliers at 3.5 SD based on timeseries added to obj.covariates.</p>
<dl class="docutils">
<dt>&#8216;smooth&#8217;:  Smoothed images with Gaussian filter</dt>
<dd>obj = preprocess(obj, &#8216;smooth&#8217;, FWHM in mm)</dd>
</dl>
<p>% NOTE: SMOOTHING KERNEL MAY BE IN VOX, AS VOL INFO IS NOT PASSED IN</p>
<p>&#8216;interp_images&#8217;: Interpolate all voxels in a series of images specified
by logical vector whout.</p>
<blockquote>
<div><ul class="simple">
<li>obj = preprocess(obj, &#8216;interp_images&#8217;, whout);</li>
</ul>
</div></blockquote>
<dl class="docutils">
<dt><em>Examples:</em> two complementary ways to get and plot outliers:</dt>
<dd><ul class="first last simple">
<li>dat = preprocess(dat, &#8216;outliers&#8217;, &#8216;plot&#8217;);</li>
<li>subplot(5, 1, 5); % go to new panel...</li>
<li>dat = preprocess(dat, &#8216;outliers_rmssd&#8217;, &#8216;plot&#8217;);</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="&#64;image_vector.read_from_file">
<code class="descclassname">&#64;image_vector.</code><code class="descname">read_from_file</code><span class="sig-paren">(</span><em>obj</em><span class="sig-paren">)</span><a class="headerlink" href="#@image_vector.read_from_file" title="Permalink to this definition">¶</a></dt>
<dd><p>Reads data from image filenames into obj.dat</p>
<blockquote>
<div><ul class="simple">
<li>obj = read_from_file(obj)</li>
</ul>
</div></blockquote>
<p>Try obj = check_image_filenames(obj) first.</p>
<p>This is automatically called if you create a new image_vector object with
names but do not directly enter data. e.g., the commands below will load data:</p>
<blockquote>
<div><ul class="simple">
<li>name = &#8216;salientmap.nii&#8217;;</li>
<li>img = image_vector(&#8216;image_names&#8217;, name);</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="&#64;image_vector.rebuild_volinfo_from_dat">
<code class="descclassname">&#64;image_vector.</code><code class="descname">rebuild_volinfo_from_dat</code><span class="sig-paren">(</span><em>dat</em>, <em>newdat</em><span class="sig-paren">)</span><a class="headerlink" href="#@image_vector.rebuild_volinfo_from_dat" title="Permalink to this definition">¶</a></dt>
<dd><p>dat = rebuild_volinfo_from_dat(dat, newdat)</p>
<p>Will rebuild volInfo (the image space, or sometimes &#8220;mask&#8221;) from a vectorized image. 
In other words, will rebuild dat.volInfo from newdat.</p>
<p>Also resets all voxels to be significant, if a statistic image</p>
<dl class="docutils">
<dt><em>Input</em></dt>
<dd><ul class="first last simple">
<li>dat: an image_vector</li>
<li>newdat: a vector that MUST be size of ENTIRE image (dat.volInfo.nvox)</li>
</ul>
</dd>
<dt><em>Output</em></dt>
<dd><ul class="first last">
<li><dl class="first docutils">
<dt>dat: dat.dat contains the non-zero values of newdat, and dat.volInfo is</dt>
<dd><p class="first last">correctly defining the image space</p>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="&#64;image_vector.reconstruct_image">
<code class="descclassname">&#64;image_vector.</code><code class="descname">reconstruct_image</code><span class="sig-paren">(</span><em>obj</em><span class="sig-paren">)</span><a class="headerlink" href="#@image_vector.reconstruct_image" title="Permalink to this definition">¶</a></dt>
<dd><p>Reconstruct a 3-D or 4-D image from image_vector object obj
[voldata, vectorized_voldata, xyz_coord_struct] = reconstruct_image(obj)</p>
<p>voldata is and X x Y x Z x Images matrix
vectorized_voldata is the same, with all voxels vectorized</p>
<p>This output has one element for every voxel in THE ENTIRE IMAGE, and so
can be very memory-intensive.  But it&#8217;s useful for lining up voxels
across images with different masks/in-mask voxels.</p>
<p>This function returns output in memory;
see image_vector.write for writing .img files to disk.</p>
<dl class="docutils">
<dt><em>Outputs:</em></dt>
<dd><ul class="first last">
<li><p class="first">voldata : 3-D recon volume</p>
</li>
<li><p class="first">vectorized_voldata : volume in column vetor, iimg_xxx function format</p>
</li>
<li><dl class="first docutils">
<dt>xyz_coord_struct <span class="classifier-delimiter">:</span> <span class="classifier">has fields with coordinate information in mm (world) space</span></dt>
<dd><ul class="first last simple">
<li>x, y, z : vectors of coordinates in mm for each of the 3
dimensions of the image</li>
<li>X, Y, Z : output matrices from meshgrid with mm coordinates,
for volume visualization.
These can be passed to surf or isocaps functions for volume
visualization in world space (mm).</li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
<p>Copyright 2011 tor wager</p>
<p><em>Programmers&#8217; notes:</em></p>
<p>Aug 2012: This function does not flip the data based on the sign of x dimension.  
The flipping is applied in image writing / display in
iimg_reconstruct_vols, write method, spm_orthviews, etc.</p>
<p>July 2013 : Tor : Added xyz_coord_struct output</p>
</dd></dl>

<dl class="function">
<dt id="&#64;image_vector.remove_empty">
<code class="descclassname">&#64;image_vector.</code><code class="descname">remove_empty</code><span class="sig-paren">(</span><em>dat</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@image_vector.remove_empty" title="Permalink to this definition">¶</a></dt>
<dd><p>dat = remove_empty(dat, [logical vector of custom voxels to remove], [logical vector of imgs to remove])</p>
<p>remove vox: logical vector of custom voxels to remove, VOX x 1</p>
<p>remove im: logical vector of custom images to remove, 1 x IMAGES</p>
<p>indices of removed data will be stored in removed_voxels and
removed_images fields, to preserve ability to later reconstruct into 3D images</p>
<p>Indicator vectors stored in:
removed_images
removed_voxels</p>
<p><em>See also:</em> replace_empty
force logical</p>
</dd></dl>

<dl class="function">
<dt id="&#64;image_vector.reparse_contiguous">
<code class="descclassname">&#64;image_vector.</code><code class="descname">reparse_contiguous</code><span class="sig-paren">(</span><em>obj</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@image_vector.reparse_contiguous" title="Permalink to this definition">¶</a></dt>
<dd><p>obj = reparse_contiguous(obj, [&#8216;nonempty&#8217;])</p>
<p>Re-construct list of contiguous voxels in an image based on in-image
voxel coordinates.  Coordinates are taken from obj.volInfo.xyzlist.</p>
<p>Results are saved in obj.volInfo.cluster.</p>
<p>xyzlist can be generated from iimg_read_img, and is done automatically by
object-oriented fMRI image classes (fmri_image, image_vector,
statistic_image)</p>
<p>If &#8216;nonempty&#8217; is entered as an optional argument, will use only voxels
that are non-zero, non-nan in all columns of obj.dat.</p>
<p>copyright tor wager, 2011
<em>Programmers&#8217; notes:</em></p>
<dl class="docutils">
<dt>Edited 1/27/13 by tor to use all columns when calculating &#8216;nonempty&#8217;</dt>
<dd>also fixed bug - was not using &#8216;nonempty&#8217; input in some
cases</dd>
</dl>
<p>.cluster and .xyzlist should both always be length v in-mask voxels
if &#8216;nonempty&#8217; is entered, then .dat should be length v in-mask voxels too</p>
</dd></dl>

<dl class="function">
<dt id="&#64;image_vector.replace_empty">
<code class="descclassname">&#64;image_vector.</code><code class="descname">replace_empty</code><span class="sig-paren">(</span><em>obj</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@image_vector.replace_empty" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Replace empty/missing values in an image data object</dt>
<dd><ul class="first last simple">
<li>obj = replace_empty(obj, [optional keywords])</li>
</ul>
</dd>
</dl>
<p>Replace missing values in obj.dat stored in obj.removed_voxels and
obj.removed_images with zeros.  This returns obj.dat in a format that can
be reconstructed into a 3-D or 4-D image matrix for brain visualization.</p>
<p><em>Optional keywords:</em></p>
<p>&#8216;voxels&#8217; or &#8216;images&#8217;: replace only missing voxels/images</p>
<p>Tor Wager, 12/1/10</p>
<p><em>See also:</em> remove_empty, zeroinsert, nanremove, naninsert</p>
</dd></dl>

<dl class="function">
<dt id="&#64;image_vector.resample_space">
<code class="descclassname">&#64;image_vector.</code><code class="descname">resample_space</code><span class="sig-paren">(</span><em>obj</em>, <em>sampleto</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@image_vector.resample_space" title="Permalink to this definition">¶</a></dt>
<dd><p>Resample the images in an fmri_data object (obj) to the space of another
image (sampleto; e.g., a mask image). Works for all image_vector objects.</p>
<blockquote>
<div><ul class="simple">
<li>obj = resample_space(obj, sampleto, [sampling method])</li>
</ul>
</div></blockquote>
<dl class="docutils">
<dt>Sampleto may be one of these:</dt>
<dd><ol class="first last arabic simple">
<li>a volInfo structure (the image does not have to exist on the path)</li>
<li>an image_vector, fmri_data, fmri_mask_image object</li>
<li>a string with the name of an image</li>
</ol>
</dd>
</dl>
<p>Can enter resampling method as optional input. Takes any input to
interp3:</p>
<blockquote>
<div><p>&#8216;nearest&#8217; - nearest neighbor interpolation
&#8216;linear&#8217;  - linear interpolation (default)
&#8216;spline&#8217;  - spline interpolation
&#8216;cubic&#8217;   - cubic interpolation as long as the data is uniformly</p>
<blockquote>
<div>spaced, otherwise the same as &#8216;spline&#8217;</div></blockquote>
</div></blockquote>
<p><em>Examples:</em></p>
<p>label_mask = fmri_data(which(&#8216;atlas_labels_combined.img&#8217;));
label_mask = resample_space(label_mask, ivec, &#8216;nearest&#8217;) % resamples and masks label image
<em>Programmers&#8217; notes:</em></p>
<p>1/27/2012 Tor edited to handle .mask field in fmri_data and .sig field in
statistic_image.  Was causing errors otherwise...</p>
<blockquote>
<div>Also changed automatic behavior to reparse contig voxels with
&#8216;nonempty&#8217; in output obj</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="&#64;image_vector.resample_time">
<code class="descclassname">&#64;image_vector.</code><code class="descname">resample_time</code><span class="sig-paren">(</span><em>obj</em>, <em>source_TR</em>, <em>target_TR</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@image_vector.resample_time" title="Permalink to this definition">¶</a></dt>
<dd><p>Resample the time-series images (source_time_interval) in an fmri_data object (obj) 
to the different time series (target_time_interval). Works for all image_vector objects.</p>
<blockquote>
<div><ul class="simple">
<li>obj = resample_time(obj, source_time_interval, target_time_interval, varargin)</li>
</ul>
</div></blockquote>
<dl class="docutils">
<dt><em>Options:</em></dt>
<dd><ol class="first last arabic">
<li><dl class="first docutils">
<dt>&#8216;meth&#8217; (Interpolation methods)</dt>
<dd><dl class="first last docutils">
<dt>You can enter resampling method as optional input. Takes any input to</dt>
<dd><ul class="first last">
<li><p class="first">&#8216;nearest&#8217; - nearest neighbor interpolation</p>
</li>
<li><p class="first">&#8216;linear&#8217;  - linear interpolation (default)</p>
</li>
<li><p class="first">&#8216;spline&#8217;  - spline interpolation</p>
</li>
<li><dl class="first docutils">
<dt>&#8216;cubic&#8217;   - cubic interpolation as long as the data is uniformly</dt>
<dd><p class="first last">spaced, otherwise the same as &#8216;spline&#8217;</p>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</dd>
</dl>
</li>
<li><p class="first">&#8216;slice&#8217; (a fraction of the slice timing correction)
The default is 0.5, meaning if your TR is 2s, the time point of your TR image
will be considered as the middle point of the TR bins. You can use this option
to use different time points. If you are upsampling your data (i.e.,
your target TR is shorter than your source TR), you need to discard the
first column of your data. This function will return the first time point data as NaN.</p>
</li>
</ol>
</dd>
</dl>
<p><em>Examples:</em></p>
<blockquote>
<div><ul class="simple">
<li>dat = fmri_data(&#8216;/Volumes/RAID1/labdata/current/BMRK3/Imaging/spatiotemp_biomarker/STmarker1.img&#8217;);</li>
<li>dat = resample_time(dat, 2, 1.3)</li>
</ul>
</div></blockquote>
<dl class="docutils">
<dt>with options:</dt>
<dd><ul class="first last simple">
<li>dat = resample_time(dat, 2, 1.3, &#8216;meth&#8217;, &#8216;linear&#8217;, &#8216;slice&#8217;, .3)</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="&#64;image_vector.sagg_slice_movie">
<code class="descclassname">&#64;image_vector.</code><code class="descname">sagg_slice_movie</code><span class="sig-paren">(</span><em>dat</em><span class="optional">[</span>, <em>full_path_of_movie_output_file</em>, <em>image_skip_interval</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#@image_vector.sagg_slice_movie" title="Permalink to this definition">¶</a></dt>
<dd><p>Movie of successive differences (sagittal slice)
Enter an image_vector or fmri_data object (usually with time series)</p>
<p><em>Optional inputs:</em></p>
<blockquote>
<div><dl class="docutils">
<dt>movie_output_file: a char array detailing the full path to save the</dt>
<dd>movie file</dd>
<dt>image_skip_interval: a integer value describing the interval </dt>
<dd>between images in each subsequent frame of the movie 
(default = 1)</dd>
</dl>
</div></blockquote>
<dl class="docutils">
<dt><em>Example:</em></dt>
<dd><ul class="first">
<li><dl class="first docutils">
<dt>sagg_slice_movie(fmri_dat, ...</dt>
<dd><p class="first last">&#8216;/Volumes/engram/labdata/fmri_data/Study1/Subj1/qc_images&#8217;, 5)</p>
</dd>
</dl>
</li>
</ul>
<p class="last">This would save an movie based on the images in fmri_dat to the
above directory, with an interval of 5 images between each
frame (so, the movie would show image 1, 6, 11, 16, etc)</p>
</dd>
<dt>Edited 8/7/14 by Scott</dt>
<dd><ul class="first simple">
<li>added skip interval</li>
<li>updated help</li>
</ul>
<p class="last">8/7/14 Programmer Note: if more varargin options are desired in the
future, the function call will likely need to be re-written. The
current form exists for backwards compatibility - obviously changing
the function call will mean that other functions that use this
(preproc) will need to be modified</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="&#64;image_vector.searchlight">
<code class="descclassname">&#64;image_vector.</code><code class="descname">searchlight</code><span class="sig-paren">(</span><em>dat</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@image_vector.searchlight" title="Permalink to this definition">¶</a></dt>
<dd><p>Run searchlight multivariate prediction/classification on an image_vector
or fmri_data object OR two objects, for cross-prediction.</p>
<p><em>Usage:</em></p>
<p>[list outputs here] = function_name(list inputs here, [optional inputs])
[results_obj, indx] = searchlight(dat, [optional inputs])</p>
<dl class="docutils">
<dt><em>Features:</em></dt>
<dd><ul class="first last simple">
<li>Runs searchlight with standard, pre-defined algorithms</li>
<li>Custom-entry definition of holdout sets</li>
<li>Can re-use searchlight spheres after initial definition</li>
<li>Custom-entry definition of any spheres/regions of interest</li>
<li>Uses Matlab&#8217;s parallel processing toolbox (parfor)</li>
</ul>
</dd>
</dl>
<p>Type help image_vector.searchlight to display this help information</p>
<p>Author and copyright information:</p>
<blockquote>
<div><p>Copyright (C) 2014  Tor Wager and...</p>
<p>This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.</p>
<p>This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.</p>
<p>You should have received a copy of the GNU General Public License
along with this program.  If not, see &lt;<a class="reference external" href="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</a>&gt;.</p>
</div></blockquote>
<p><em>Inputs:</em></p>
<blockquote>
<div><ul class="simple">
<li>dat           image_vector or fmri_data object with data</li>
<li>dat.Y         required: true outcomes for each observation (image) in dat</li>
</ul>
</div></blockquote>
<dl class="docutils">
<dt><em>Optional:</em> Keyword followed by input variable:</dt>
<dd><ul class="first last">
<li><p class="first">&#8216;r&#8217;         searchlight radius, voxels</p>
</li>
<li><p class="first">&#8216;dat2&#8217;      second dataset, for cross-prediction</p>
</li>
<li><dl class="first docutils">
<dt>&#8216;indx&#8217;      sparse logical matrix. each COLUMN is index of inclusion sets for each region/sphere in searchlight</dt>
<dd><p class="first last">This takes a long time to calculate, but can be saved and
re-used for a given mask</p>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
<p><em>Outputs:</em></p>
<blockquote>
<div><ul>
<li><p class="first">results_obj   fmri_data object with results maps</p>
</li>
<li><p class="first">stats         selected statistics for each sphere in searchlight</p>
</li>
<li><dl class="first docutils">
<dt>indx          sparse logical matrix. each COLUMN is index of inclusion sets for each region/sphere in searchlight</dt>
<dd><ul class="first simple">
<li>this can be re-used for all data with the same</li>
</ul>
<p class="last">mask/structure. *</p>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
<p><em>Examples:</em></p>
<dl class="docutils">
<dt>Define a sensible gray-matter mask:</dt>
<dd><ul class="first last simple">
<li>dat = fmri_data(which(&#8216;scalped_avg152T1_graymatter.img&#8217;));</li>
<li>dat = threshold(dat, [.8 Inf], &#8216;raw-between&#8217;);</li>
<li>dat = trim_mask(dat);</li>
</ul>
</dd>
<dt>Create fake data and holdout indicator index vector</dt>
<dd><ul class="first last simple">
<li>dat.dat = randn(dat.volInfo.n_inmask, 30);</li>
<li>dat.Y = dat.dat(111111, :)&#8217; + .3 * randn(30, 1);</li>
<li>holdout_set = ones(6, 1); for i = 2:5, holdout_set = [holdout_set; i*ones(6, 1)]; end</li>
</ul>
</dd>
<dt>Run, and run again with existing indx</dt>
<dd><ul class="first last simple">
<li>pool = parpool(12);  % initialize parallel processing (12 cores)</li>
<li>[results_obj, indx] = searchlight(dat, &#8216;holdout_set&#8217;, holdout_set);</li>
<li>results_obj = searchlight(dat, &#8216;holdout_set&#8217;, holdout_set, &#8216;indx&#8217;, indx);</li>
</ul>
</dd>
</dl>
<p><em>See also:</em>
region.m, fmri_data.predict.m
<em>Programmers&#8217; notes:</em>
List dates and changes here, and author of changes
&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;-
DEFAULTS AND INPUTS
&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;-
For defining regions</p>
</dd></dl>

<dl class="function">
<dt id="&#64;image_vector.slices">
<code class="descclassname">&#64;image_vector.</code><code class="descname">slices</code><span class="sig-paren">(</span><em>obj</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@image_vector.slices" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a montage of single-slice results for every image in an
image_vector object</p>
<blockquote>
<div><ul class="simple">
<li>o = slices(obj, &#8216;orientation&#8217;, [orientation], &#8216;slice&#8217;, [slice_mm], &#8216;nimages&#8217;, [nimgs])</li>
</ul>
</div></blockquote>
<p>obj is an image_vector, fmri_data, or statistic_image object with
multiple images (only the first 64 will display), which are stored as
columns in its .dat field.</p>
<dl class="docutils">
<dt><em>Optional inputs:</em></dt>
<dd><ul class="first last simple">
<li>&#8216;orientation&#8217; can be followed by &#8216;saggital&#8217;, &#8216;axial&#8217;, or &#8216;coronal&#8217;</li>
<li>&#8216;slice_mm&#8217; is followed by the mm coord of the slice to display; default = 0</li>
<li>&#8216;nimgs&#8217; can be followed by the number of images to display, 1:nimgs</li>
<li>&#8216;names&#8217; is followed by a cell array of names for the images.</li>
<li>&#8216;color&#8217; is followed by color vector or string specification. default is</li>
<li>color-mapped with split colors (hot/cool) for pos and neg effects.</li>
<li>&#8216;outline&#8217; is followed by a color vector for outline around blobs.</li>
</ul>
</dd>
</dl>
<p>The output, o, is an fmridisplay object.</p>
<p>This function uses fmridisplay objects, and may be memory-intensive for
older computers.</p>
<p><em>Common Errors:</em></p>
<p>This function uses the volInfo.cluster field. If you create a mask in an
ad hoc way, this field may not be updated.  use this to fix:
mask = reparse_contiguous(mask);</p>
<p><em>Examples:</em></p>
<blockquote>
<div><ul class="simple">
<li>slices(dat);</li>
<li>slices(dat, &#8216;orientation&#8217;, &#8216;axial&#8217;);</li>
<li>slices(dat, &#8216;slice&#8217;, -5);                 % display sagg at x = -5</li>
<li>o = slices(dat, &#8216;names&#8217;, terms); % use &#8216;terms&#8217; var as names</li>
<li>o2 = slices(all_chi2_images, &#8216;orientation&#8217;, &#8216;saggital&#8217;, &#8216;slice&#8217;, 0);</li>
</ul>
</div></blockquote>
<p>Copyright 2011, Tor Wager</p>
</dd></dl>

<dl class="function">
<dt id="&#64;image_vector.surface">
<code class="descclassname">&#64;image_vector.</code><code class="descname">surface</code><span class="sig-paren">(</span><em>obj</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@image_vector.surface" title="Permalink to this definition">¶</a></dt>
<dd><p>[all_surf_handles, pcl, ncl] = surface(obj)</p>
<dl class="docutils">
<dt><em>Usage:</em></dt>
<dd><ul class="first last simple">
<li>[all_surf_handles, pcl, ncl] = surface(r, [&#8216;cutaways&#8217;, any optional inputs to surface_cutaway])</li>
</ul>
</dd>
</dl>
<p>This function uses region.surface to create surface figures.
See help region.surface for options.</p>
<p><em>Examples:</em></p>
<dl class="docutils">
<dt>create an initial surface plot from an fmri_data object:</dt>
<dd><ul class="first last simple">
<li>han = surface(regionmasks{2});</li>
</ul>
</dd>
<dt>Now add a second region in green:</dt>
<dd><ul class="first last simple">
<li>cluster_surf(region(regionmasks{2}), {[0 1 0]}, han, 5);</li>
</ul>
</dd>
<dt>Use optional arguments taken by surface_cutaway:</dt>
<dd><ul class="first last simple">
<li>poscm = colormap_tor([1 .3 0], [1 1 0]); % orange to yellow</li>
<li>[all_surf_handles, pcl, ncl] = surface(t, &#8216;cutaway&#8217;, &#8216;ycut_mm&#8217;, -30, &#8216;pos_colormap&#8217;, poscm, &#8216;existingfig&#8217;);</li>
<li>[all_surf_handles2, pcl, ncl] = surface(t, &#8216;foursurfaces&#8217;, &#8216;pos_colormap&#8217;, poscm, &#8216;neg_colormap&#8217;, negcm);</li>
<li>[all_surf_handles2, pcl, ncl] = surface(t, &#8216;foursurfaces&#8217;, &#8216;existingfig&#8217;, &#8216;color_upperboundpercentile&#8217;, 95, &#8216;color_lowerboundpercentile&#8217;, 5, &#8216;neg_colormap&#8217;, colormap_tor([0 0 1], [.3 0 .5]));</li>
</ul>
</dd>
<dt>use mediation_brain_surface_figs and re-make colors</dt>
<dd><ul class="first last simple">
<li>all_surf_handles = mediation_brain_surface_figs([]);</li>
<li>surface(t2, &#8216;cutaway&#8217;, &#8216;surface_handles&#8217;, all_surf_handles, &#8216;color_upperboundpercentile&#8217;, 95, &#8216;color_lowerboundpercentile&#8217;, 5, &#8216;neg_colormap&#8217;, colormap_tor([0 0 1], [.2 0 .5]));</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="&#64;image_vector.threshold">
<code class="descclassname">&#64;image_vector.</code><code class="descname">threshold</code><span class="sig-paren">(</span><em>obj</em>, <em>input_threshold</em>, <em>thresh_type</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@image_vector.threshold" title="Permalink to this definition">¶</a></dt>
<dd><p>Threshold image_vector (or fmri_data or fmri_obj_image) object based on
raw threshold values. For statistical thresholding, convert to a
statistic_image object and see the threshold method for that object.</p>
<dl class="docutils">
<dt><em>Usage:</em></dt>
<dd><ul class="first last simple">
<li>obj = threshold(obj, input_threshold, thresh_type, [optional arguments])</li>
</ul>
</dd>
</dl>
<p>This is a method for an image_vector object</p>
<p>Thresholding is not reversible. For statistic_image objects it is.</p>
<dl class="docutils">
<dt>For objects: Type methods(object_name) for a list of special commands</dt>
<dd>Type help object_name.method_name for help on specific
methods.</dd>
</dl>
<p>Author and copyright information:</p>
<blockquote>
<div><p>Copyright (C) 2015 Tor Wager</p>
<p>This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.</p>
<p>This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.</p>
<p>You should have received a copy of the GNU General Public License
along with this program.  If not, see &lt;<a class="reference external" href="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</a>&gt;.</p>
</div></blockquote>
<p><em>Inputs:</em></p>
<blockquote>
<div><ul>
<li><p class="first">obj               image_vector object</p>
</li>
<li><dl class="first docutils">
<dt>input_threshold   Vector of 2 values defining data value bounds at which</dt>
<dd><p class="first last">to threshold, e.g., [0 Inf] or [-3 3]</p>
</dd>
</dl>
</li>
<li><p class="first">thresh_type       String: &#8216;raw-between&#8217; or &#8216;raw-outside&#8217;</p>
</li>
</ul>
</div></blockquote>
<dl class="docutils">
<dt><em>Optional:</em> Argument or argument followed by value</dt>
<dd><ul class="first last simple">
<li>&#8216;k&#8217;               Followed by extent threshold cluster size, default = 1</li>
<li>&#8216;trim_mask&#8217;       Reduce the mask in obj.voInfo based on thresholding</li>
<li>&#8216;noverbose&#8217;       Suppress verbose output</li>
</ul>
</dd>
<dt><em>Outputs:</em></dt>
<dd><ul class="first last simple">
<li>obj           thresholded image_vector object</li>
</ul>
</dd>
</dl>
<p><em>Examples:</em></p>
<dl class="docutils">
<dt>Retain positive values, cluster extent &gt; 100 voxels</dt>
<dd><ul class="first last simple">
<li>obj = threshold(obj, [0 Inf], &#8216;raw-between&#8217;, &#8216;k&#8217;, 100)</li>
</ul>
</dd>
<dt>Retain voxels with absolute value &gt; 3</dt>
<dd><ul class="first last simple">
<li>obj = threshold(obj, [-3 3], &#8216;raw-outside&#8217;)</li>
</ul>
</dd>
</dl>
<p><em>See also:</em>
statistic_image.threshold, statistic_image.multi_threshold
<em>Programmers&#8217; notes:</em>
Tor: Updated documentation, July 2015
Inputs
&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;-</p>
</dd></dl>

<dl class="function">
<dt id="&#64;image_vector.trim_mask">
<code class="descclassname">&#64;image_vector.</code><code class="descname">trim_mask</code><span class="sig-paren">(</span><em>obj</em><span class="sig-paren">)</span><a class="headerlink" href="#@image_vector.trim_mask" title="Permalink to this definition">¶</a></dt>
<dd><p>Exclude empty voxels from mask information in obj.volInfo structure, and re-make obj.volInfo</p>
<blockquote>
<div><ul class="simple">
<li>obj = trim_mask(obj)</li>
</ul>
</div></blockquote>
<p>Tor Wager, 2013</p>
</dd></dl>

<dl class="function">
<dt id="&#64;image_vector.union">
<code class="descclassname">&#64;image_vector.</code><code class="descname">union</code><span class="sig-paren">(</span><em>dat1</em>, <em>dat2</em>, <em>outputname</em><span class="sig-paren">)</span><a class="headerlink" href="#@image_vector.union" title="Permalink to this definition">¶</a></dt>
<dd><p>Union and intersection masks for two image_vector objects</p>
<blockquote>
<div><ul>
<li><p class="first">[dat_union, dat_intersection] = union(dat1, dat2, outputname)</p>
</li>
<li><p class="first">dat = union(dat1, dat2, outputname)
outputname = character array name for union image</p>
<blockquote>
<div><p>INCLUDE .img at the end.</p>
</div></blockquote>
</li>
</ul>
</div></blockquote>
<p>NOTE: must now be in same space!</p>
<p>tor</p>
</dd></dl>

<dl class="function">
<dt id="&#64;image_vector.write">
<code class="descclassname">&#64;image_vector.</code><code class="descname">write</code><span class="sig-paren">(</span><em>obj</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@image_vector.write" title="Permalink to this definition">¶</a></dt>
<dd><p>Write an image_vector object to an Analyze image.
Option to write thresholded image, for statistic_image objects.</p>
<p>obj.dat should contain data, with one COLUMN for each 3-D frame in the
4-D image to be written.</p>
<p><em>Usage:</em></p>
<blockquote>
<div><ul class="simple">
<li>write(obj)  -&gt; writes to the image(s) specified in obj.fullpath</li>
<li>write(obj, &#8216;thresh&#8217;) -&gt; for statistic_image objects, writes thresholded</li>
<li>write(obj, &#8216;fname&#8217;, &#8216;~/Documents/test.nii&#8217;)  -&gt; writes the image(s) to specific path</li>
</ul>
</div></blockquote>
<p><em>For example:</em> 
If m is an image_vector object,</p>
<blockquote>
<div><ul class="simple">
<li>m.X(m.X &lt; .12) = 0; % apply an arbitrary but reasonable custom threshold</li>
<li>orthviews(m);</li>
</ul>
</div></blockquote>
<dl class="docutils">
<dt>write the thresholded image to disk:</dt>
<dd><ul class="first last simple">
<li>anatmeanname = &#8216;mean_gray_matter_mask.img&#8217;;</li>
<li>m.filename = anatmeanname;</li>
<li>m.fullpath = fullfile(maskdir, anatmeanname);</li>
<li>write(m)</li>
</ul>
</dd>
<dt><em>Option:</em></dt>
<dd><dl class="first docutils">
<dt>&#8216;mni&#8217;       resample image to standard MNI FOV (91x109x91)</dt>
<dd>uses mri_data.resample_space</dd>
</dl>
<p>&#8216;keepdt&#8217;    output image will be keep original data type (default = float32)
&#8216;fname&#8217;     writes out image to specific file name.  &#8216;fname&#8217; must be</p>
<blockquote class="last">
<div>followed by image name with path</div></blockquote>
</dd>
</dl>
<p>2013/3/5: Luk[ea] added &#8216;mni&#8217; option</p>
<p>2013/3/25: Luke[ea] added optional input to retain original datatype</p>
<p>2014/3/14: Luke added &#8216;fname&#8217; option to specify filename</p>
</dd></dl>

</div>
<div class="section" id="module-&#64;region">
<span id="region"></span><h1>region<a class="headerlink" href="#module-@region" title="Permalink to this headline">¶</a></h1>
<dl class="function">
<dt id="&#64;region.check_extracted_data">
<code class="descclassname">&#64;region.</code><code class="descname">check_extracted_data</code><span class="sig-paren">(</span><em>cl</em><span class="sig-paren">)</span><a class="headerlink" href="#@region.check_extracted_data" title="Permalink to this definition">¶</a></dt>
<dd><p>isok = check_extracted_data(cl)</p>
<p>cl must be a valid region object (see region.m)
and cl(1).source_images must still be on the path.</p>
<p>Checks the data, just in case of space/programming issues, 
by re-extracting the region average data from 5 random regions 
using spm_get_data.m, and compares it to the already-saved values</p>
<p>You should not need to run this regularly &#8211; but you should if you
suspect things have gone awry.</p>
</dd></dl>

<dl class="function">
<dt id="&#64;region.extract_data">
<code class="descclassname">&#64;region.</code><code class="descname">extract_data</code><span class="sig-paren">(</span><em>r</em>, <em>data_obj</em><span class="sig-paren">)</span><a class="headerlink" href="#@region.extract_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Extract data from image_vector object (data_obj) for voxels specified by a region object (r)
Returns extracted data and averages</p>
<p><em>Features:</em></p>
<p>data_obj does not have to be in the same space, uses mm coordinates</p>
<dl class="docutils">
<dt><em>Usage:</em></dt>
<dd><ul class="first last simple">
<li>region_obj = extract_data(region_obj, data_obj)</li>
</ul>
</dd>
</dl>
<p>Type methods(region) for a list of special commands for region object
Type help object_name.method_name for help on specific methods.</p>
<p>Author and copyright information:</p>
<blockquote>
<div><p>Copyright (C) 2010 Tor Wager</p>
<p>This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.</p>
<p>This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.</p>
<p>You should have received a copy of the GNU General Public License
along with this program.  If not, see &lt;<a class="reference external" href="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</a>&gt;.</p>
</div></blockquote>
<dl class="docutils">
<dt><em>Inputs:</em></dt>
<dd><ul class="first last">
<li><p class="first">r           a region object</p>
</li>
<li><dl class="first docutils">
<dt>data_obj    an image_vector or fmri_data object to extract data from</dt>
<dd><p class="first last">does not have to be in the same space, uses mm coordinates</p>
</dd>
</dl>
</li>
</ul>
</dd>
<dt><em>Outputs:</em></dt>
<dd><ul class="first last simple">
<li>r           a region object, with data attached</li>
</ul>
</dd>
</dl>
<p><em>Examples:</em>
give examples here</p>
<p><em>See also:</em>
list other functions related to this one, and alternatives*</p>
<p><em>Programmers&#8217; notes:</em></p>
<p>8/3/2015 Tor Wager: Fixed bug in averaging when only 1 voxel in region</p>
</dd></dl>

<dl class="function">
<dt id="&#64;region.merge">
<code class="descclassname">&#64;region.</code><code class="descname">merge</code><span class="sig-paren">(</span><em>cl</em>, <em>wh_merge</em><span class="sig-paren">)</span><a class="headerlink" href="#@region.merge" title="Permalink to this definition">¶</a></dt>
<dd><p>Merge two or more regions together in a region object.
Combines fields from all clusters in the named series with the first one
in the series.</p>
<blockquote>
<div><ul class="simple">
<li>wh_merge = [3 4];</li>
<li>cl = merge(cl, wh_merge)</li>
</ul>
</div></blockquote>
<p>Tor Wager, April 2011</p>
</dd></dl>

<dl class="function">
<dt id="&#64;region.posneg_separate">
<code class="descclassname">&#64;region.</code><code class="descname">posneg_separate</code><span class="sig-paren">(</span><em>cl</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@region.posneg_separate" title="Permalink to this definition">¶</a></dt>
<dd><p>Separate a region object (cl) into clusters with positive and negative
peak values, based on max (peak) value in .val or .Z field (default =
val)</p>
<blockquote>
<div><ul class="simple">
<li>[pcl, ncl] = posneg_separate(cl, [&#8216;Z&#8217;])</li>
</ul>
</div></blockquote>
<p>Returns pcl and ncl, region structures with positive- and negative-valued
peaks, respectively, copied from the original cl input.</p>
<p><em>Optional input:</em> &#8216;Z&#8217;, to use .Z field</p>
<dl class="docutils">
<dt><em>Note:</em> You may have to use reparse_continguous to get this to work right.</dt>
<dd><ul class="first last simple">
<li>r = reparse_continguous(r);</li>
<li>[pcl, ncl] = posneg_separate(r);</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="&#64;region.region2imagevec">
<code class="descclassname">&#64;region.</code><code class="descname">region2imagevec</code><span class="sig-paren">(</span><em>cl</em><span class="sig-paren">)</span><a class="headerlink" href="#@region.region2imagevec" title="Permalink to this definition">¶</a></dt>
<dd><p>[ivecobj, orig_cluster_indx]  = region2imagevec(cl)</p>
<p>Convert a region object to an image_vector object, replacing the voxels
and reconstructing as much info as possible.</p>
<p>The .dat field of the new &#8220;ivecobj&#8221; is made from the cl.all_data field.
if this is empty, uses cl.val field, then cl.Z as a backup.
Mask information is available in ivecobj.volInfo.</p>
<blockquote>
<div><ul class="simple">
<li>ivecobj = region2imagevec(cl)</li>
</ul>
</div></blockquote>
<p>NEEDS SOME ADDITIONAL WORK/CHECKING</p>
</dd></dl>

<dl class="function">
<dt id="&#64;region.region2imagevec2tmp">
<code class="descclassname">&#64;region.</code><code class="descname">region2imagevec2tmp</code><span class="sig-paren">(</span><em>cl</em><span class="sig-paren">)</span><a class="headerlink" href="#@region.region2imagevec2tmp" title="Permalink to this definition">¶</a></dt>
<dd><p>[ivecobj, orig_cluster_indx]  = region2imagevec2tmp(cl)</p>
<p>Convert a region object to an image_vector object, replacing the voxels
and reconstructing as much info as possible.</p>
<p>The .dat field of the new &#8220;ivecobj&#8221; is made from the cl.all_data field.
if this is empty, uses cl.val field, then cl.Z as a backup.
Mask information is available in ivecobj.volInfo.</p>
<blockquote>
<div><ul class="simple">
<li>ivecobj = region2imagevec(cl)</li>
</ul>
</div></blockquote>
<p>NEEDS SOME ADDITIONAL WORK/CHECKING</p>
</dd></dl>

<dl class="function">
<dt id="&#64;region.region2struct">
<code class="descclassname">&#64;region.</code><code class="descname">region2struct</code><span class="sig-paren">(</span><em>cl</em><span class="sig-paren">)</span><a class="headerlink" href="#@region.region2struct" title="Permalink to this definition">¶</a></dt>
<dd><p>cl = region2struct(cl)</p>
<p>Convert a region object to a simple structure, primarily for
compatibility with other, older CANlab tools.</p>
<p>see also cluster2region, for the reverse transformation</p>
</dd></dl>

<dl class="function">
<dt id="&#64;region.reparse_continguous">
<code class="descclassname">&#64;region.</code><code class="descname">reparse_continguous</code><span class="sig-paren">(</span><em>cl</em><span class="sig-paren">)</span><a class="headerlink" href="#@region.reparse_continguous" title="Permalink to this definition">¶</a></dt>
<dd><p>Re-define regions in region object based on contiguous blobs</p>
<blockquote>
<div><ul class="simple">
<li>clout = reparse_continguous(cl)</li>
</ul>
</div></blockquote>
<p>NEEDS SOME ADDITIONAL WORK/CHECKING</p>
</dd></dl>

<dl class="function">
<dt id="&#64;region.subdivide_by_atlas">
<code class="descclassname">&#64;region.</code><code class="descname">subdivide_by_atlas</code><span class="sig-paren">(</span><em>r</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@region.subdivide_by_atlas" title="Permalink to this definition">¶</a></dt>
<dd><p>r = subdivide_by_atlas(r, [atlas name])</p>
<dl class="docutils">
<dt><em>Inputs:</em></dt>
<dd><ul class="first last">
<li><p class="first">r = a region object, defined using region(mask)</p>
</li>
<li><dl class="first docutils">
<dt>atlas name: Optional mask image with integer codes defining in-mask</dt>
<dd><p class="first last">regions.  Default is &#8216;atlas_labels_combined.img&#8217;</p>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
<p><em>Output:</em> A region object with separate clusters for each contiguous blob,
subdivided by regions labeled in atlas.</p>
<dl class="docutils">
<dt><em>Example:</em></dt>
<dd><ul class="first last simple">
<li>r = subdivide_by_atlas(r);</li>
<li>r(cat(1, r.numVox) &lt; 20) = []; % get rid of small regions</li>
<li>cluster_orthviews(r, &#8216;unique&#8217;);</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="&#64;region.subdivide_by_local_max">
<code class="descclassname">&#64;region.</code><code class="descname">subdivide_by_local_max</code><span class="sig-paren">(</span><em>r</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@region.subdivide_by_local_max" title="Permalink to this definition">¶</a></dt>
<dd><p>Subdivide regions into sub-regions based on local peak Z-scores/maxima</p>
<dl class="docutils">
<dt><em>Usage:</em></dt>
<dd><ul class="first last simple">
<li>subregions = subdivide_by_local_max(r, [&#8216;mm_distance&#8217;, value], [&#8216;noorthviews&#8217;])</li>
</ul>
</dd>
<dt>For objects: Type methods(object_name) for a list of special commands</dt>
<dd>Type help object_name.method_name for help on specific
methods.</dd>
</dl>
<p>Author and copyright information:</p>
<blockquote>
<div><p>Copyright (C) 2015 Tor Wager</p>
<p>This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.</p>
<p>This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.</p>
<p>You should have received a copy of the GNU General Public License
along with this program.  If not, see &lt;<a class="reference external" href="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</a>&gt;.</p>
</div></blockquote>
<dl class="docutils">
<dt><em>Inputs:</em> All Optional</dt>
<dd><ul class="first last simple">
<li>&#8216;mm_distance&#8217;     Followed by mm distance minimum for dividing subclusters</li>
<li>&#8216;noorthviews&#8217;     Suppress display of orthviews</li>
</ul>
</dd>
<dt><em>Outputs:</em></dt>
<dd><ul class="first last simple">
<li>subregions        subdivided region object</li>
</ul>
</dd>
</dl>
<p><em>Examples:</em>
give examples here</p>
<p><em>See also:</em></p>
<p>region.subdivide_by_atlas, subclusters_from_local_max, cluster_local_maxima</p>
<p>Programmers&#8217; notes:
List dates and changes here, and author of changes</p>
<p>BELOW IS A STANDARD TEMPLATE FOR DEFINING VARIABLE (OPTIONAL) INPUT
ARGUMENTS. MANY FUNCTIONS NEED TO PARSE OPTIONAL ARGS, SO THIS MAY BE
USEFUL.</p>
</dd></dl>

<dl class="function">
<dt id="&#64;region.surface">
<code class="descclassname">&#64;region.</code><code class="descname">surface</code><span class="sig-paren">(</span><em>r</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@region.surface" title="Permalink to this definition">¶</a></dt>
<dd><p>Surface method for region object - renders blobs on multiple types of 3-D surface</p>
<dl class="docutils">
<dt><em>Usage:</em></dt>
<dd><ul class="first last simple">
<li>[all_surf_handles, pcl, ncl] = surface(r, [&#8216;cutaways&#8217;, any optional inputs to surface_cutaway])</li>
</ul>
</dd>
</dl>
<blockquote>
<div><p>Copyright (C) 2013 Tor Wager</p>
<p>This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.</p>
<p>This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.</p>
<p>You should have received a copy of the GNU General Public License
along with this program.  If not, see &lt;<a class="reference external" href="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</a>&gt;.</p>
</div></blockquote>
<dl class="docutils">
<dt><em>Inputs:</em></dt>
<dd><ul class="first last">
<li><p class="first">r                A region object</p>
</li>
<li><dl class="first docutils">
<dt>&#8216;cutaway&#8217;        String command for rendering cutaways instead of the default</dt>
<dd><ul class="first last simple">
<li>default is call to mediation_brain_surface_figs</li>
<li>cutaways calls surface_cutaway</li>
<li>all optional arguments are passed to surface_cutaway</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>&#8216;rightsurface&#8217;   String command for rendering a right frontal cortical</dt>
<dd><p class="first last">view complementary to &#8216;cutaways&#8217;</p>
</dd>
</dl>
</li>
<li><p class="first">&#8216;foursurfaces&#8217;   Compact plots of four surfaces</p>
</li>
</ul>
</dd>
</dl>
<p>Other optional inputs to surface_cutaway
e.g., &#8216;pos_colormap&#8217;</p>
<dl class="docutils">
<dt><em>Outputs:</em></dt>
<dd><ul class="first last simple">
<li>all_surf_handles       surface patch handles</li>
<li>pcl                    region object with positive-only clusters</li>
<li>ncl                    region object with negative-only clusters</li>
</ul>
</dd>
</dl>
<p><em>Examples:</em>
Use surface(r), with optional arguments taken by surface_cutaway:</p>
<blockquote>
<div><ul class="simple">
<li>poscm = colormap_tor([1 .3 0], [1 1 0]); % orange to yellow</li>
<li>[all_surf_handles, pcl, ncl] = surface(r, &#8216;cutaway&#8217;, &#8216;ycut_mm&#8217;, -30, &#8216;pos_colormap&#8217;, poscm, &#8216;existingfig&#8217;);</li>
<li>[all_surf_handles2, pcl, ncl] = surface(r, &#8216;foursurfaces&#8217;, &#8216;pos_colormap&#8217;, poscm, &#8216;neg_colormap&#8217;, negcm);</li>
<li>[all_surf_handles2, pcl, ncl] = surface(r, &#8216;foursurfaces&#8217;, &#8216;existingfig&#8217;, &#8216;color_upperboundpercentile&#8217;, 95, &#8216;color_lowerboundpercentile&#8217;, 5, &#8216;neg_colormap&#8217;, colormap_tor([0 0 1], [.4 0 .7]));</li>
</ul>
</div></blockquote>
<dl class="docutils">
<dt>use mediation_brain_surface_figs and re-make colors</dt>
<dd><ul class="first last simple">
<li>all_surf_handles = mediation_brain_surface_figs([]);</li>
<li>surface(r, &#8216;cutaway&#8217;, &#8216;surface_handles&#8217;, all_surf_handles, &#8216;color_upperboundpercentile&#8217;, 95, &#8216;color_lowerboundpercentile&#8217;, 5, &#8216;neg_colormap&#8217;, colormap_tor([0 0 1], [.2 0 .5]));</li>
</ul>
</dd>
</dl>
<p><em>See also:</em></p>
<p>default options
optional inputs</p>
</dd></dl>

<dl class="function">
<dt id="&#64;region.table">
<code class="descclassname">&#64;region.</code><code class="descname">table</code><span class="sig-paren">(</span><em>cl</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@region.table" title="Permalink to this definition">¶</a></dt>
<dd><p>Print a table of all regions in a region object (cl)</p>
<blockquote>
<div><ul class="simple">
<li>[poscl, negcl] = table(cl, [optional inputs])</li>
</ul>
</div></blockquote>
<dl class="docutils">
<dt><em>Optional inputs:</em></dt>
<dd><ul class="first last simple">
<li>&#8216;k&#8217;           : Print only regions with k or more contiguous voxels</li>
<li>&#8216;nosep&#8217;       : do not separate cl with pos and neg effects based on peak in .val</li>
<li>&#8216;names&#8217;       : name clusters before printing to table and output; saves in .shorttitle field</li>
<li>&#8216;forcenames&#8217;  : force naming of cl by removing existing names in .shorttitle field</li>
</ul>
</dd>
</dl>
<p><em>Outputs:</em></p>
<p>Returns region objects for cl with pos and neg effects, limited by size if entered
and named if entered as optional input</p>
<p>Copyright 2011, tor wager</p>
</dd></dl>

</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">fmri_data</a></li>
<li><a class="reference internal" href="#module-&#64;fmri_mask_image">fmri_mask_image</a></li>
<li><a class="reference internal" href="#module-&#64;fmri_model">fmri_model</a></li>
<li><a class="reference internal" href="#module-&#64;fmri_timeseries">fmri_timeseries</a></li>
<li><a class="reference internal" href="#module-&#64;image_vector">image_vector</a></li>
<li><a class="reference internal" href="#module-&#64;region">region</a></li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="index.html"
                        title="previous chapter">CanlabCore documentation home</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/moduleslist.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="mat-modindex.html" title="MATLAB Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="index.html" title="CanlabCore documentation home"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">CanlabCore 1.0 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &copy; Copyright 2015, Tor Wager.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.3.1.
    </div>
  </body>
</html>